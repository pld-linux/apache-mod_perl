Index: RELEASE
===================================================================
--- RELEASE	(.../tags/2_0_3)	(revision 630610)
+++ RELEASE	(.../trunk)	(revision 630610)
@@ -30,7 +30,7 @@
        make sure you give the correct permissions to them.
 
 1. 'make dist' - to make sure nothing is missing from the manifest,
-   etc. Now test this generated package mod_perl-2.0.3.tar.gz (not
+   etc. Now test this generated package mod_perl-2.0.4.tar.gz (not
    the current build) with as many
    configurations as possible on as many platforms as possible,
    unpacking the package each time afresh.  
@@ -55,7 +55,7 @@
    to the modperl/dev list (may be longer to give most people a chance
    to catch up). no need to tag this package
 
-   Subject: [RELEASE CANDIDATE]: mod_perl-2.0.3 RC\d+
+   Subject: [RELEASE CANDIDATE]: mod_perl-2.0.4 RC\d+
 
 2a. if problems are detected during stage 2, repeat stages 1 and 2.
 
@@ -82,8 +82,8 @@
 
   f. Update the svn:externals in the new tag
      (you can't propedit remotely yet in svn)
-     svn co https://svn.apache.org/repos/asf/perl/tags/2_0_3
-     svn propedit svn:xternals 2_0_3
+     svn co https://svn.apache.org/repos/asf/perl/modperl/tags/2_0_3
+     svn propedit svn:externals 2_0_3
      Update the Apache-Test line to the tag you previously created.
      Update the docs line to the current tag.
      svn ci
@@ -93,29 +93,29 @@
 
   h. test the final package again at least once
 
-4. Release the package and update links (e.g. mod_perl-2.0.3.tar.gz)
+4. Release the package and update links (e.g. mod_perl-2.0.4.tar.gz)
 
   a. upload to www.apache.org:/www/perl.apache.org/dist/
 
-    %  scp mod_perl-2.0.3.tar.gz perl.apache.org:/www/perl.apache.org/dist/
+    %  scp mod_perl-2.0.4.tar.gz perl.apache.org:/www/perl.apache.org/dist/
 
   b. ssh to perl.apache.org, unpack the package, update symlinks to the
      tar ball and unpacked distro:
 
     % ssh perl.apache.org
     % cd /www/perl.apache.org/dist/
-    % ln -sf mod_perl-2.0.3.tar.gz mod_perl-2.0-current.tar.gz
-    % tar -xzvf mod_perl-2.0.3.tar.gz
+    % ln -sf mod_perl-2.0.4.tar.gz mod_perl-2.0-current.tar.gz
+    % tar -xzvf mod_perl-2.0.4.tar.gz
     % rm /www/perl.apache.org/dist/mod_perl-2.0-current
-    % ln -sf  mod_perl-2.0.3 mod_perl-2.0-current
+    % ln -sf  mod_perl-2.0.4 mod_perl-2.0-current
 
   c. archive older releases (keep current + one prior release)
 
-    % mv /www/perl.apache.org/dist/mod_perl-2.0.0.tar.gz \
+    % mv /www/perl.apache.org/dist/mod_perl-2.0.2.tar.gz \
          /www/perl.apache.org/dist/old
-    % mv /www/perl.apache.org/dist/mod_perl-2.0.0.tar.gz.asc \
+    % mv /www/perl.apache.org/dist/mod_perl-2.0.2.tar.gz.asc \
          /www/perl.apache.org/dist/old
-    % rm -rf /www/perl.apache.org/dist/mod_perl-2.0.0
+    % rm -rf /www/perl.apache.org/dist/mod_perl-2.0.2
 
   d. update the version and release date
      modperl-docs/src/download/index_top.html and commit. It'll be
@@ -138,27 +138,27 @@
 
   a. sign your local copy of the tarball:
 
-    % gpg --detach-sign --armor mod_perl-2.0.3.tar.gz
+    % gpg --detach-sign --armor mod_perl-2.0.4.tar.gz
 
-    % pgps -b --armor mod_perl-2.0.3.tar.gz
+    % pgps -b --armor mod_perl-2.0.4.tar.gz
 
   b. upload the generated sig file to www.apache.org:
 
-    % scp mod_perl-2.0.3.tar.gz.asc perl.apache.org:/www/perl.apache.org/dist/
+    % scp mod_perl-2.0.4.tar.gz.asc perl.apache.org:/www/perl.apache.org/dist/
     % ssh www.apache.org
     % cd /www/perl.apache.org/dist/
-    % chmod 0664 mod_perl-2.0.3.tar.gz.asc
-    % ln -sf mod_perl-2.0.3.tar.gz.asc mod_perl-2.0-current.tar.gz.asc
+    % chmod 0664 mod_perl-2.0.4.tar.gz.asc
+    % ln -sf mod_perl-2.0.4.tar.gz.asc mod_perl-2.0-current.tar.gz.asc
 
   c. ask one of the other developers to double check the signature file
      and tarball: download both files and verify the signature:
 
-    http://perl.apache.org/dist/mod_perl-2.0.3.tar.gz.asc
-    http://perl.apache.org/dist/mod_perl-2.0.3.tar.gz
+    http://perl.apache.org/dist/mod_perl-2.0.4.tar.gz.asc
+    http://perl.apache.org/dist/mod_perl-2.0.4.tar.gz
 
-    % gpg --verify mod_perl-2.0.3.tar.gz.asc
+    % gpg --verify mod_perl-2.0.4.tar.gz.asc
 
-    % pgpv mod_perl-2.0.3.tar.gz.asc
+    % pgpv mod_perl-2.0.4.tar.gz.asc
 
   d. make sure that the files you just created are group rw so
      all the dist admins can make changes:
@@ -172,10 +172,10 @@
   a. unpack the package, update symlinks to the tarball and unpacked distro:
 
    % cd /www/www.apache.org/dist/perl/
-   % cp /www/perl.apache.org/dist/mod_perl-2.0.3.tar.gz* .
-   % tar -xzvf mod_perl-2.0.3.tar.gz
-   % mv mod_perl-2.0.0.tar.gz* /www/archive.apache.org/dist/perl/
-   % rm -rf mod_perl-2.0.0
+   % cp /www/perl.apache.org/dist/mod_perl-2.0.4.tar.gz* .
+   % tar -xzvf mod_perl-2.0.4.tar.gz
+   % mv mod_perl-2.0.2.tar.gz* /www/archive.apache.org/dist/perl/
+   % rm -rf mod_perl-2.0.2
 
   b. make sure that the files you just created are group rw so
 
@@ -188,11 +188,11 @@
 
   a. post ... to the modperl, announce lists
   Note, to post to announce@, you must be sending from an apache.org address.
-  Subject: [ANNOUNCE] mod_perl 2.0.3 
+  Subject: [ANNOUNCE] mod_perl 2.0.4 
      include 
   - link at perl.apache.org:
-    http://apache.org/dist/perl/mod_perl-2.0.3.tar.gz
-    http://apache.org/dist/perl/mod_perl-2.0.3.tar.gz.asc (pgp sig)
+    http://apache.org/dist/perl/mod_perl-2.0.4.tar.gz
+    http://apache.org/dist/perl/mod_perl-2.0.4.tar.gz.asc (pgp sig)
   - MD5 sig (as it comes from CPAN upload announce).
   - the latest Changes
 
@@ -203,7 +203,7 @@
   b. edit ./Changes:
      - start a new item with incremented version + '-dev'
 
-  =item 2.0.3-dev
+  =item 2.0.5-dev
 
   c. add a release entry in STATUS
 
@@ -214,7 +214,7 @@
 
   e. commit the changed files
 
-     % svn ci -m "start 2.0.3-dev cycle" Changes lib/mod_perl2.pm \
+     % svn ci -m "start 2.0.4-dev cycle" Changes lib/mod_perl2.pm \
        STATUS RELEASE
 
 10. Old Versions
Index: STATUS
===================================================================
--- STATUS	(.../tags/2_0_3)	(revision 630610)
+++ STATUS	(.../trunk)	(revision 630610)
@@ -3,6 +3,7 @@
 
 Release:
 --------
+   2.000.03   : Released Nov 29, 2006
    2.000.02   : Released Oct 20, 2005
    2.000.01   : Released Jun 17, 2005
    2.000.00   : Released May 20, 2005
Index: src/modules/perl/modperl_handler.c
===================================================================
--- src/modules/perl/modperl_handler.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_handler.c	(.../trunk)	(revision 630610)
@@ -18,7 +18,7 @@
 
 modperl_handler_t *modperl_handler_new(apr_pool_t *p, const char *name)
 {
-    modperl_handler_t *handler = 
+    modperl_handler_t *handler =
         (modperl_handler_t *)apr_pcalloc(p, sizeof(*handler));
 
     switch (*name) {
@@ -38,7 +38,7 @@
 
     handler->cv = NULL;
     handler->name = name;
-    MP_TRACE_h(MP_FUNC, "[%s] new handler %s\n",
+    MP_TRACE_h(MP_FUNC, "[%s] new handler %s",
                modperl_pid_tid(p), handler->name);
 
     return handler;
@@ -72,7 +72,7 @@
  * when perl_clone is called, each clone will clone that CV value, but
  * we will still be able to find it, since we stored it in the
  * hash. so we retrieve the CV value, whatever it is and we run it.
- * 
+ *
  * that explanation can be written and run in perl:
  *
  * use threads;
@@ -97,7 +97,7 @@
 {
     /* re-use modperl_mgv_t entry which is otherwise is not used
      * by anon handlers */
-    modperl_mgv_t *anon = 
+    modperl_mgv_t *anon =
         (modperl_mgv_t *)apr_pcalloc(p, sizeof(*anon));
 
     anon->name = apr_psprintf(p, "anon%d", modperl_global_anon_cnt_next());
@@ -157,7 +157,7 @@
 static
 modperl_handler_t *modperl_handler_new_anon(pTHX_ apr_pool_t *p, CV *cv)
 {
-    modperl_handler_t *handler = 
+    modperl_handler_t *handler =
         (modperl_handler_t *)apr_pcalloc(p, sizeof(*handler));
     MpHandlerPARSED_On(handler);
     MpHandlerANON_On(handler);
@@ -174,7 +174,7 @@
     handler->cv   = cv;
     handler->name = NULL;
 
-    MP_TRACE_h(MP_FUNC, "[%s] new cached cv anon handler\n",
+    MP_TRACE_h(MP_FUNC, "[%s] new cached cv anon handler",
                modperl_pid_tid(p));
 #endif
 
@@ -244,7 +244,7 @@
 modperl_handler_t *modperl_handler_dup(apr_pool_t *p,
                                        modperl_handler_t *h)
 {
-    MP_TRACE_h(MP_FUNC, "dup handler %s\n", modperl_handler_name(h));
+    MP_TRACE_h(MP_FUNC, "dup handler %s", modperl_handler_name(h));
     return modperl_handler_new(p, h->name);
 }
 
@@ -279,12 +279,12 @@
     for (i=0; i<base_a->nelts; i++) {
         for (j=0; j<add_a->nelts; j++) {
             if (modperl_handler_equal(base_h[i], add_h[j])) {
-                MP_TRACE_d(MP_FUNC, "both base and new config contain %s\n",
+                MP_TRACE_d(MP_FUNC, "both base and new config contain %s",
                            add_h[j]->name);
             }
             else {
                 modperl_handler_array_push(mrg_a, add_h[j]);
-                MP_TRACE_d(MP_FUNC, "base does not contain %s\n",
+                MP_TRACE_d(MP_FUNC, "base does not contain %s",
                            add_h[j]->name);
             }
         }
@@ -363,7 +363,7 @@
  * $r->push/set at request time will create entries in r->request_config
  * push will first merge with configured handlers, unless an entry
  * in r->request_config already exists.  in this case, push or set has
- * already been called for the given handler, 
+ * already been called for the given handler,
  * r->request_config entries then override those in r->per_dir_config
  */
 
@@ -427,15 +427,17 @@
         /* just a lookup */
         break;
       case MP_HANDLER_ACTION_PUSH:
-        if (ravp && !*ravp) {
-            if (*avp) {
-                /* merge with existing configured handlers */
-                *ravp = apr_array_copy(p, *avp);
+        if (ravp) {
+            if (!*ravp) {
+                if (*avp) {
+                    /* merge with existing configured handlers */
+                    *ravp = apr_array_copy(p, *avp);
+                }
+                else {
+                    /* no request handlers have been previously pushed or set */
+                    *ravp = modperl_handler_array_new(p);
+                }
             }
-            else {
-                /* no request handlers have been previously pushed or set */
-                *ravp = modperl_handler_array_new(p);
-            }
         }
         else if (!*avp) {
             /* directly modify the configuration at startup time */
@@ -514,6 +516,7 @@
         }
         name = apr_pstrcat(p, HvNAME(GvSTASH(gv)), "::", GvNAME(gv), NULL);
         return modperl_handler_new(p, apr_pstrdup(p, name));
+      default:
         break;
     };
 
@@ -530,7 +533,7 @@
         return TRUE;
     }
 
-    MP_TRACE_h(MP_FUNC, "unable to push_handler 0x%lx\n",
+    MP_TRACE_h(MP_FUNC, "unable to push_handler 0x%lx",
                (unsigned long)sv);
 
     return FALSE;
@@ -569,7 +572,7 @@
             }
 
             if (!modperl_mgv_resolve(aTHX_ handler, p, handler->name, TRUE)) {
-                MP_TRACE_h(MP_FUNC, "failed to resolve handler %s\n",
+                MP_TRACE_h(MP_FUNC, "failed to resolve handler %s",
                            handler->name);
             }
 
Index: src/modules/perl/modperl_common_types.h
===================================================================
--- src/modules/perl/modperl_common_types.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_common_types.h	(.../trunk)	(revision 630610)
@@ -26,4 +26,3 @@
 } modperl_uri_t;
 
 #endif /* MODPERL_COMMON_TYPES_H */
-
Index: src/modules/perl/modperl_handler.h
===================================================================
--- src/modules/perl/modperl_handler.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_handler.h	(.../trunk)	(revision 630610)
@@ -27,7 +27,7 @@
 MP_INLINE modperl_mgv_t *modperl_handler_anon_next(pTHX_ apr_pool_t *p);
 MP_INLINE void modperl_handler_anon_add(pTHX_ modperl_mgv_t *anon, CV *cv);
 MP_INLINE CV *modperl_handler_anon_get(pTHX_ modperl_mgv_t *anon);
-    
+
 #define modperl_handler_array_new(p) \
 apr_array_make(p, 1, sizeof(modperl_handler_t *))
 
@@ -45,7 +45,7 @@
 modperl_handler_t *modperl_handler_new_from_sv(pTHX_ apr_pool_t *p, SV *sv);
 
 MP_INLINE const char *modperl_handler_name(modperl_handler_t *handler);
-    
+
 int modperl_handler_resolve(pTHX_ modperl_handler_t **handp,
                             apr_pool_t *p, server_rec *s);
 
@@ -66,7 +66,7 @@
                                        modperl_handler_action_e action,
                                        const char **desc);
 
-MpAV **modperl_handler_get_handlers(request_rec *r, conn_rec *c,server_rec *s, 
+MpAV **modperl_handler_get_handlers(request_rec *r, conn_rec *c,server_rec *s,
                                     apr_pool_t *p, const char *name,
                                     modperl_handler_action_e action);
 
Index: src/modules/perl/modperl_apache_compat.c
===================================================================
--- src/modules/perl/modperl_apache_compat.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_apache_compat.c	(.../trunk)	(revision 630610)
@@ -27,3 +27,45 @@
  * and don't forget to insert comments explaining exactly
  * which httpd release allows us to remove the compat code
  */
+
+/* pre-APACHE_2.2.4 */
+#if ! AP_MODULE_MAGIC_AT_LEAST(20051115,4)
+
+#define modperl_warn_fallback_http_function(ver, fallback) \
+    { \
+        dTHX; \
+        Perl_warn(aTHX_ "%s() not available until httpd/%s " \
+                        "falling back to %s()", \
+                  __func__, ver, fallback); \
+    }
+
+/* added in APACHE_2.2.4 */
+AP_DECLARE(const char *) ap_get_server_description(void) {
+    modperl_warn_fallback_http_function("2.2.4", "ap_get_server_version");
+    return ap_get_server_version();
+}
+
+AP_DECLARE(const char *) ap_get_server_banner(void) {
+    modperl_warn_fallback_http_function("2.2.4", "ap_get_server_version");
+    return ap_get_server_version();
+}
+
+#endif /* pre-APACHE_2.2.4 */
+
+/* since-APACHE-2.3.0 */
+#if AP_MODULE_MAGIC_AT_LEAST(20060905,0)
+#define modperl_warn_deprecated_http_function(ver, fallback) \
+    { \
+        dTHX; \
+        Perl_warn(aTHX_ "%s() is deprecated since httpd/%s " \
+                        "try using %s() instead", \
+                  __func__, ver, fallback); \
+    }
+
+AP_DECLARE(const char *) ap_get_server_version(void) {
+    modperl_warn_deprecated_http_function("2.3.0",
+        "ap_get_server_(description|banner)");
+    return ap_get_server_banner();
+}
+
+#endif /* since-APACHE-2.3.0 */
Index: src/modules/perl/modperl_module.c
===================================================================
--- src/modules/perl/modperl_module.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_module.c	(.../trunk)	(revision 630610)
@@ -120,7 +120,7 @@
 
     modperl_svptr_table_delete(aTHX_ cleanup->table, cleanup->ptr);
 
-    MP_TRACE_c(MP_FUNC, "deleting ptr 0x%lx from table 0x%lx\n",
+    MP_TRACE_c(MP_FUNC, "deleting ptr 0x%lx from table 0x%lx",
                (unsigned long)cleanup->ptr,
                (unsigned long)cleanup->table);
 
@@ -211,7 +211,7 @@
         int count;
         dSP;
 
-        MP_TRACE_c(MP_FUNC, "calling %s->%s\n",
+        MP_TRACE_c(MP_FUNC, "calling %s->%s",
                    SvCLASS(base_obj), modperl_mgv_last_name(method));
 
         ENTER;SAVETMPS;
@@ -250,7 +250,7 @@
        modperl_interp_unselect(interp); */
     MP_PERL_CONTEXT_RESTORE;
 #endif
-    
+
     return (void *)mrg;
 }
 
@@ -296,7 +296,7 @@
         return NULL;
     }
 
-    MP_TRACE_c(MP_FUNC, "%s cfg=0x%lx for %s.%s\n",
+    MP_TRACE_c(MP_FUNC, "%s cfg=0x%lx for %s.%s",
                method, (unsigned long)cfg,
                mname, parms->cmd->name);
 
@@ -420,7 +420,7 @@
     }
 
     if (obj) {
-        MP_TRACE_c(MP_FUNC, "found per-dir obj=0x%lx for %s.%s\n",
+        MP_TRACE_c(MP_FUNC, "found per-dir obj=0x%lx for %s.%s",
                    (unsigned long)obj,
                    info->modp->name, cmd->name);
     }
@@ -440,7 +440,7 @@
         }
 
         if (srv_obj) {
-            MP_TRACE_c(MP_FUNC, "found per-srv obj=0x%lx for %s.%s\n",
+            MP_TRACE_c(MP_FUNC, "found per-srv obj=0x%lx for %s.%s",
                        (unsigned long)srv_obj,
                        info->modp->name, cmd->name);
         }
@@ -647,7 +647,7 @@
 #ifdef USE_ITHREADS
     MP_dSCFG(s);
     dTHXa(scfg->mip->parent->perl);
-#endif 
+#endif
     module_cmds = (AV*)SvRV(mod_cmds);
 
     fill = AvFILL(module_cmds);
@@ -772,7 +772,7 @@
     HV *stash = gv_stashpv(modp->name, FALSE);
     GV *gv = gv_fetchmethod_autoload(stash, method, FALSE);
 
-    MP_TRACE_c(MP_FUNC, "looking for method %s in package `%s'...%sfound\n", 
+    MP_TRACE_c(MP_FUNC, "looking for method %s in package `%s'...%sfound",
                method, modp->name,
                MP_isGV(gv) ? "" : "not ");
 
@@ -809,7 +809,7 @@
     /* use this slot for our context */
     modp->dynamic_load_handle = minfo;
 
-    /* 
+    /*
      * XXX: we should lookup here if the Perl methods exist,
      * and set these pointers only if they do.
      */
@@ -854,7 +854,7 @@
     apr_hash_set(scfg->modules, apr_pstrdup(p, name), APR_HASH_KEY_STRING, modp);
 
 #ifdef USE_ITHREADS
-    /* 
+    /*
      * if the Perl module is loaded in the base server and a vhost
      * has configuration directives from that module, but no mod_perl.c
      * directives, scfg == NULL when modperl_module_cmd_take123 is run.
@@ -870,7 +870,7 @@
     return NULL;
 }
 
-SV *modperl_module_config_get_obj(pTHX_ SV *pmodule, server_rec *s, 
+SV *modperl_module_config_get_obj(pTHX_ SV *pmodule, server_rec *s,
                                   ap_conf_vector_t *v)
 {
     MP_dSCFG(s);
Index: src/modules/perl/modperl_filter.c
===================================================================
--- src/modules/perl/modperl_filter.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_filter.c	(.../trunk)	(revision 630610)
@@ -85,7 +85,7 @@
 {
     const char *name = f->frec->name;
 
-    /* frec->name is always lowercased */ 
+    /* frec->name is always lowercased */
     if (!strcasecmp(name, MP_FILTER_CONNECTION_INPUT_NAME)  ||
         !strcasecmp(name, MP_FILTER_CONNECTION_OUTPUT_NAME) ||
         !strcasecmp(name, MP_FILTER_REQUEST_INPUT_NAME)     ||
@@ -105,7 +105,7 @@
     APR_BRIGADE_INSERT_TAIL(filter->bb_out, b);
     ((modperl_filter_ctx_t *)filter->f->ctx)->sent_eos = 1;
     MP_TRACE_f(MP_FUNC, MP_FILTER_NAME_FORMAT
-               "write out: EOS bucket\n", MP_FILTER_NAME(filter->f));
+               "write out: EOS bucket", MP_FILTER_NAME(filter->f));
     return APR_SUCCESS;
 }
 
@@ -115,7 +115,7 @@
     apr_bucket *b = apr_bucket_flush_create(ba);
     APR_BRIGADE_INSERT_TAIL(filter->bb_out, b);
     MP_TRACE_f(MP_FUNC, MP_FILTER_NAME_FORMAT
-               "write out: FLUSH bucket\n", MP_FILTER_NAME(filter->f));
+               "write out: FLUSH bucket", MP_FILTER_NAME(filter->f));
     return APR_SUCCESS;
 }
 
@@ -128,7 +128,7 @@
     APR_BRIGADE_INSERT_TAIL(bb, b);
     ((modperl_filter_ctx_t *)f->ctx)->sent_eos = 1;
     MP_TRACE_f(MP_FUNC, MP_FILTER_NAME_FORMAT
-               "write out: EOS bucket in separate bb\n", MP_FILTER_NAME(f));
+               "write out: EOS bucket in separate bb", MP_FILTER_NAME(f));
     return ap_pass_brigade(f->next, bb);
 }
 
@@ -140,7 +140,7 @@
     apr_bucket *b = apr_bucket_flush_create(ba);
     APR_BRIGADE_INSERT_TAIL(bb, b);
     MP_TRACE_f(MP_FUNC, MP_FILTER_NAME_FORMAT
-               "write out: FLUSH bucket in separate bb\n", MP_FILTER_NAME(f));
+               "write out: FLUSH bucket in separate bb", MP_FILTER_NAME(f));
     return ap_pass_brigade(f, bb);
 }
 
@@ -165,7 +165,7 @@
         const char *body;
         int status;
 
-        MP_TRACE_f(MP_FUNC, "\n\n\tparsing headers: %db [%s]\n", len,
+        MP_TRACE_f(MP_FUNC, "parsing headers: %db [%s]", len,
                    MP_TRACE_STR_TRUNC(wb->pool, buf, len));
 
         status = modperl_cgi_header_parse(r, (char *)buf, &len, &body);
@@ -209,9 +209,9 @@
         APR_BRIGADE_INSERT_TAIL(bb, bucket);
     }
 
-    MP_TRACE_f(MP_FUNC, "\n\n\twrite out: %db [%s]\n"
-               "\t\tfrom %s\n\t\tto %s filter handler\n",
-               len, 
+    MP_TRACE_f(MP_FUNC, "\n\n\twrite out: %db [%s]"
+               "\t\tfrom %s\n\t\tto %s filter handler",
+               len,
                MP_TRACE_STR_TRUNC(wb->pool, buf, len),
                ((wb->r && wb->filters == &wb->r->output_filters)
                    ? "response handler" : "current filter handler"),
@@ -343,7 +343,7 @@
 
     MP_TRACE_f(MP_FUNC, MP_FILTER_NAME_FORMAT
                "new: %s %s filter (modperl_filter_t *0x%lx), "
-               "f (ap_filter_t *0x%lx)\n",
+               "f (ap_filter_t *0x%lx)",
                MP_FILTER_NAME(f),
                MP_FILTER_TYPE(filter),
                MP_FILTER_MODE(filter),
@@ -404,7 +404,7 @@
         FREETMPS;LEAVE;
 
         if (init_handler) {
-            MP_TRACE_h(MP_FUNC, "found init handler %s\n",
+            MP_TRACE_h(MP_FUNC, "found init handler %s",
                        modperl_handler_name(init_handler));
 
             if (!init_handler->attrs & MP_FILTER_INIT_HANDLER) {
@@ -427,7 +427,7 @@
 
 static int modperl_run_filter_init(ap_filter_t *f,
                                    modperl_filter_mode_e mode,
-                                   modperl_handler_t *handler) 
+                                   modperl_handler_t *handler)
 {
     AV *args = Nullav;
     int status;
@@ -438,9 +438,9 @@
     apr_pool_t  *p = r ? r->pool : c->pool;
     modperl_filter_t *filter = modperl_filter_new(f, NULL, mode, 0, 0, 0);
 
-    MP_dINTERP_SELECT(r, c, s);    
+    MP_dINTERP_SELECT(r, c, s);
 
-    MP_TRACE_h(MP_FUNC, "running filter init handler %s\n",
+    MP_TRACE_h(MP_FUNC, "running filter init handler %s",
                modperl_handler_name(handler));
 
     modperl_handler_make_args(aTHX_ &args,
@@ -465,9 +465,9 @@
     MP_INTERP_PUTBACK(interp);
 
     MP_TRACE_f(MP_FUNC, MP_FILTER_NAME_FORMAT
-               "return: %d\n", modperl_handler_name(handler), status);
+               "return: %d", modperl_handler_name(handler), status);
 
-    return status;  
+    return status;
 }
 
 
@@ -572,7 +572,7 @@
     MP_INTERP_PUTBACK(interp);
 
     MP_TRACE_f(MP_FUNC, MP_FILTER_NAME_FORMAT
-               "return: %d\n", modperl_handler_name(handler), status);
+               "return: %d", modperl_handler_name(handler), status);
 
     return status;
 }
@@ -601,7 +601,7 @@
 {
     if (!filter->bb_in || MP_FILTER_EMPTY(filter)) {
         MP_TRACE_f(MP_FUNC, MP_FILTER_NAME_FORMAT
-                   "read in: bucket brigade is empty\n",
+                   "read in: bucket brigade is empty",
                    MP_FILTER_NAME(filter->f));
         return 0;
     }
@@ -623,7 +623,7 @@
 
     if (MP_FILTER_IS_EOS(filter)) {
         MP_TRACE_f(MP_FUNC, MP_FILTER_NAME_FORMAT
-                   "read in: EOS bucket\n",
+                   "read in: EOS bucket",
                    MP_FILTER_NAME(filter->f));
 
         filter->seen_eos = 1;
@@ -634,7 +634,7 @@
     }
     else if (MP_FILTER_IS_FLUSH(filter)) {
         MP_TRACE_f(MP_FUNC, MP_FILTER_NAME_FORMAT
-                   "read in: FLUSH bucket\n",
+                   "read in: FLUSH bucket",
                    MP_FILTER_NAME(filter->f));
         filter->flush = 1;
         return 0;
@@ -669,7 +669,7 @@
     /* modperl_brigade_dump(filter->bb_in, NULL); */
 
     MP_TRACE_f(MP_FUNC, MP_FILTER_NAME_FORMAT
-               "wanted: %db\n",
+               "wanted: %db",
                MP_FILTER_NAME(filter->f),
                wanted);
 
@@ -677,7 +677,7 @@
         if (filter->remaining >= wanted) {
             MP_TRACE_f(MP_FUNC, MP_FILTER_NAME_FORMAT
                        "eating and returning %d [%s]\n\tof "
-                       "remaining %db\n",
+                       "remaining %db",
                        MP_FILTER_NAME(filter->f),
                        wanted,
                        MP_TRACE_STR_TRUNC(filter->pool, filter->leftover, wanted),
@@ -689,7 +689,7 @@
         }
         else {
             MP_TRACE_f(MP_FUNC, MP_FILTER_NAME_FORMAT
-                       "eating remaining %db\n",
+                       "eating remaining %db",
                        MP_FILTER_NAME(filter->f),
                        filter->remaining);
             sv_catpvn(buffer, filter->leftover, filter->remaining);
@@ -714,7 +714,7 @@
         if (filter->rc == APR_SUCCESS) {
             MP_TRACE_f(MP_FUNC,
                        MP_FILTER_NAME_FORMAT
-                       "read in: %s bucket with %db (0x%lx)\n",
+                       "read in: %s bucket with %db (0x%lx)",
                        MP_FILTER_NAME(filter->f),
                        filter->bucket->type->name,
                        buf_len,
@@ -743,7 +743,7 @@
 
     MP_TRACE_f(MP_FUNC,
                MP_FILTER_NAME_FORMAT
-               "return: %db from %d bucket%s [%s]\n\t(%db leftover)\n",
+               "return: %db from %d bucket%s [%s]\n\t(%db leftover)",
                MP_FILTER_NAME(filter->f),
                len, num_buckets, ((num_buckets == 1) ? "" : "s"),
                MP_TRACE_STR_TRUNC(filter->pool, SvPVX(buffer), len),
@@ -764,7 +764,7 @@
         filter->bb_in = apr_brigade_create(filter->pool,
                                            filter->f->c->bucket_alloc);
         MP_TRACE_f(MP_FUNC, MP_FILTER_NAME_FORMAT
-                   "retrieving bb: 0x%lx\n",
+                   "retrieving bb: 0x%lx",
                    MP_FILTER_NAME(filter->f),
                    (unsigned long)(filter->bb_in));
         MP_RUN_CROAK(ap_get_brigade(filter->f->next, filter->bb_in,
@@ -870,7 +870,7 @@
     char *copy = apr_pmemdup(filter->pool, buf, *len);
     apr_bucket *bucket = apr_bucket_transient_create(copy, *len, ba);
     MP_TRACE_f(MP_FUNC, MP_FILTER_NAME_FORMAT
-               "write out: %db [%s]:\n",
+               "write out: %db [%s]:",
                MP_FILTER_NAME(filter->f), *len,
                MP_TRACE_STR_TRUNC(filter->pool, copy, *len));
     APR_BRIGADE_INSERT_TAIL(filter->bb_out, bucket);
@@ -898,7 +898,7 @@
         MP_TRACE_f(MP_FUNC,
                    MP_FILTER_NAME_FORMAT
                    "write_out: EOS was already sent, "
-                   "passing through the brigade\n",
+                   "passing through the brigade",
                    MP_FILTER_NAME(f));
         return ap_pass_brigade(f->next, bb);
     }
@@ -932,7 +932,7 @@
         MP_TRACE_f(MP_FUNC,
                    MP_FILTER_NAME_FORMAT
                    "write out: EOS was already sent, "
-                   "passing through the brigade\n",
+                   "passing through the brigade",
                    MP_FILTER_NAME(f));
         return ap_get_brigade(f->next, bb, input_mode, block, readbytes);
     }
@@ -998,7 +998,7 @@
                 addfunc(handlers[i]->name, NULL, NULL, c);
                 MP_TRACE_f(MP_FUNC,
                            "a non-mod_perl %s handler %s configured "
-                           "(connection)\n", type, handlers[i]->name);
+                           "(connection)", type, handlers[i]->name);
                 continue;
             }
 
@@ -1006,7 +1006,7 @@
              * configured outside the resource container */
             if (!(handlers[i]->attrs & MP_FILTER_CONNECTION_HANDLER)) {
                 MP_TRACE_f(MP_FUNC,
-                           "%s is not a FilterConnection handler, skipping\n",
+                           "%s is not a FilterConnection handler, skipping",
                            handlers[i]->name);
                 continue;
             }
@@ -1033,14 +1033,14 @@
                 }
             }
 
-            MP_TRACE_h(MP_FUNC, "%s handler %s configured (connection)\n",
+            MP_TRACE_h(MP_FUNC, "%s handler %s configured (connection)",
                        type, handlers[i]->name);
         }
 
         return OK;
     }
 
-    MP_TRACE_h(MP_FUNC, "no %s handlers configured (connection)\n", type);
+    MP_TRACE_h(MP_FUNC, "no %s handlers configured (connection)", type);
 
     return DECLINED;
 }
@@ -1068,7 +1068,7 @@
             if ((handlers[i]->attrs & MP_FILTER_HTTPD_HANDLER)) {
                 addfunc(handlers[i]->name, NULL, r, r->connection);
                 MP_TRACE_f(MP_FUNC,
-                           "a non-mod_perl %s handler %s configured (%s)\n",
+                           "a non-mod_perl %s handler %s configured (%s)",
                            type, handlers[i]->name, r->uri);
                 continue;
             }
@@ -1079,7 +1079,7 @@
              */
             if ((handlers[i]->attrs & MP_FILTER_CONNECTION_HANDLER)) {
                 MP_TRACE_f(MP_FUNC,
-                           "%s is not a FilterRequest handler, skipping\n",
+                           "%s is not a FilterRequest handler, skipping",
                            handlers[i]->name);
                 continue;
             }
@@ -1096,7 +1096,7 @@
                 /* XXX: I think this won't work as f->frec->name gets
                  * lowercased when added to the chain */
                 if (*fname == 'M' && strEQ(fname, name)) {
-                    modperl_handler_t *ctx_handler = 
+                    modperl_handler_t *ctx_handler =
                         ((modperl_filter_ctx_t *)f->ctx)->handler;
 
                     if (modperl_handler_equal(ctx_handler, handlers[i])) {
@@ -1114,7 +1114,7 @@
 
             if (registered) {
                 MP_TRACE_f(MP_FUNC,
-                        "%s %s already registered\n",
+                        "%s %s already registered",
                         handlers[i]->name, type);
                 continue;
             }
@@ -1141,14 +1141,14 @@
                 }
             }
 
-            MP_TRACE_h(MP_FUNC, "%s handler %s configured (%s)\n",
+            MP_TRACE_h(MP_FUNC, "%s handler %s configured (%s)",
                        type, handlers[i]->name, r->uri);
         }
 
         return OK;
     }
 
-    MP_TRACE_h(MP_FUNC, "no %s handlers configured (%s)\n",
+    MP_TRACE_h(MP_FUNC, "no %s handlers configured (%s)",
                type, r->uri);
 
     return DECLINED;
@@ -1215,7 +1215,7 @@
                                   modperl_filter_f_cleanup,
                                   apr_pool_cleanup_null);
 
-        /* has to resolve early so we can check for init functions */ 
+        /* has to resolve early so we can check for init functions */
         if (!modperl_mgv_resolve(aTHX_ handler, pool, handler->name, TRUE)) {
             Perl_croak(aTHX_ "unable to resolve handler %s\n",
                        modperl_handler_name(handler));
@@ -1255,7 +1255,7 @@
             }
         }
 
-        MP_TRACE_h(MP_FUNC, "%s handler %s configured (connection)\n",
+        MP_TRACE_h(MP_FUNC, "%s handler %s configured (connection)",
                    type, name);
 
         return;
Index: src/modules/perl/modperl_common_util.c
===================================================================
--- src/modules/perl/modperl_common_util.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_common_util.c	(.../trunk)	(revision 630610)
@@ -23,9 +23,8 @@
 
 #include "modperl_common_util.h"
 
-
 /* Prefetch magic requires perl 5.8 */
-#if ((PERL_REVISION == 5) && (PERL_VERSION >= 8))
+#if MP_PERL_VERSION_AT_LEAST(5, 8, 0)
 
 /* A custom MGVTBL with mg_copy slot filled in allows us to FETCH a
  * table entry immediately during iteration.  For multivalued keys
@@ -41,7 +40,7 @@
  */
 
 MP_INLINE static
-int modperl_table_magic_copy(pTHX_ SV *sv, MAGIC *mg, SV *nsv, 
+int modperl_table_magic_copy(pTHX_ SV *sv, MAGIC *mg, SV *nsv,
                              const char *name, int namelen)
 {
     /* prefetch the value whenever we're iterating over the keys */
@@ -54,11 +53,11 @@
 }
 
 
-static const MGVTBL modperl_table_magic_prefetch = {0, 0, 0, 0, 0, 
+static const MGVTBL modperl_table_magic_prefetch = {0, 0, 0, 0, 0,
                                                     modperl_table_magic_copy};
 #endif /* End of prefetch magic */
 
-MP_INLINE SV *modperl_hash_tie(pTHX_ 
+MP_INLINE SV *modperl_hash_tie(pTHX_
                                const char *classname,
                                SV *tsv, void *p)
 {
@@ -68,7 +67,7 @@
     sv_setref_pv(rsv, classname, p);
 
     /* Prefetch magic requires perl 5.8 */
-#if ((PERL_REVISION == 5) && (PERL_VERSION >= 8))
+#if MP_PERL_VERSION_AT_LEAST(5, 8, 0)
 
     sv_magicext(hv, NULL, PERL_MAGIC_ext, NULL, Nullch, -1);
     SvMAGIC(hv)->mg_virtual = (MGVTBL *)&modperl_table_magic_prefetch;
@@ -82,7 +81,7 @@
                                  gv_stashpv(classname, TRUE)));
 }
 
-MP_INLINE SV *modperl_hash_tied_object_rv(pTHX_ 
+MP_INLINE SV *modperl_hash_tied_object_rv(pTHX_
                                           const char *classname,
                                           SV *tsv)
 {
@@ -116,7 +115,7 @@
     return &PL_sv_undef;
 }
 
-MP_INLINE void *modperl_hash_tied_object(pTHX_ 
+MP_INLINE void *modperl_hash_tied_object(pTHX_
                                          const char *classname,
                                          SV *tsv)
 {
@@ -134,7 +133,7 @@
 {
     GV *gv = newGVgen(pack);
     SV *rv = newRV((SV*)gv);
-    (void)hv_delete(gv_stashpv(pack, TRUE), 
+    (void)hv_delete(gv_stashpv(pack, TRUE),
                     GvNAME(gv), GvNAMELEN(gv), G_DISCARD);
     return rv;
 }
Index: src/modules/perl/modperl_pcw.c
===================================================================
--- src/modules/perl/modperl_pcw.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_pcw.c	(.../trunk)	(revision 630610)
@@ -32,7 +32,7 @@
     for (i = 0; i < sconf->sec_url->nelts; i++) {
         core_dir_config *conf =
             ap_get_module_config(urls[i], &core_module);
-        void *dir_cfg = ap_get_module_config(urls[i], modp);     
+        void *dir_cfg = ap_get_module_config(urls[i], modp);
 
         if (!dir_cb(pconf, s, dir_cfg, conf->d, data)) {
             break;
@@ -82,9 +82,9 @@
                                 module *modp,
                                 ap_pcw_dir_cb_t dir_cb, void *data)
 {
-    core_dir_config *conf = 
+    core_dir_config *conf =
         ap_get_module_config(s->lookup_defaults, &core_module);
-    void *dir_cfg = 
+    void *dir_cfg =
         ap_get_module_config(s->lookup_defaults, modp);
 
     dir_cb(pconf, s, dir_cfg, conf->d, data);
@@ -108,7 +108,7 @@
                         ap_pcw_dir_cb_t dir_cb, ap_pcw_srv_cb_t srv_cb)
 {
     for (; s; s = s->next) {
-        core_dir_config *dconf = 
+        core_dir_config *dconf =
             ap_get_module_config(s->lookup_defaults,
                                  &core_module);
 
Index: src/modules/perl/modperl_apache_compat.h
===================================================================
--- src/modules/perl/modperl_apache_compat.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_apache_compat.h	(.../trunk)	(revision 630610)
@@ -36,6 +36,23 @@
  * which httpd release allows us to remove the compat code
  */
 
+/* pre-APACHE_2.2.4 */
+#if ! AP_MODULE_MAGIC_AT_LEAST(20051115,4)
+
+/* added in APACHE_2.2.4 */
+AP_DECLARE(const char *) ap_get_server_description(void);
+AP_DECLARE(const char *) ap_get_server_banner(void);
+
+#endif /* pre-APACHE_2.2.4 */
+
+/* since-APACHE-2.3.0 */
+#if AP_MODULE_MAGIC_AT_LEAST(20060905,0)
+
+/* removed in APACHE-2.3.0 */
+AP_DECLARE(const char *) ap_get_server_version(void);
+
+#endif /* since-APACHE-2.3.0 */
+
 /* ap_http_scheme is called ap_http_method in httpd 2.0 */
 #ifndef ap_http_scheme
 #define ap_http_scheme(r) ap_http_method(r)
Index: src/modules/perl/modperl_module.h
===================================================================
--- src/modules/perl/modperl_module.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_module.h	(.../trunk)	(revision 630610)
@@ -24,7 +24,7 @@
 const char *modperl_module_add(apr_pool_t *p, server_rec *s,
                                const char *name, SV *mod_cmds);
 
-SV *modperl_module_config_get_obj(pTHX_ SV *pmodule, server_rec *s, 
+SV *modperl_module_config_get_obj(pTHX_ SV *pmodule, server_rec *s,
                                   ap_conf_vector_t *v);
 
 #endif /* MODPERL_MODULE_H */
Index: src/modules/perl/modperl_filter.h
===================================================================
--- src/modules/perl/modperl_filter.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_filter.h	(.../trunk)	(revision 630610)
@@ -25,9 +25,9 @@
 
 #define MP_FILTER_CONNECTION_HANDLER 0x01
 #define MP_FILTER_REQUEST_HANDLER    0x02
-#define MP_FILTER_HAS_INIT_HANDLER   0x04 
-#define MP_FILTER_INIT_HANDLER       0x08 
-#define MP_FILTER_HTTPD_HANDLER      0x10 
+#define MP_FILTER_HAS_INIT_HANDLER   0x04
+#define MP_FILTER_INIT_HANDLER       0x08
+#define MP_FILTER_HTTPD_HANDLER      0x10
 
 typedef ap_filter_t * MP_FUNC_T(modperl_filter_add_t) (const char *, void *,
                                                        request_rec *,
@@ -101,7 +101,7 @@
                                                modperl_filter_t *filter,
                                                SV *buffer,
                                                apr_size_t wanted);
-    
+
 MP_INLINE apr_status_t modperl_input_filter_write(pTHX_
                                                   modperl_filter_t *filter,
                                                   const char *buf,
Index: src/modules/perl/modperl_common_util.h
===================================================================
--- src/modules/perl/modperl_common_util.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_common_util.h	(.../trunk)	(revision 630610)
@@ -1,4 +1,3 @@
-
 /* Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -78,13 +77,25 @@
 #define MP_magical_tie(sv, mg_flags) \
     SvFLAGS((SV*)sv) |= mg_flags
 
+/* some wrapper macros to detect perl versions
+ * and prevent code clutter */
+#define MP_PERL_VERSION_AT_LEAST(r, v, s)                                \
+    (PERL_REVISION == r &&                                               \
+    ((PERL_VERSION == v && PERL_SUBVERSION > s-1) || PERL_VERSION > v))
 
+#define MP_PERL_VERSION_AT_MOST(r, v, s)                                 \
+   (PERL_REVISION == r &&                                                \
+   (PERL_VERSION < v || (PERL_VERSION == v && PERL_SUBVERSION < s+1)))
+
+#define MP_PERL_VERSION(r, v, s)                                         \
+  (PERL_REVISION == r && PERL_VERSION == v && PERL_SUBVERSION == s)
+
 /* tie %hash */
 MP_INLINE SV *modperl_hash_tie(pTHX_ const char *classname,
                                SV *tsv, void *p);
 
 /* tied %hash */
-MP_INLINE SV *modperl_hash_tied_object_rv(pTHX_ 
+MP_INLINE SV *modperl_hash_tied_object_rv(pTHX_
                                           const char *classname,
                                           SV *tsv);
 /* tied %hash */
@@ -99,4 +110,3 @@
 SV *modperl_perl_gensym(pTHX_ char *pack);
 
 #endif /* MODPERL_COMMON_UTIL_H */
-
Index: src/modules/perl/modperl_options.c
===================================================================
--- src/modules/perl/modperl_options.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_options.c	(.../trunk)	(revision 630610)
@@ -52,10 +52,10 @@
 
 modperl_options_t *modperl_options_new(apr_pool_t *p, int type)
 {
-    modperl_options_t *options = 
+    modperl_options_t *options =
         (modperl_options_t *)apr_pcalloc(p, sizeof(*options));
 
-    options->opts = options->unset = 
+    options->opts = options->unset =
         (type == MpSrvType ? MpSrv_f_UNSET : MpDir_f_UNSET);
 
     return options;
Index: src/modules/perl/modperl_perl.c
===================================================================
--- src/modules/perl/modperl_perl.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_perl.c	(.../trunk)	(revision 630610)
@@ -43,9 +43,9 @@
         Perl_croak(aTHX_ "Usage: ModPerl::Util::exit(status=0)");
     }
     /* default: 0 */
-    status = items < 1 ? 0 : (int)SvIV(ST(0)); 
+    status = items < 1 ? 0 : (int)SvIV(ST(0));
     modperl_perl_exit(aTHX_ status);
-    
+
     XSRETURN_EMPTY;
 }
 
@@ -71,17 +71,17 @@
 #endif
 #ifndef WIN32
     ids->uid  = getuid();
-    ids->euid = geteuid(); 
-    ids->gid  = getgid(); 
-    ids->egid  = getegid(); 
+    ids->euid = geteuid();
+    ids->gid  = getgid();
+    ids->egid  = getegid();
 
-    MP_TRACE_r(MP_FUNC, 
+    MP_TRACE_r(MP_FUNC,
                "pid=%d, "
 #ifdef MP_MAINTAIN_PPID
                "ppid=%d, "
 #endif
                "uid=%" Uid_t_f ", euid=%" Uid_t_f ", "
-               "gid=%" Gid_t_f ", egid=%" Gid_t_f "\n",
+               "gid=%" Gid_t_f ", egid=%" Gid_t_f,
                (int)ids->pid,
 #ifdef MP_MAINTAIN_PPID
                (int)ids->ppid,
@@ -134,7 +134,7 @@
 void modperl_perl_destruct(PerlInterpreter *perl)
 {
     char **orig_environ = NULL;
-    PTR_TBL_t *module_commands; 
+    PTR_TBL_t *module_commands;
     dTHXa(perl);
 
     PERL_SET_CONTEXT(perl);
@@ -200,8 +200,7 @@
      }
 }
 
-#if !(PERL_REVISION == 5 && ( PERL_VERSION < 8 ||    \
-    (PERL_VERSION == 8 && PERL_SUBVERSION == 0))) && \
+#if !(MP_PERL_VERSION_AT_MOST(5, 8, 0)) && \
     (defined(USE_HASH_SEED) || defined(USE_HASH_SEED_EXPLICIT))
 #define MP_NEED_HASH_SEED_FIXUP
 #endif
@@ -212,7 +211,7 @@
 #endif
 
 /* see modperl_hash_seed_set() */
-void modperl_hash_seed_init(apr_pool_t *p) 
+void modperl_hash_seed_init(apr_pool_t *p)
 {
 #ifdef MP_NEED_HASH_SEED_FIXUP
     char *s;
@@ -254,11 +253,11 @@
  * it randomizes if perl was compiled with ccflags -DUSE_HASH_SEED
  * or -DUSE_HASH_SEED_EXPLICIT, in which case we need to tell perl
  * to use the same seed everywhere */
-void modperl_hash_seed_set(pTHX) 
+void modperl_hash_seed_set(pTHX)
 {
 #ifdef MP_NEED_HASH_SEED_FIXUP
     if (MP_init_hash_seed_set) {
-#if PERL_REVISION == 5 && PERL_VERSION == 8 && PERL_SUBVERSION == 1
+#if MP_PERL_VERSION(5, 8, 1)
         PL_hash_seed       = MP_init_hash_seed;
         PL_hash_seed_set   = MP_init_hash_seed_set;
 #else
Index: src/modules/perl/modperl_tipool.c
===================================================================
--- src/modules/perl/modperl_tipool.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_tipool.c	(.../trunk)	(revision 630610)
@@ -33,7 +33,7 @@
 
 modperl_list_t *modperl_list_new()
 {
-    modperl_list_t *listp = 
+    modperl_list_t *listp =
         (modperl_list_t *)malloc(sizeof(*listp));
     memset(listp, '\0', sizeof(*listp));
     return listp;
@@ -123,7 +123,7 @@
 #ifdef MP_TRACE
     if (!tmp) {
         /* should never happen */
-        MP_TRACE_i(MP_FUNC, "failed to find 0x%lx in list 0x%lx\n",
+        MP_TRACE_i(MP_FUNC, "failed to find 0x%lx in list 0x%lx",
                    (unsigned long)rlist, (unsigned long)list);
     }
 #endif
@@ -189,7 +189,7 @@
         modperl_tipool_add(tipool, item);
     }
 
-    MP_TRACE_i(MP_FUNC, "start=%d, max=%d, min_spare=%d, max_spare=%d\n",
+    MP_TRACE_i(MP_FUNC, "start=%d, max=%d, min_spare=%d, max_spare=%d",
                tipool->cfg->start, tipool->cfg->max,
                tipool->cfg->min_spare, tipool->cfg->max_spare);
 
@@ -211,7 +211,7 @@
     }
 
     if (tipool->busy) {
-        MP_TRACE_i(MP_FUNC, "ERROR: %d items still in use\n",
+        MP_TRACE_i(MP_FUNC, "ERROR: %d items still in use",
                    tipool->in_use);
     }
 
@@ -231,7 +231,7 @@
 
     tipool->size++;
 
-    MP_TRACE_i(MP_FUNC, "added 0x%lx (size=%d)\n",
+    MP_TRACE_i(MP_FUNC, "added 0x%lx (size=%d)",
                (unsigned long)listp, tipool->size);
 }
 
@@ -242,7 +242,7 @@
     tipool->idle = modperl_list_remove(tipool->idle, listp);
 
     tipool->size--;
-    MP_TRACE_i(MP_FUNC, "removed 0x%lx (size=%d)\n",
+    MP_TRACE_i(MP_FUNC, "removed 0x%lx (size=%d)",
                (unsigned long)listp, tipool->size);
 }
 
@@ -255,7 +255,7 @@
     if (tipool->size == tipool->in_use) {
         if (tipool->size < tipool->cfg->max) {
             MP_TRACE_i(MP_FUNC,
-                       "no idle items, size %d < %d max\n",
+                       "no idle items, size %d < %d max",
                        tipool->size, tipool->cfg->max);
             if (tipool->func->tipool_rgrow) {
                 void * item =
@@ -277,7 +277,7 @@
 
     /* XXX: this should never happen */
     if (!head) {
-        MP_TRACE_i(MP_FUNC, "PANIC: no items available, %d of %d in use\n", 
+        MP_TRACE_i(MP_FUNC, "PANIC: no items available, %d of %d in use",
                    tipool->in_use, tipool->size);
         abort();
     }
@@ -318,14 +318,14 @@
 
 #ifdef MP_TRACE
     if (!tipool->busy && tipool->func->tipool_dump) {
-        MP_TRACE_i(MP_FUNC, "all items idle:\n");
+        MP_TRACE_i(MP_FUNC, "all items idle:");
         MP_TRACE_i_do((*tipool->func->tipool_dump)(tipool,
                                                    tipool->data,
                                                    tipool->idle));
     }
 #endif
 
-    MP_TRACE_i(MP_FUNC, "0x%lx now available (%d in use, %d running)\n",
+    MP_TRACE_i(MP_FUNC, "0x%lx now available (%d in use, %d running)",
                (unsigned long)listp->data, tipool->in_use, tipool->size);
 
     if (tipool->in_use == (tipool->cfg->max - 1)) {
@@ -341,11 +341,11 @@
 
     if (max_spare) {
         MP_TRACE_i(MP_FUNC,
-                   "shrinking pool: max_spare=%d, only %d of %d in use\n",
+                   "shrinking pool: max_spare=%d, only %d of %d in use",
                    tipool->cfg->max_spare, tipool->in_use, tipool->size);
     }
     else if (max_requests) {
-        MP_TRACE_i(MP_FUNC, "shrinking pool: max requests %d reached\n",
+        MP_TRACE_i(MP_FUNC, "shrinking pool: max requests %d reached",
                    tipool->cfg->max_requests);
     }
 
@@ -370,7 +370,7 @@
                                                   tipool->data);
 
                 MP_TRACE_i(MP_FUNC,
-                           "growing pool: min_spare=%d, %d of %d in use\n",
+                           "growing pool: min_spare=%d, %d of %d in use",
                            tipool->cfg->min_spare, tipool->in_use,
                            tipool->size);
 
Index: src/modules/perl/modperl_perl.h
===================================================================
--- src/modules/perl/modperl_perl.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_perl.h	(.../trunk)	(revision 630610)
@@ -22,7 +22,7 @@
  * need to do that for those fake 5.8.0 as well. real 5.8.0 doesn't
  * have THREADS_HAVE_PIDS defined.
  */
-#if PERL_REVISION == 5 && PERL_VERSION >= 8 && THREADS_HAVE_PIDS
+#if MP_PERL_VERSION_AT_LEAST(5, 8, 0) && THREADS_HAVE_PIDS
 #define MP_MAINTAIN_PPID
 #endif
 
Index: src/modules/perl/modperl_io.c
===================================================================
--- src/modules/perl/modperl_io.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_io.c	(.../trunk)	(revision 630610)
@@ -33,7 +33,7 @@
 
     SvREFCNT_dec(obj); /* since sv_magic did SvREFCNT_inc */
 
-    MP_TRACE_r(MP_FUNC, "tie *%s(0x%lx) => %s, REFCNT=%d\n",
+    MP_TRACE_r(MP_FUNC, "tie *%s(0x%lx) => %s, REFCNT=%d",
                GvNAME(handle), (unsigned long)handle, classname,
                SvREFCNT(TIEHANDLE_SV(handle)));
 }
@@ -80,12 +80,12 @@
     SV *sv = TIEHANDLE_SV(handle);
 
     if (SvMAGICAL(sv) && (mg = mg_find(sv, PERL_MAGIC_tiedscalar))) {
-	char *package = HvNAME(SvSTASH((SV*)SvRV(mg->mg_obj)));
+        char *package = HvNAME(SvSTASH((SV*)SvRV(mg->mg_obj)));
 
-	if (!strEQ(package, classname)) {
-	    MP_TRACE_r(MP_FUNC, "%s tied to %s\n", GvNAME(handle), package);
-	    return TRUE;
-	}
+        if (!strEQ(package, classname)) {
+            MP_TRACE_r(MP_FUNC, "%s tied to %s", GvNAME(handle), package);
+            return TRUE;
+        }
     }
 
     return FALSE;
@@ -95,7 +95,7 @@
 {
 #ifdef MP_TRACE
     if (mg_find(TIEHANDLE_SV(handle), PERL_MAGIC_tiedscalar)) {
-        MP_TRACE_r(MP_FUNC, "untie *%s(0x%lx), REFCNT=%d\n",
+        MP_TRACE_r(MP_FUNC, "untie *%s(0x%lx), REFCNT=%d",
                    GvNAME(handle), (unsigned long)handle,
                    SvREFCNT(TIEHANDLE_SV(handle)));
     }
@@ -141,7 +141,7 @@
         Perl_croak(aTHX_ "Failed to open STDIN: %" SVf, get_sv("!", TRUE));
     }
 
-    MP_TRACE_o(MP_FUNC, "end\n");
+    MP_TRACE_o(MP_FUNC, "end");
 
     return handle_save;
 }
@@ -184,7 +184,7 @@
         Perl_croak(aTHX_ "Failed to open STDOUT: %" SVf, get_sv("!", TRUE));
     }
 
-    MP_TRACE_o(MP_FUNC, "end\n");
+    MP_TRACE_o(MP_FUNC, "end");
 
     /* XXX: shouldn't we preserve the value STDOUT had before it was
      * overridden? */
@@ -218,7 +218,7 @@
         }
 
         do_close(handle, FALSE);
-        (void)hv_delete(gv_stashpv("Apache2::RequestIO", TRUE), 
+        (void)hv_delete(gv_stashpv("Apache2::RequestIO", TRUE),
                         GvNAME(handle), GvNAMELEN(handle), G_DISCARD);
 
         if (err != Nullsv) {
@@ -226,11 +226,11 @@
         }
     }
 
-    MP_TRACE_o(MP_FUNC, "end\n");
+    MP_TRACE_o(MP_FUNC, "end");
 }
 
 MP_INLINE void modperl_io_perlio_restore_stdout(pTHX_ GV *handle)
-{ 
+{
     GV *handle_orig = gv_fetchpv("STDOUT", FALSE, SVt_PVIO);
 
     MP_TRACE_o(MP_FUNC, "start");
@@ -265,7 +265,7 @@
         }
 
         do_close(handle, FALSE);
-        (void)hv_delete(gv_stashpv("Apache2::RequestIO", TRUE), 
+        (void)hv_delete(gv_stashpv("Apache2::RequestIO", TRUE),
                         GvNAME(handle), GvNAMELEN(handle), G_DISCARD);
 
         if (err != Nullsv) {
@@ -273,5 +273,5 @@
         }
     }
 
-    MP_TRACE_o(MP_FUNC, "end\n");
+    MP_TRACE_o(MP_FUNC, "end");
 }
Index: src/modules/perl/modperl_tipool.h
===================================================================
--- src/modules/perl/modperl_tipool.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_tipool.h	(.../trunk)	(revision 630610)
@@ -63,26 +63,26 @@
 #define modperl_tipool_wait(tipool) \
     while (tipool->size == tipool->in_use) { \
         MP_TRACE_i(MP_FUNC, \
-                   "waiting for available tipool item in thread 0x%lx\n", \
+                   "waiting for available tipool item in thread 0x%lx", \
                    MP_TIDF); \
-        MP_TRACE_i(MP_FUNC, "(%d items in use, %d alive)\n", \
+        MP_TRACE_i(MP_FUNC, "(%d items in use, %d alive)", \
                    tipool->in_use, tipool->size); \
         COND_WAIT(&tipool->available, &tipool->tiplock); \
     }
 
 #define modperl_tipool_broadcast(tipool) \
-    MP_TRACE_i(MP_FUNC, "broadcast available tipool item\n"); \
+    MP_TRACE_i(MP_FUNC, "broadcast available tipool item"); \
     COND_SIGNAL(&tipool->available)
 
 #define modperl_tipool_lock(tipool) \
-    MP_TRACE_i(MP_FUNC, "about to lock tipool in thread 0x%lx\n", MP_TIDF); \
+    MP_TRACE_i(MP_FUNC, "about to lock tipool in thread 0x%lx", MP_TIDF); \
     MUTEX_LOCK(&tipool->tiplock); \
-    MP_TRACE_i(MP_FUNC, "acquired tipool lock\n")
+    MP_TRACE_i(MP_FUNC, "acquired tipool lock")
 
 #define modperl_tipool_unlock(tipool) \
-    MP_TRACE_i(MP_FUNC, "about to unlock tipool in thread 0x%lx\n", MP_TIDF); \
+    MP_TRACE_i(MP_FUNC, "about to unlock tipool in thread 0x%lx", MP_TIDF); \
     MUTEX_UNLOCK(&tipool->tiplock); \
-    MP_TRACE_i(MP_FUNC, "released tipool lock\n")
+    MP_TRACE_i(MP_FUNC, "released tipool lock")
 
 #endif /* USE_ITHREADS */
 
Index: src/modules/perl/modperl_io.h
===================================================================
--- src/modules/perl/modperl_io.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_io.h	(.../trunk)	(revision 630610)
@@ -24,7 +24,7 @@
  * from living in the gv to the GvIOp(gv), so we have to deal
  * with both to support 5.6.x
  */
-#if ((PERL_REVISION == 5) && (PERL_VERSION >= 7))
+#if MP_PERL_VERSION_AT_LEAST(5, 7, 0)
 #   define TIEHANDLE_SV(handle) (SV*)GvIOp((SV*)handle)
 #else
 #   define TIEHANDLE_SV(handle) (SV*)handle
@@ -62,15 +62,15 @@
 #if defined(MP_IO_TIE_SFIO)
     /* XXX */
 #elif defined(MP_IO_TIE_PERLIO)
-#define modperl_io_override_stdin  modperl_io_perlio_override_stdin  
-#define modperl_io_override_stdout modperl_io_perlio_override_stdout  
-#define modperl_io_restore_stdin   modperl_io_perlio_restore_stdin  
-#define modperl_io_restore_stdout  modperl_io_perlio_restore_stdout  
+#define modperl_io_override_stdin  modperl_io_perlio_override_stdin
+#define modperl_io_override_stdout modperl_io_perlio_override_stdout
+#define modperl_io_restore_stdin   modperl_io_perlio_restore_stdin
+#define modperl_io_restore_stdout  modperl_io_perlio_restore_stdout
 #else
-#define modperl_io_override_stdin  modperl_io_tie_stdin  
-#define modperl_io_override_stdout modperl_io_tie_stdout  
-#define modperl_io_restore_stdin   modperl_io_handle_untie  
-#define modperl_io_restore_stdout  modperl_io_handle_untie  
+#define modperl_io_override_stdin  modperl_io_tie_stdin
+#define modperl_io_override_stdout modperl_io_tie_stdout
+#define modperl_io_restore_stdin   modperl_io_handle_untie
+#define modperl_io_restore_stdout  modperl_io_handle_untie
 #endif
 
 
Index: src/modules/perl/modperl_perl_global.c
===================================================================
--- src/modules/perl/modperl_perl_global.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_perl_global.c	(.../trunk)	(revision 630610)
@@ -194,7 +194,7 @@
     av_store(mav, AvFILLp(mav)+1, sv);
 
     /* print scalar @{ $PL_modglobal{$key}{$package} } */
-    MP_TRACE_g(MP_FUNC, "%s::%s av now has %d entries\n",
+    MP_TRACE_g(MP_FUNC, "%s::%s av now has %d entries",
                package, (char*)gkey->name, 1+av_len(mav));
 
     return 1;
@@ -279,7 +279,7 @@
     HvRITER(ohv) = hv_riter;
     HvEITER(ohv) = hv_eiter;
 
-    hv_magic(hv, Nullgv, 'E');    
+    hv_magic(hv, Nullgv, 'E');
 
     TAINT_NOT;
 
@@ -299,7 +299,7 @@
      * at this point: modperl_env.c:modperl_env_const_vars[],
      * PerlPassEnv and top-level PerlSetEnv
      * XXX: still; could have have something faster than newHVhv()
-     * especially if we add another GVHV to the globals table that 
+     * especially if we add another GVHV to the globals table that
      * might have more entries
      */
 
Index: src/modules/perl/modperl_debug.c
===================================================================
--- src/modules/perl/modperl_debug.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_debug.c	(.../trunk)	(revision 630610)
@@ -59,7 +59,7 @@
                 len = tmp_len;
             }
         }
-    }    
+    }
     /* dump the table with keys aligned */
     fmt = Perl_form(aTHX_ "%%-%ds => %%s", len);
 
@@ -68,7 +68,7 @@
             continue;
         }
         modperl_trace(MP_FUNC, fmt, elts[i].key, elts[i].val);
-    }    
+    }
     modperl_trace(MP_FUNC, "");
 }
 #endif
@@ -93,8 +93,7 @@
         MP_TRACE_g(MP_FUNC, "| %s => 0x%lx", key, val);
     }
 
-    MP_TRACE_g(MP_FUNC, "|-------- PL_modglobal --------\n");
+    MP_TRACE_g(MP_FUNC, "|-------- PL_modglobal --------");
 
 }
 #endif
-
Index: src/modules/perl/modperl_common_log.c
===================================================================
--- src/modules/perl/modperl_common_log.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_common_log.c	(.../trunk)	(revision 630610)
@@ -30,7 +30,7 @@
 
 unsigned long modperl_debug_level(void)
 {
-    return debug_level;  
+    return debug_level;
 }
 
 void modperl_trace_logfile_set(apr_file_t *logfile_new)
Index: src/modules/perl/modperl_error.c
===================================================================
--- src/modules/perl/modperl_error.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_error.c	(.../trunk)	(revision 630610)
@@ -62,7 +62,7 @@
  *   line - set to the callers line number
  *   func - set to the function name
  */
-void modperl_croak(pTHX_ apr_status_t rc, const char* func) 
+void modperl_croak(pTHX_ apr_status_t rc, const char* func)
 {
     HV *stash;
     HV *data;
@@ -78,7 +78,7 @@
     }
 
     if (SvTRUE(ERRSV)) {
-        Perl_croak(aTHX_ "%s", SvPV_nolen(ERRSV));   
+        Perl_croak(aTHX_ "%s", SvPV_nolen(ERRSV));
     }
 
     stash = gv_stashpvn("APR::Error", 10, FALSE);
@@ -91,5 +91,5 @@
     sv_setiv(*hv_fetch(data, "line", 4, 1), CopLINE(PL_curcop));
     sv_setpv(*hv_fetch(data, "func", 4, 1), func);
 
-    Perl_croak(aTHX_ Nullch);   
+    Perl_croak(aTHX_ Nullch);
 }
Index: src/modules/perl/modperl_perl_includes.h
===================================================================
--- src/modules/perl/modperl_perl_includes.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_perl_includes.h	(.../trunk)	(revision 630610)
@@ -53,7 +53,6 @@
 #   define uid_t perl_uid_t
 #   define gid_t perl_gid_t
 #   ifdef exit
-#      define perl_exit exit
 #      undef exit
 #   endif
 #endif
@@ -68,27 +67,13 @@
 
 #if defined(WIN32) && defined(USE_LARGE_FILES)
 #   ifdef malloc
-#      define perl_malloc malloc
 #      undef malloc
 #   endif
 #   ifdef free
-#      define perl_free free
 #      undef free
 #   endif
 #endif
 
-#if (PERL_REVISION == 5) && (PERL_VERSION == 6)
-#   define MP_PERL_5_6_x
-#endif
-
-#if defined(MP_PERL_5_6_x) && (PERL_SUBVERSION == 0)
-#   define MP_PERL_5_6_0
-#endif
-
-#if defined(MP_PERL_5_6_x) && (PERL_SUBVERSION == 1)
-#   define MP_PERL_5_6_1
-#endif
-
 #include "modperl_perl_unembed.h"
 
 /* avoiding -Wall warning */
Index: src/modules/perl/modperl_error.h
===================================================================
--- src/modules/perl/modperl_error.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_error.h	(.../trunk)	(revision 630610)
@@ -25,7 +25,7 @@
 #define MODPERL_FILTER_ERROR   APR_OS_START_USERERR + 1
 
 /**
- * return the string representation of the error code 
+ * return the string representation of the error code
  * @param rc   error code
  * @return     the error string
  *
@@ -34,7 +34,7 @@
  * called again (which could happen indirectly). If unsure, copy.
  */
 char *modperl_error_strerror(pTHX_ apr_status_t rc);
-        
+
 void modperl_croak(pTHX_ apr_status_t rc, const char* func);
 
 #define MP_RUN_CROAK(rc_run, func) STMT_START                \
Index: src/modules/perl/modperl_perl_pp.h
===================================================================
--- src/modules/perl/modperl_perl_pp.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_perl_pp.h	(.../trunk)	(revision 630610)
@@ -17,7 +17,10 @@
 #ifndef MODPERL_PERL_PP_H
 #define MODPERL_PERL_PP_H
 
-#if defined(USE_ITHREADS) && defined(MP_PERL_5_6_x)
+#define MP_PERL_BRANCH(r, v)                                             \
+    (PERL_REVISION == r && PERL_VERSION == v)
+
+#if defined(USE_ITHREADS) && MP_PERL_BRANCH(5, 6)
 #   define MP_REFGEN_FIXUP
 #endif
 
Index: src/modules/perl/modperl_perl_unembed.h
===================================================================
--- src/modules/perl/modperl_perl_unembed.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_perl_unembed.h	(.../trunk)	(revision 630610)
@@ -43,4 +43,3 @@
 #undef list
 
 #endif /* MODPERL_PERL_UNEMBED_H */
-
Index: src/modules/perl/mod_perl.c
===================================================================
--- src/modules/perl/mod_perl.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/mod_perl.c	(.../trunk)	(revision 630610)
@@ -61,7 +61,7 @@
 
     handles = modperl_xs_dl_handles_get(aTHX);
 
-    MP_TRACE_i(MP_FUNC, "destroying interpreter=0x%lx\n",
+    MP_TRACE_i(MP_FUNC, "destroying interpreter=0x%lx",
                (unsigned long)perl);
 
     modperl_perl_destruct(perl);
@@ -165,8 +165,7 @@
     dTHXa(perl);
 
 /* 5.7.3+ has a built-in special ${^TAINT}, backport it to 5.6.0+ */
-#if PERL_REVISION == 5 && \
-    (PERL_VERSION == 6 || (PERL_VERSION == 7 && PERL_SUBVERSION < 3))
+#if MP_PERL_VERSION_AT_MOST(5, 7, 2)
     {
         GV *gv = gv_fetchpv("\024AINT", GV_ADDMULTI, SVt_IV);
         sv_setiv(GvSV(gv), PL_tainting);
@@ -216,13 +215,13 @@
     {
         server_rec *base_server = modperl_global_get_server_rec();
         const char *desc = modperl_server_desc(s, p);
-        if (base_server == s) {        
+        if (base_server == s) {
             MP_TRACE_i(MP_FUNC,
-                       "starting the parent perl for the base server\n", desc);
+                       "starting the parent perl for the base server", desc);
         }
         else {
             MP_TRACE_i(MP_FUNC,
-                       "starting the parent perl for vhost %s\n", desc);
+                       "starting the parent perl for vhost %s", desc);
         }
     }
 #endif
@@ -266,7 +265,7 @@
     PL_endav = Nullav;
 
 /* This was fixed in 5.9.0/5.8.1 (17775), but won't compile after 19122 */
-#if PERL_REVISION == 5 && PERL_VERSION == 8 && PERL_SUBVERSION == 0 && \
+#if MP_PERL_VERSION(5, 8, 0) && \
     defined(USE_REENTRANT_API) && defined(HAS_CRYPT_R) && defined(__GLIBC__)
     /* workaround perl5.8.0/glibc bug */
     PL_reentrant_buffer->_crypt_struct.current_saltbits = 0;
@@ -293,7 +292,7 @@
 
     set_taint_var(perl);
 
-    MP_TRACE_i(MP_FUNC, "constructed interpreter=0x%lx\n",
+    MP_TRACE_i(MP_FUNC, "constructed interpreter=0x%lx",
                (unsigned long)perl);
 
 #ifdef MP_USE_GTOP
@@ -352,7 +351,7 @@
     const char *vhost = modperl_server_desc(s, p);
 
     if (!scfg) {
-        MP_TRACE_i(MP_FUNC, "server %s has no mod_perl config\n", vhost);
+        MP_TRACE_i(MP_FUNC, "server %s has no mod_perl config", vhost);
         return OK;
     }
 
@@ -360,11 +359,11 @@
         base_server = modperl_global_get_server_rec();
     }
 
-    MP_TRACE_i(MP_FUNC, "Init vhost %s: s=0x%lx, base_s=0x%lx\n",
+    MP_TRACE_i(MP_FUNC, "Init vhost %s: s=0x%lx, base_s=0x%lx",
                vhost, s, base_server);
 
     if (base_server == s) {
-        MP_TRACE_i(MP_FUNC, "base server is not vhost, skipping %s\n",
+        MP_TRACE_i(MP_FUNC, "base server is not vhost, skipping %s",
                    vhost);
         return OK;
     }
@@ -380,14 +379,14 @@
 #ifdef USE_ITHREADS
 
     if (scfg->mip) {
-        MP_TRACE_i(MP_FUNC, "server %s already initialized\n", vhost);
+        MP_TRACE_i(MP_FUNC, "server %s already initialized", vhost);
         return OK;
     }
 
     /* the base server could have mod_perl callbacks disabled, but it
      * still needs perl to drive the vhosts */
     if (!MpSrvENABLE(scfg) && s->is_virtual) {
-        MP_TRACE_i(MP_FUNC, "mod_perl disabled for server %s\n", vhost);
+        MP_TRACE_i(MP_FUNC, "mod_perl disabled for server %s", vhost);
         scfg->mip = NULL;
         return OK;
     }
@@ -402,7 +401,7 @@
     if (MpSrvPARENT(scfg)) {
         perl = modperl_startup(s, p);
         MP_TRACE_i(MP_FUNC,
-                   "created parent interpreter for VirtualHost %s\n",
+                   "created parent interpreter for VirtualHost %s",
                    modperl_server_desc(s, p));
     }
     else {
@@ -410,7 +409,7 @@
         /* virtual host w/ +Clone gets its own mip */
         if (MpSrvCLONE(scfg)) {
             modperl_interp_init(s, p, perl);
-        }   
+        }
 #endif
 
         if (!modperl_config_apply_PerlRequire(s, scfg, perl, p)) {
@@ -428,7 +427,7 @@
          * need to point to the base mip here if this vhost
          * doesn't have its own
          */
-        MP_TRACE_i(MP_FUNC, "%s mip inherited from %s\n",
+        MP_TRACE_i(MP_FUNC, "%s mip inherited from %s",
                    vhost, modperl_server_desc(base_server, p));
         scfg->mip = base_scfg->mip;
     }
@@ -477,7 +476,7 @@
     for (; s; s=s->next) {
         MP_dSCFG(s);
         if (!modperl_config_apply_PerlPostConfigRequire(s, scfg, p)) {
-            return FALSE;   
+            return FALSE;
         }
     }
     return TRUE;
@@ -492,7 +491,7 @@
 #endif /* MP_TRACE */
 
     if (!modperl_threaded_mpm()) {
-        MP_TRACE_i(MP_FUNC, "no clones created for non-threaded mpm\n");
+        MP_TRACE_i(MP_FUNC, "no clones created for non-threaded mpm");
         return;
     }
 
@@ -501,7 +500,7 @@
 #ifdef MP_TRACE
         char *name = modperl_server_desc(s, p);
 
-        MP_TRACE_i(MP_FUNC, "PerlInterpScope set to %s for %s\n",
+        MP_TRACE_i(MP_FUNC, "PerlInterpScope set to %s for %s",
                    modperl_interp_scope_desc(scfg->interp_scope), name);
 #else
         char *name = NULL;
@@ -511,18 +510,18 @@
 #ifdef MP_TRACE
             if (scfg->mip == base_scfg->mip) {
                 MP_TRACE_i(MP_FUNC,
-                           "%s interp pool inherited from %s\n",
+                           "%s interp pool inherited from %s",
                            name, base_name);
             }
             else {
                 MP_TRACE_i(MP_FUNC,
-                           "%s interp pool already initialized\n",
+                           "%s interp pool already initialized",
                            name);
             }
 #endif /* MP_TRACE */
         }
         else {
-            MP_TRACE_i(MP_FUNC, "initializing interp pool for %s\n",
+            MP_TRACE_i(MP_FUNC, "initializing interp pool for %s",
                        name);
             modperl_tipool_init(scfg->mip->tipool);
         }
@@ -534,7 +533,7 @@
 {
     ap_mpm_query(AP_MPMQ_IS_THREADED, &MP_threaded_mpm);
 
-    MP_TRACE_g(MP_FUNC, "mod_perl globals are configured\n");
+    MP_TRACE_g(MP_FUNC, "mod_perl globals are configured");
 
     modperl_global_init_pconf(pconf, pconf);
     modperl_global_init_server_rec(pconf, s);
@@ -554,7 +553,7 @@
     int argc = 0;
     char **argv = NULL, **env = NULL;
 
-    MP_TRACE_i(MP_FUNC, "mod_perl sys init\n");
+    MP_TRACE_i(MP_FUNC, "mod_perl sys init");
 
     /* not every OS uses those vars in PERL_SYS_INIT3 macro */
     argc = argc; argv = argv; env = env;
@@ -584,13 +583,18 @@
 
 static apr_status_t modperl_sys_term(void *data)
 {
+    /* PERL_SYS_TERM() needs 'my_perl' as of 5.9.5 */
+#if MP_PERL_VERSION_AT_LEAST(5, 9, 5) && defined(USE_ITHREADS)
+    modperl_cleanup_data_t *cdata = (modperl_cleanup_data_t *)data;
+    PerlInterpreter *my_perl = cdata == NULL ? NULL : (PerlInterpreter *)cdata->data;
+#endif
     MP_init_status = 0;
     MP_threads_started = 0;
     MP_post_post_config_phase = 0;
 
     MP_PERL_FREE_THREAD_KEY_WORKAROUND;
 
-    MP_TRACE_i(MP_FUNC, "mod_perl sys term\n");
+    MP_TRACE_i(MP_FUNC, "mod_perl sys term");
 
     modperl_env_unload();
 
@@ -601,14 +605,14 @@
     return APR_SUCCESS;
 }
 
-int modperl_hook_init(apr_pool_t *pconf, apr_pool_t *plog, 
+int modperl_hook_init(apr_pool_t *pconf, apr_pool_t *plog,
                       apr_pool_t *ptemp, server_rec *s)
 {
     if (MP_IS_STARTING || MP_IS_RUNNING) {
         return OK;
     }
 
-    MP_TRACE_i(MP_FUNC, "mod_perl hook init\n");
+    MP_TRACE_i(MP_FUNC, "mod_perl hook init");
 
     MP_init_status = 1; /* now starting */
 
@@ -703,12 +707,12 @@
     }
 #endif
 
-#if PERL_REVISION == 5 && PERL_VERSION < 9
+#if MP_PERL_VERSION_AT_LEAST(5, 9, 0)
+#define MP_PERL_VERSION_STAMP "Perl/%" SVf
+#else
 #define MP_PERL_VERSION_STAMP "Perl/v%vd"
-#else
-#define MP_PERL_VERSION_STAMP "Perl/%" SVf
 #endif
-    
+
     ap_add_version_component(pconf, MP_VERSION_STRING);
     ap_add_version_component(pconf,
                              Perl_form(aTHX_ MP_PERL_VERSION_STAMP,
@@ -754,7 +758,7 @@
 }
 
 static int modperl_hook_header_parser(request_rec *r)
-{    
+{
     /* if 'PerlOptions +GlobalRequest' is inside a container */
     modperl_global_request_cfg_set(r);
 
@@ -831,6 +835,7 @@
 
 #ifdef USE_ITHREADS
     APR_REGISTER_OPTIONAL_FN(modperl_interp_unselect);
+    APR_REGISTER_OPTIONAL_FN(modperl_thx_interp_get);
 #endif
 
     /* for <IfDefine MODPERL2> and Apache2->define("MODPERL2") */
@@ -896,7 +901,7 @@
     modperl_register_handler_hooks();
 }
 
-static const command_rec modperl_cmds[] = {  
+static const command_rec modperl_cmds[] = {
     MP_CMD_SRV_ITERATE("PerlSwitches", switches, "Perl Switches"),
     MP_CMD_DIR_ITERATE("PerlModule", modules, "PerlModule"),
     MP_CMD_DIR_ITERATE("PerlRequire", requires, "PerlRequire"),
@@ -952,8 +957,8 @@
                     "Turn on -w switch"),
 #endif
     MP_CMD_ENTRIES,
-    { NULL }, 
-}; 
+    { NULL },
+};
 
 void modperl_response_init(request_rec *r)
 {
@@ -1011,6 +1016,7 @@
 int modperl_response_handler(request_rec *r)
 {
     MP_dDCFG;
+    MP_dRCFG;
     apr_status_t retval;
 
 #ifdef USE_ITHREADS
@@ -1025,6 +1031,9 @@
 #ifdef USE_ITHREADS
     interp = modperl_interp_select(r, r->connection, r->server);
     aTHX = interp->perl;
+    if (MpInterpPUTBACK(interp)) {
+        rcfg->interp = interp;
+    }
 #endif
 
     /* default is -SetupEnv, add if PerlOption +SetupEnv */
@@ -1037,6 +1046,7 @@
 #ifdef USE_ITHREADS
     if (MpInterpPUTBACK(interp)) {
         /* PerlInterpScope handler */
+        rcfg->interp = NULL;
         modperl_interp_unselect(interp);
     }
 #endif
@@ -1133,7 +1143,7 @@
 }
 
 module AP_MODULE_DECLARE_DATA perl_module = {
-    STANDARD20_MODULE_STUFF, 
+    STANDARD20_MODULE_STUFF,
     modperl_config_dir_create, /* dir config creater */
     modperl_config_dir_merge,  /* dir merger --- default is to override */
     modperl_config_srv_create, /* server config */
Index: src/modules/perl/mod_perl.h
===================================================================
--- src/modules/perl/mod_perl.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/mod_perl.h	(.../trunk)	(revision 630610)
@@ -55,7 +55,7 @@
 
 /* apr largefile support is enabled, perl support is disabled */
 #if (!defined(USE_LARGE_FILES)) && APR_HAS_LARGE_FILES
-#define MP_LARGE_FILES_APR_ONLY   
+#define MP_LARGE_FILES_APR_ONLY
 #endif
 
 /* conflict due to not have either both perl and apr
@@ -103,7 +103,7 @@
         Perl_croak(aTHX_ "Can't run '%s' in the threaded "      \
                    "environment after server startup", what);   \
     }
-  
+
 #define MP_CROAK_IF_THREADED_MPM(what)                          \
     if (modperl_threaded_mpm()) {                               \
         Perl_croak(aTHX_ "Can't run '%s' in a threaded mpm",    \
@@ -122,7 +122,7 @@
 void modperl_init_globals(server_rec *s, apr_pool_t *pconf);
 int modperl_run(void);
 int modperl_is_running(void);
-int modperl_hook_init(apr_pool_t *pconf, apr_pool_t *plog, 
+int modperl_hook_init(apr_pool_t *pconf, apr_pool_t *plog,
                       apr_pool_t *ptemp, server_rec *s);
 int modperl_hook_pre_config(apr_pool_t *p, apr_pool_t *plog,
                             apr_pool_t *ptemp);
@@ -138,11 +138,6 @@
 int modperl_response_handler(request_rec *r);
 int modperl_response_handler_cgi(request_rec *r);
 
-/* betting on Perl*Handlers not using CvXSUBANY
- * mod_perl reuses this field for handler attributes
- */
-#define MP_CODE_ATTRS(cv) (CvXSUBANY((CV*)cv).any_i32)
-
 #define MgTypeExt(mg) (mg->mg_type == '~')
 
 typedef void MP_FUNC_NONSTD_T(modperl_var_modify_t) (apr_table_t *,
@@ -153,7 +148,10 @@
 /* we need to hook a few internal things before APR_HOOK_REALLY_FIRST */
 #define MODPERL_HOOK_REALLY_REALLY_FIRST (-20)
 
+#ifdef USE_ITHREADS
 APR_DECLARE_OPTIONAL_FN(apr_status_t,modperl_interp_unselect,(void *));
+APR_DECLARE_OPTIONAL_FN(modperl_interp_t *,modperl_thx_interp_get,(PerlInterpreter *));
+#endif
 
 /*
  * perl context overriding and restoration is required when
Index: src/modules/perl/modperl_svptr_table.c
===================================================================
--- src/modules/perl/modperl_svptr_table.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_svptr_table.c	(.../trunk)	(revision 630610)
@@ -29,7 +29,7 @@
 
 #ifdef USE_ITHREADS
 
-#ifdef MP_PERL_5_6_x
+#if MP_PERL_BRANCH(5, 6)
 #   define my_sv_dup(s, p) sv_dup(s)
 
 typedef struct {
@@ -55,8 +55,8 @@
     CLONE_PARAMS parms;
 
     Newz(0, tbl, 1, PTR_TBL_t);
-    tbl->tbl_max	= source->tbl_max;
-    tbl->tbl_items	= source->tbl_items;
+    tbl->tbl_max        = source->tbl_max;
+    tbl->tbl_items        = source->tbl_items;
     Newz(0, tbl->tbl_ary, tbl->tbl_max + 1, PTR_TBL_ENT_t *);
 
     dst_ary = tbl->tbl_ary;
@@ -67,13 +67,13 @@
     parms.stashes = newAV();
 
     for (i=0; i < source->tbl_max; i++, dst_ary++, src_ary++) {
-	PTR_TBL_ENT_t *src_ent, *dst_ent=NULL;
+        PTR_TBL_ENT_t *src_ent, *dst_ent=NULL;
 
-	if (!*src_ary) {
-	    continue;
+        if (!*src_ary) {
+            continue;
         }
 
-	for (src_ent = *src_ary;
+        for (src_ent = *src_ary;
              src_ent;
              src_ent = src_ent->next)
         {
@@ -110,13 +110,13 @@
     PTR_TBL_ENT_t **ary = tbl->tbl_ary;
 
     for (i=0; i < tbl->tbl_max; i++, ary++) {
-	PTR_TBL_ENT_t *ent;
+        PTR_TBL_ENT_t *ent;
 
-	if (!*ary) {
-	    continue;
+        if (!*ary) {
+            continue;
         }
 
-	for (ent = *ary; ent; ent = ent->next) {
+        for (ent = *ary; ent; ent = ent->next) {
             if (!ent->newval) {
                 continue;
             }
@@ -143,13 +143,13 @@
     entry = *oentry;
 
     for (; entry; oentry = &entry->next, entry = *oentry) {
-	if (entry->oldval == key) {
+        if (entry->oldval == key) {
             *oentry = entry->next;
             SvREFCNT_dec((SV*)entry->newval);
             Safefree(entry);
             tbl->tbl_items--;
-	    return;
-	}
+            return;
+        }
     }
 }
 
@@ -168,8 +168,8 @@
 {
     PTR_TBL_t *tbl;
     Newz(0, tbl, 1, PTR_TBL_t);
-    tbl->tbl_max	= 511;
-    tbl->tbl_items	= 0;
+    tbl->tbl_max        = 511;
+    tbl->tbl_items        = 0;
     Newz(0, tbl->tbl_ary, tbl->tbl_max + 1, PTR_TBL_ENT_t*);
     return tbl;
 }
@@ -184,8 +184,8 @@
     assert(tbl);
     tblent = tbl->tbl_ary[hash & tbl->tbl_max];
     for (; tblent; tblent = tblent->next) {
-	if (tblent->oldval == sv)
-	    return tblent->newval;
+        if (tblent->oldval == sv)
+            return tblent->newval;
     }
     return (void*)NULL;
 }
@@ -205,10 +205,10 @@
     assert(tbl);
     otblent = &tbl->tbl_ary[hash & tbl->tbl_max];
     for (tblent = *otblent; tblent; i=0, tblent = tblent->next) {
-	if (tblent->oldval == oldv) {
-	    tblent->newval = newv;
-	    return;
-	}
+        if (tblent->oldval == oldv) {
+            tblent->newval = newv;
+            return;
+        }
     }
     Newz(0, tblent, 1, PTR_TBL_ENT_t);
     tblent->oldval = oldv;
@@ -217,7 +217,7 @@
     *otblent = tblent;
     tbl->tbl_items++;
     if (i && tbl->tbl_items > tbl->tbl_max)
-	modperl_svptr_table_split(aTHX_ tbl);
+        modperl_svptr_table_split(aTHX_ tbl);
 }
 
 /* double the hash bucket size of an existing ptr table */
@@ -235,20 +235,20 @@
     tbl->tbl_max = --newsize;
     tbl->tbl_ary = ary;
     for (i=0; i < oldsize; i++, ary++) {
-	PTR_TBL_ENT_t **curentp, **entp, *ent;
-	if (!*ary)
-	    continue;
-	curentp = ary + oldsize;
-	for (entp = ary, ent = *ary; ent; ent = *entp) {
-	    if ((newsize & PTR2UV(ent->oldval)) != i) {
-		*entp = ent->next;
-		ent->next = *curentp;
-		*curentp = ent;
-		continue;
-	    }
-	    else
-		entp = &ent->next;
-	}
+        PTR_TBL_ENT_t **curentp, **entp, *ent;
+        if (!*ary)
+            continue;
+        curentp = ary + oldsize;
+        for (entp = ary, ent = *ary; ent; ent = *entp) {
+            if ((newsize & PTR2UV(ent->oldval)) != i) {
+                *entp = ent->next;
+                ent->next = *curentp;
+                *curentp = ent;
+                continue;
+            }
+            else
+                entp = &ent->next;
+        }
     }
 }
 
Index: src/modules/perl/modperl_const.c
===================================================================
--- src/modules/perl/modperl_const.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_const.c	(.../trunk)	(revision 630610)
@@ -117,7 +117,7 @@
     }
 
     classname = *(stashname + 1) == 'P'
-        ? "APR::Const" 
+        ? "APR::Const"
         : (*stashname == 'A' ? "Apache2::Const" : "ModPerl");
     arg = SvPV(ST(1),n_a);
 
Index: src/modules/perl/modperl_mgv.c
===================================================================
--- src/modules/perl/modperl_mgv.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_mgv.c	(.../trunk)	(revision 630610)
@@ -64,7 +64,7 @@
 
 #define modperl_mgv_hash(mgv)                   \
     PERL_HASH(mgv->hash, mgv->name, mgv->len)
- /* MP_TRACE_h(MP_FUNC, "%s...hash=%ld\n", mgv->name, mgv->hash) */
+ /* MP_TRACE_h(MP_FUNC, "%s...hash=%ld", mgv->name, mgv->hash) */
 
 modperl_mgv_t *modperl_mgv_compile(pTHX_ apr_pool_t *p,
                                    register const char *name)
@@ -156,7 +156,7 @@
         return gv;
     }
 
-    /* 
+    /*
      * this VirtualHost has its own parent interpreter
      * must require the module again with this server's THX
      */
@@ -247,31 +247,31 @@
                 if (SvROK(obj) && sv_isobject(obj)) {
                     stash = SvSTASH(SvRV(obj));
                     MpHandlerOBJECT_On(handler);
-                    MP_TRACE_h(MP_FUNC, "handler object %s isa %s\n",
+                    MP_TRACE_h(MP_FUNC, "handler object %s isa %s",
                                package, HvNAME(stash));
                 }
                 else {
-                    MP_TRACE_h(MP_FUNC, "%s is not an object, pv=%s\n",
+                    MP_TRACE_h(MP_FUNC, "%s is not an object, pv=%s",
                                package, SvPV_nolen(obj));
                     return 0;
                 }
             }
             else {
-                MP_TRACE_h(MP_FUNC, "failed to thaw %s\n", package);
+                MP_TRACE_h(MP_FUNC, "failed to thaw %s", package);
                 return 0;
             }
         }
 
         if (!stash) {
             if ((stash = gv_stashpvn(package, package_len, FALSE))) {
-                MP_TRACE_h(MP_FUNC, "handler method %s isa %s\n",
+                MP_TRACE_h(MP_FUNC, "handler method %s isa %s",
                            name, HvNAME(stash));
             }
         }
     }
     else {
         if ((cv = get_cv(name, FALSE))) {
-            handler->attrs = (U32)MP_CODE_ATTRS(cv);
+            handler->attrs = *modperl_code_attrs(aTHX_ cv);
             handler->mgv_cv =
                 modperl_mgv_compile(aTHX_ p, HvNAME(GvSTASH(CvGV(cv))));
             modperl_mgv_append(aTHX_ p, handler->mgv_cv, GvNAME(CvGV(cv)));
@@ -284,11 +284,11 @@
     if (!stash && MpHandlerAUTOLOAD(handler)) {
         if (!modperl_perl_module_loaded(aTHX_ name)) { /* not in %INC */
             MP_TRACE_h(MP_FUNC,
-                       "package %s not in %INC, attempting to load it\n",
+                       "package %s not in %INC, attempting to load it",
                        name);
 
             if (modperl_require_module(aTHX_ name, logfailure)) {
-                MP_TRACE_h(MP_FUNC, "loaded %s package\n", name);
+                MP_TRACE_h(MP_FUNC, "loaded %s package", name);
             }
             else {
                 if (logfailure) {
@@ -297,13 +297,13 @@
                 }
                 else {
                     /* the caller handles the error checking */
-                    MP_TRACE_h(MP_FUNC, "failed to load %s package\n", name);
+                    MP_TRACE_h(MP_FUNC, "failed to load %s package", name);
                     return 0;
                 }
             }
         }
         else {
-            MP_TRACE_h(MP_FUNC, "package %s seems to be loaded\n", name);
+            MP_TRACE_h(MP_FUNC, "package %s seems to be loaded", name);
         }
     }
 
@@ -312,7 +312,7 @@
      * module was loaded, preventing from loading the module
      */
     if (!(stash || (stash = gv_stashpv(name, FALSE)))) {
-        MP_TRACE_h(MP_FUNC, "%s's stash is not found\n", name);
+        MP_TRACE_h(MP_FUNC, "%s's stash is not found", name);
         return 0;
     }
 
@@ -324,8 +324,8 @@
         if (!stash) {
             return 0;
         }
-        
-        
+
+
         if (MpHandlerMETHOD(handler) && !handler->mgv_obj) {
             char *name = HvNAME(stash);
             if (!name) {
@@ -334,13 +334,13 @@
             modperl_mgv_new_name(handler->mgv_obj, p, name);
         }
 
-        handler->attrs = (U32)MP_CODE_ATTRS(cv);
+        handler->attrs = *modperl_code_attrs(aTHX_ cv);
         /* note: this is the real function after @ISA lookup */
         handler->mgv_cv = modperl_mgv_compile(aTHX_ p, HvNAME(GvSTASH(gv)));
         modperl_mgv_append(aTHX_ p, handler->mgv_cv, handler_name);
 
         MpHandlerPARSED_On(handler);
-        MP_TRACE_h(MP_FUNC, "[%s] found `%s' in class `%s' as a %s\n",
+        MP_TRACE_h(MP_FUNC, "[%s] found `%s' in class `%s' as a %s",
                    modperl_pid_tid(p),
                    handler_name, HvNAME(stash),
                    MpHandlerMETHOD(handler) ? "method" : "function");
@@ -359,7 +359,7 @@
 #ifdef MP_TRACE
     /* complain only if the class was actually loaded/created */
     if (stash) {
-        MP_TRACE_h(MP_FUNC, "`%s' not found in class `%s'\n",
+        MP_TRACE_h(MP_FUNC, "`%s' not found in class `%s'",
                    handler_name, name);
     }
 #endif
@@ -418,7 +418,7 @@
         modperl_mgv_as_string(aTHX_ symbol, p, 1);
 
     if (modperl_require_module(aTHX_ package, TRUE)) {
-        MP_TRACE_h(MP_FUNC, "reloaded %s for server %s\n",
+        MP_TRACE_h(MP_FUNC, "reloaded %s for server %s",
                    package, modperl_server_desc(s, p));
         return TRUE;
     }
@@ -452,7 +452,7 @@
 #ifdef USE_ITHREADS
             if ((MpSrvPARENT(scfg) && MpSrvAUTOLOAD(scfg))
                 && !modperl_mgv_lookup(aTHX_ handler->mgv_cv)) {
-                /* 
+                /*
                  * this VirtualHost has its own parent interpreter
                  * must require the module again with this server's THX
                  */
@@ -460,7 +460,7 @@
                                            s, p);
             }
 #endif
-            MP_TRACE_h(MP_FUNC, "%s already resolved in server %s\n",
+            MP_TRACE_h(MP_FUNC, "%s already resolved in server %s",
                        modperl_handler_name(handler),
                        modperl_server_desc(s, p));
         }
Index: src/modules/perl/modperl_apr_compat.h
===================================================================
--- src/modules/perl/modperl_apr_compat.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_apr_compat.h	(.../trunk)	(revision 630610)
@@ -109,7 +109,7 @@
 #ifndef APR_FOPEN_READ
 #define APR_FOPEN_READ        APR_READ
 #endif
-#ifndef APR_FOPEN_WRITE 
+#ifndef APR_FOPEN_WRITE
 #define APR_FOPEN_WRITE       APR_WRITE
 #endif
 #ifndef APR_FOPEN_CREATE
@@ -124,16 +124,16 @@
 #ifndef APR_FOPEN_BINARY
 #define APR_FOPEN_BINARY      APR_BINARY
 #endif
-#ifndef APR_FOPEN_EXCL 
+#ifndef APR_FOPEN_EXCL
 #define APR_FOPEN_EXCL        APR_EXCL
 #endif
-#ifndef APR_FOPEN_BUFFERED 
+#ifndef APR_FOPEN_BUFFERED
 #define APR_FOPEN_BUFFERED    APR_BUFFERED
 #endif
 #ifndef APR_FOPEN_DELONCLOSE
 #define APR_FOPEN_DELONCLOSE  APR_DELONCLOSE
 #endif
-#ifndef APR_FOPEN_XTHREAD 
+#ifndef APR_FOPEN_XTHREAD
 #define APR_FOPEN_XTHREAD     APR_XTHREAD
 #endif
 #ifndef APR_FOPEN_SHARELOCK
Index: src/modules/perl/modperl_callback.c
===================================================================
--- src/modules/perl/modperl_callback.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_callback.c	(.../trunk)	(revision 630610)
@@ -88,7 +88,7 @@
                 name = handler->name;
             }
 
-            MP_TRACE_h(MP_FUNC, "[%s %s] lookup of %s failed\n",
+            MP_TRACE_h(MP_FUNC, "[%s %s] lookup of %s failed",
                        modperl_pid_tid(p),
                        modperl_server_desc(s, p), name);
             ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
@@ -112,7 +112,7 @@
             if (status_sv == &PL_sv_undef) {
                 /* ModPerl::Util::exit() and Perl_croak internally
                  * arrange to return PL_sv_undef with G_EVAL|G_SCALAR */
-                status = OK; 
+                status = OK;
             }
             else {
                 status = SvIVx(status_sv);
@@ -163,7 +163,7 @@
     AV *av_args = Nullav;
 
     if (!MpSrvENABLE(scfg)) {
-        MP_TRACE_h(MP_FUNC, "PerlOff for server %s:%u\n",
+        MP_TRACE_h(MP_FUNC, "PerlOff for server %s:%u",
                    s->server_hostname, s->port);
         return DECLINED;
     }
@@ -179,7 +179,7 @@
                                           type, idx, FALSE, &desc);
 
     if (!(avp && (av = *avp))) {
-        MP_TRACE_h(MP_FUNC, "no %s handlers configured (%s)\n",
+        MP_TRACE_h(MP_FUNC, "no %s handlers configured (%s)",
                    desc, r ? r->uri : "");
         return DECLINED;
     }
@@ -254,14 +254,14 @@
 
     modperl_callback_current_callback_set(desc);
 
-    MP_TRACE_h(MP_FUNC, "[%s] running %d %s handlers\n",
+    MP_TRACE_h(MP_FUNC, "[%s] running %d %s handlers",
                modperl_pid_tid(p), av->nelts, desc);
     handlers = (modperl_handler_t **)av->elts;
 
     for (i=0; i<av->nelts; i++) {
         status = modperl_callback(aTHX_ handlers[i], p, r, s, av_args);
 
-        MP_TRACE_h(MP_FUNC, "callback '%s' returned %d\n",
+        MP_TRACE_h(MP_FUNC, "callback '%s' returned %d",
                    modperl_handler_name(handlers[i]), status);
 
         /* follow Apache's lead and let OK terminate the phase for
@@ -290,7 +290,7 @@
                 break;
             }
             /* the normal case:
-             *   OK and DECLINED continue 
+             *   OK and DECLINED continue
              *   errors end the phase
              */
             else if ((status != OK) && (status != DECLINED)) {
@@ -299,7 +299,7 @@
 #ifdef MP_TRACE
                 if (i+1 != av->nelts) {
                     MP_TRACE_h(MP_FUNC, "error status %d leaves %d "
-                               "uncalled %s handlers\n",
+                               "uncalled %s handlers",
                                status, av->nelts-i-1, desc);
                 }
 #endif
@@ -316,7 +316,7 @@
 #ifdef MP_TRACE
                 if (i+1 != av->nelts) {
                     MP_TRACE_h(MP_FUNC, "OK ends the %s stack, "
-                               "leaving %d uncalled %s handlers\n",
+                               "leaving %d uncalled %s handlers",
                                desc, av->nelts-i-1, desc);
                 }
 #endif
@@ -327,7 +327,7 @@
 #ifdef MP_TRACE
                 if (i+1 != av->nelts) {
                     MP_TRACE_h(MP_FUNC, "error status %d leaves %d "
-                               "uncalled %s handlers\n",
+                               "uncalled %s handlers",
                                status, av->nelts-i-1, desc);
                 }
 #endif
@@ -337,7 +337,7 @@
         else {
             /* the rare case.
              * MP_HOOK_VOID handlers completely ignore the return status
-             * Apache should handle whatever mod_perl returns, 
+             * Apache should handle whatever mod_perl returns,
              * so there is no need to mess with the status
              */
         }
@@ -371,7 +371,7 @@
                                          NULL, NULL, NULL, run_mode);
 }
 
-int modperl_callback_per_srv(int idx, request_rec *r, 
+int modperl_callback_per_srv(int idx, request_rec *r,
                              modperl_hook_run_mode_e run_mode)
 {
     return modperl_callback_run_handlers(idx,
@@ -380,7 +380,7 @@
                                          NULL, NULL, NULL, run_mode);
 }
 
-int modperl_callback_connection(int idx, conn_rec *c, 
+int modperl_callback_connection(int idx, conn_rec *c,
                                 modperl_hook_run_mode_e run_mode)
 {
     return modperl_callback_run_handlers(idx,
Index: src/modules/perl/modperl_common_debug.c
===================================================================
--- src/modules/perl/modperl_common_debug.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_common_debug.c	(.../trunk)	(revision 630610)
@@ -17,4 +17,3 @@
 /* This file must not contain any symbols from apache/mod_perl
  *  (apr and perl are OK) */
 #include "modperl_common_includes.h"
-
Index: src/modules/perl/modperl_interp.c
===================================================================
--- src/modules/perl/modperl_interp.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_interp.c	(.../trunk)	(revision 630610)
@@ -55,7 +55,7 @@
                                      PerlInterpreter *perl)
 {
     UV clone_flags = CLONEf_KEEP_PTR_TABLE;
-    modperl_interp_t *interp = 
+    modperl_interp_t *interp =
         (modperl_interp_t *)malloc(sizeof(*interp));
 
     memset(interp, '\0', sizeof(*interp));
@@ -79,7 +79,7 @@
 
         interp->perl = perl_clone(perl, clone_flags);
 
-#if PERL_REVISION == 5 && PERL_VERSION == 8 && PERL_SUBVERSION == 0 && \
+#if MP_PERL_VERSION(5, 8, 0) && \
     defined(USE_REENTRANT_API) && defined(HAS_CRYPT_R) && defined(__GLIBC__)
         {
             dTHXa(interp->perl);
@@ -120,7 +120,7 @@
 #endif
     }
 
-    MP_TRACE_i(MP_FUNC, "0x%lx / perl: 0x%lx / parent perl: 0x%lx\n",
+    MP_TRACE_i(MP_FUNC, "0x%lx / perl: 0x%lx / parent perl: 0x%lx",
                (unsigned long)interp, (unsigned long)interp->perl,
                (unsigned long)perl);
 
@@ -134,11 +134,11 @@
 
     PERL_SET_CONTEXT(interp->perl);
 
-    MP_TRACE_i(MP_FUNC, "interp == 0x%lx / perl: 0x%lx\n",
+    MP_TRACE_i(MP_FUNC, "interp == 0x%lx / perl: 0x%lx",
                (unsigned long)interp, (unsigned long)interp->perl);
 
     if (MpInterpIN_USE(interp)) {
-        MP_TRACE_i(MP_FUNC, "*error - still in use!*\n");
+        MP_TRACE_i(MP_FUNC, "*error - still in use!*");
     }
 
     handles = modperl_xs_dl_handles_get(aTHX);
@@ -166,16 +166,16 @@
     head = modperl_tipool_pop(mip->tipool);
     interp = (modperl_interp_t *)head->data;
 
-    MP_TRACE_i(MP_FUNC, "head == 0x%lx, parent == 0x%lx\n",
+    MP_TRACE_i(MP_FUNC, "head == 0x%lx, parent == 0x%lx",
                (unsigned long)head, (unsigned long)mip->parent);
 
-    MP_TRACE_i(MP_FUNC, "selected 0x%lx (perl==0x%lx)\n",
+    MP_TRACE_i(MP_FUNC, "selected 0x%lx (perl==0x%lx)",
                (unsigned long)interp,
                (unsigned long)interp->perl);
 
 #ifdef MP_TRACE
     interp->tid = MP_TIDF;
-    MP_TRACE_i(MP_FUNC, "thread == 0x%lx\n", interp->tid);
+    MP_TRACE_i(MP_FUNC, "thread == 0x%lx", interp->tid);
 #endif
 
     MpInterpIN_USE_On(interp);
@@ -196,7 +196,7 @@
         /* multiple mips might share the same parent
          * make sure its only destroyed once
          */
-        MP_TRACE_i(MP_FUNC, "parent == 0x%lx\n",
+        MP_TRACE_i(MP_FUNC, "parent == 0x%lx",
                    (unsigned long)mip->parent);
 
         modperl_interp_destroy(mip->parent);
@@ -208,7 +208,7 @@
 static void *interp_pool_grow(modperl_tipool_t *tipool, void *data)
 {
     modperl_interp_pool_t *mip = (modperl_interp_pool_t *)data;
-    MP_TRACE_i(MP_FUNC, "adding new interpreter to the pool\n");
+    MP_TRACE_i(MP_FUNC, "adding new interpreter to the pool");
     return (void *)modperl_interp_new(mip, mip->parent->perl);
 }
 
@@ -223,7 +223,7 @@
 {
     while (listp) {
         modperl_interp_t *interp = (modperl_interp_t *)listp->data;
-        MP_TRACE_i(MP_FUNC, "listp==0x%lx, interp==0x%lx, requests=%d\n",
+        MP_TRACE_i(MP_FUNC, "listp==0x%lx, interp==0x%lx, requests=%d",
                  (unsigned long)listp, (unsigned long)interp,
                  interp->num_requests);
         listp = listp->next;
@@ -244,10 +244,10 @@
     apr_pool_t *server_pool = modperl_server_pool();
     pTHX;
     MP_dSCFG(s);
-    modperl_interp_pool_t *mip = 
+    modperl_interp_pool_t *mip =
         (modperl_interp_pool_t *)apr_pcalloc(p, sizeof(*mip));
 
-    MP_TRACE_i(MP_FUNC, "server=%s\n", modperl_server_desc(s, p));
+    MP_TRACE_i(MP_FUNC, "server=%s", modperl_server_desc(s, p));
 
     if (modperl_threaded_mpm()) {
         mip->tipool = modperl_tipool_new(p, scfg->interp_pool_cfg,
@@ -275,7 +275,7 @@
 
     if (interp->refcnt != 0) {
         --interp->refcnt;
-        MP_TRACE_i(MP_FUNC, "interp=0x%lx, refcnt=%d\n",
+        MP_TRACE_i(MP_FUNC, "interp=0x%lx, refcnt=%d",
                    (unsigned long)interp, interp->refcnt);
         return APR_SUCCESS;
     }
@@ -291,7 +291,7 @@
     MpInterpIN_USE_Off(interp);
     MpInterpPUTBACK_Off(interp);
 
-    MP_THX_INTERP_SET(interp->perl, NULL);
+    modperl_thx_interp_set(interp->perl, NULL);
 
     modperl_tipool_putback_data(mip->tipool, data, interp->num_requests);
 
@@ -343,7 +343,7 @@
     modperl_interp_t *interp = NULL;
 
     if (scfg && (is_startup || !modperl_threaded_mpm())) {
-        MP_TRACE_i(MP_FUNC, "using parent interpreter at %s\n",
+        MP_TRACE_i(MP_FUNC, "using parent interpreter at %s",
                    is_startup ? "startup" : "request time (non-threaded MPM)");
 
         if (!scfg->mip) {
@@ -360,11 +360,11 @@
             interp = modperl_interp_get(s);
             modperl_interp_pool_set(p, interp, TRUE);
 
-            MP_TRACE_i(MP_FUNC, "set interp in request time pool 0x%lx\n",
+            MP_TRACE_i(MP_FUNC, "set interp in request time pool 0x%lx",
                        (unsigned long)p);
         }
         else {
-            MP_TRACE_i(MP_FUNC, "found interp in request time pool 0x%lx\n",
+            MP_TRACE_i(MP_FUNC, "found interp in request time pool 0x%lx",
                        (unsigned long)p);
         }
     }
@@ -386,7 +386,7 @@
 
     if (!modperl_threaded_mpm()) {
         MP_TRACE_i(MP_FUNC,
-                   "using parent 0x%lx for non-threaded mpm (%s:%d)\n",
+                   "using parent 0x%lx for non-threaded mpm (%s:%d)",
                    (unsigned long)scfg->mip->parent,
                    s->server_hostname, s->port);
         /* XXX: if no VirtualHosts w/ PerlOptions +Parent we can skip this */
@@ -412,11 +412,11 @@
      * else scope must be per-connection
      */
 
-    scope = (dcfg && !modperl_interp_scope_undef(dcfg)) ? 
+    scope = (dcfg && !modperl_interp_scope_undef(dcfg)) ?
         dcfg->interp_scope :
         (r ? scfg->interp_scope : MP_INTERP_SCOPE_CONNECTION);
 
-    MP_TRACE_i(MP_FUNC, "scope is per-%s\n",
+    MP_TRACE_i(MP_FUNC, "scope is per-%s",
                modperl_interp_scope_desc(scope));
 
     /*
@@ -448,7 +448,7 @@
                            "looking for interp in main request for %s...%s\n",
                            main_r->uri, interp ? "found" : "not found");
                 main_r = main_r->main;
-            }                
+            }
         }
         else {
             p = r->pool;
@@ -490,7 +490,7 @@
     else {
         if (!p) {
             /* should never happen */
-            MP_TRACE_i(MP_FUNC, "no pool\n");
+            MP_TRACE_i(MP_FUNC, "no pool");
             return NULL;
         }
 
@@ -506,7 +506,7 @@
     /* set context (THX) for this thread */
     PERL_SET_CONTEXT(interp->perl);
 
-    MP_THX_INTERP_SET(interp->perl, interp);
+    modperl_thx_interp_set(interp->perl, interp);
 
     return interp;
 }
@@ -575,6 +575,24 @@
     }
 }
 
+#define MP_THX_INTERP_KEY "modperl2::thx_interp_key"
+modperl_interp_t *modperl_thx_interp_get(PerlInterpreter *thx)
+{
+    modperl_interp_t *interp;
+    dTHXa(thx);
+    SV **svp = hv_fetch(PL_modglobal, MP_THX_INTERP_KEY, strlen(MP_THX_INTERP_KEY), 0);
+    if (!svp) return;
+    interp = INT2PTR(modperl_interp_t *, SvIV(*svp));
+    return interp;
+}
+
+void modperl_thx_interp_set(PerlInterpreter *thx, modperl_interp_t *interp)
+{
+    dTHXa(thx);
+    hv_store(PL_modglobal, MP_THX_INTERP_KEY, strlen(MP_THX_INTERP_KEY), newSViv(PTR2IV(interp)), 0);
+    return;
+}
+
 #else
 
 void modperl_interp_init(server_rec *s, apr_pool_t *p,
Index: src/modules/perl/modperl_callback.h
===================================================================
--- src/modules/perl/modperl_callback.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_callback.h	(.../trunk)	(revision 630610)
@@ -45,7 +45,7 @@
                                   apr_pool_t *ptemp,
                                   modperl_hook_run_mode_e run_mode);
 
-int modperl_callback_per_dir(int idx, request_rec *r, 
+int modperl_callback_per_dir(int idx, request_rec *r,
                              modperl_hook_run_mode_e run_mode);
 
 int modperl_callback_per_srv(int idx, request_rec *r,
Index: src/modules/perl/modperl_config.c
===================================================================
--- src/modules/perl/modperl_config.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_config.c	(.../trunk)	(revision 630610)
@@ -22,8 +22,8 @@
 
     dcfg->location = dir;
 
-    MP_TRACE_d(MP_FUNC, "dir %s\n", dir);
-    
+    MP_TRACE_d(MP_FUNC, "dir %s", dir);
+
 #ifdef USE_ITHREADS
     /* defaults to per-server scope */
     dcfg->interp_scope = MP_INTERP_SCOPE_UNDEF;
@@ -110,7 +110,7 @@
         *add  = (modperl_config_dir_t *)addv,
         *mrg  = modperl_config_dir_new(p);
 
-    MP_TRACE_d(MP_FUNC, "basev==0x%lx, addv==0x%lx, mrg==0x%lx\n", 
+    MP_TRACE_d(MP_FUNC, "basev==0x%lx, addv==0x%lx, mrg==0x%lx",
                (unsigned long)basev, (unsigned long)addv,
                (unsigned long)mrg);
 
@@ -140,20 +140,20 @@
 
 modperl_config_req_t *modperl_config_req_new(request_rec *r)
 {
-    modperl_config_req_t *rcfg = 
+    modperl_config_req_t *rcfg =
         (modperl_config_req_t *)apr_pcalloc(r->pool, sizeof(*rcfg));
 
-    MP_TRACE_d(MP_FUNC, "0x%lx\n", (unsigned long)rcfg);
+    MP_TRACE_d(MP_FUNC, "0x%lx", (unsigned long)rcfg);
 
     return rcfg;
 }
 
 modperl_config_con_t *modperl_config_con_new(conn_rec *c)
 {
-    modperl_config_con_t *ccfg = 
+    modperl_config_con_t *ccfg =
         (modperl_config_con_t *)apr_pcalloc(c->pool, sizeof(*ccfg));
 
-    MP_TRACE_d(MP_FUNC, "0x%lx\n", (unsigned long)ccfg);
+    MP_TRACE_d(MP_FUNC, "0x%lx", (unsigned long)ccfg);
 
     return ccfg;
 }
@@ -182,13 +182,13 @@
 
 #ifdef MP_USE_GTOP
     scfg->gtop = modperl_gtop_new(p);
-#endif        
+#endif
 
     /* make sure httpd's argv[0] is the first argument so $0 is
      * correctly connected to the real thing */
     modperl_config_srv_argv_push(s->process->argv[0]);
 
-    MP_TRACE_d(MP_FUNC, "new scfg: 0x%lx\n", (unsigned long)scfg);
+    MP_TRACE_d(MP_FUNC, "new scfg: 0x%lx", (unsigned long)scfg);
 
     return scfg;
 }
@@ -205,7 +205,7 @@
 
     dcfg->SetEnv = apr_table_make(p, 2);
 
-    MP_TRACE_d(MP_FUNC, "new dcfg: 0x%lx\n", (unsigned long)dcfg);
+    MP_TRACE_d(MP_FUNC, "new dcfg: 0x%lx", (unsigned long)dcfg);
 
     return dcfg;
 }
@@ -253,12 +253,12 @@
         modperl_init_globals(s, p);
     }
 
-    MP_TRACE_d(MP_FUNC, "p=0x%lx, s=0x%lx, virtual=%d\n",
+    MP_TRACE_d(MP_FUNC, "p=0x%lx, s=0x%lx, virtual=%d",
                p, s, s->is_virtual);
 
 #ifdef USE_ITHREADS
 
-    scfg->interp_pool_cfg = 
+    scfg->interp_pool_cfg =
         (modperl_tipool_config_t *)
         apr_pcalloc(p, sizeof(*scfg->interp_pool_cfg));
 
@@ -286,7 +286,7 @@
         *add  = (modperl_config_srv_t *)addv,
         *mrg  = modperl_config_srv_new(p, add->server);
 
-    MP_TRACE_d(MP_FUNC, "basev==0x%lx, addv==0x%lx, mrg==0x%lx\n", 
+    MP_TRACE_d(MP_FUNC, "basev==0x%lx, addv==0x%lx, mrg==0x%lx",
                (unsigned long)basev, (unsigned long)addv,
                (unsigned long)mrg);
 
@@ -362,11 +362,6 @@
 
     retval = modperl_callback_per_dir(MP_CLEANUP_HANDLER, r, MP_HOOK_RUN_ALL);
 
-    if (rcfg->pnotes) {
-        SvREFCNT_dec(rcfg->pnotes);
-        rcfg->pnotes = Nullhv;
-    }
-
     /* undo changes to %ENV caused by +SetupEnv, perl-script, or
      * $r->subprocess_env, so the values won't persist  */
     if (MpReqSETUP_ENV(rcfg)) {
@@ -405,7 +400,7 @@
     entries = (char **)scfg->PerlModule->elts;
     for (i = 0; i < scfg->PerlModule->nelts; i++){
         if (modperl_require_module(aTHX_ entries[i], TRUE)){
-            MP_TRACE_d(MP_FUNC, "loaded Perl module %s for server %s\n",
+            MP_TRACE_d(MP_FUNC, "loaded Perl module %s for server %s",
                        entries[i], modperl_server_desc(s,p));
         }
         else {
@@ -430,7 +425,7 @@
     entries = (char **)scfg->PerlRequire->elts;
     for (i = 0; i < scfg->PerlRequire->nelts; i++){
         if (modperl_require_file(aTHX_ entries[i], TRUE)){
-            MP_TRACE_d(MP_FUNC, "loaded Perl file: %s for server %s\n",
+            MP_TRACE_d(MP_FUNC, "loaded Perl file: %s for server %s",
                        entries[i], modperl_server_desc(s,p));
         }
         else {
@@ -463,14 +458,14 @@
         MP_PERL_CONTEXT_RESTORE;
 
         if (retval) {
-            MP_TRACE_d(MP_FUNC, "loaded Perl file: %s for server %s\n",
+            MP_TRACE_d(MP_FUNC, "loaded Perl file: %s for server %s",
                        requires[i]->file, modperl_server_desc(s, p));
         }
         else {
             ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,
                          "Can't load Perl file: %s for server %s, exiting...",
                          requires[i]->file, modperl_server_desc(s, p));
-            
+
             return FALSE;
         }
     }
@@ -523,7 +518,7 @@
     parms.limited = -1;
     parms.server = s;
     parms.override = override;
-    parms.path = path;
+    parms.path = apr_pstrdup(p, path);
     parms.pool = p;
 #ifdef MP_HTTPD_HAS_OVERRIDE_OPTS
     if (override_options == MP_HTTPD_OVERRIDE_OPTS_UNSET) {
@@ -570,14 +565,14 @@
     return errmsg;
 }
 
-const char *modperl_config_insert_parms(pTHX_ cmd_parms *parms, 
+const char *modperl_config_insert_parms(pTHX_ cmd_parms *parms,
                                         SV *lines)
 {
-    return modperl_config_insert(aTHX_ 
-                                 parms->server, 
-                                 parms->pool, 
+    return modperl_config_insert(aTHX_
+                                 parms->server,
+                                 parms->pool,
                                  parms->temp_pool,
-                                 parms->override, 
+                                 parms->override,
                                  parms->path,
 #ifdef MP_HTTPD_HAS_OVERRIDE_OPTS
                                  parms->override_opts,
@@ -623,7 +618,7 @@
         return errmsg;
     }
 
-    r->per_dir_config = 
+    r->per_dir_config =
         ap_merge_per_dir_configs(r->pool,
                                  r->per_dir_config,
                                  dconf);
Index: src/modules/perl/modperl_interp.h
===================================================================
--- src/modules/perl/modperl_interp.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_interp.h	(.../trunk)	(revision 630610)
@@ -24,33 +24,9 @@
 
 #ifdef USE_ITHREADS
 
-/*
- * HvPMROOT will never be used by Perl with PL_modglobal.
- * so we have stolen it as a quick way to stash the interp
- * pointer.
- *
- * However in 5.9.3 HvPMROOT was completely removed, so we have moved
- * to use another struct member that's hopefully won't be used by
- * anybody else. But if we can find a better place to store the
- * pointer to the current mod_perl interpreter object it'd be a much
- * cleaner solution. of course it must be really fast.
- */
-#ifndef HvPMROOT
-#define MP_THX_INTERP_GET(thx)                                  \
-    (modperl_interp_t *) ((XPVMG*)SvANY(*Perl_Imodglobal_ptr(thx)))->xmg_magic
-#else
-#define MP_THX_INTERP_GET(thx) \
-    (modperl_interp_t *)HvPMROOT(*Perl_Imodglobal_ptr(thx))
-#endif
+modperl_interp_t *modperl_thx_interp_get(PerlInterpreter *thx);
+void modperl_thx_interp_set(PerlInterpreter *thx, modperl_interp_t *interp);
 
-#ifndef HvPMROOT
-#define MP_THX_INTERP_SET(thx, interp)                          \
-    ((XPVMG*)SvANY(*Perl_Imodglobal_ptr(thx)))->xmg_magic = (MAGIC*)interp
-#else
-#define MP_THX_INTERP_SET(thx, interp)                          \
-    HvPMROOT(*Perl_Imodglobal_ptr(thx)) = (PMOP*)interp
-#endif
-
 const char *modperl_interp_scope_desc(modperl_interp_scope_e scope);
 
 void modperl_interp_clone_init(modperl_interp_t *interp);
@@ -91,7 +67,7 @@
 
 apr_status_t modperl_interp_pool_destroy(void *data);
 
-typedef apr_status_t (*modperl_interp_mip_walker_t)(pTHX_ 
+typedef apr_status_t (*modperl_interp_mip_walker_t)(pTHX_
                                                     modperl_interp_pool_t *mip,
                                                     void *data);
 
Index: src/modules/perl/modperl_io_apache.c
===================================================================
--- src/modules/perl/modperl_io_apache.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_io_apache.c	(.../trunk)	(revision 630610)
@@ -98,7 +98,7 @@
 {
     /* XXX: we could return STDIN => 0, STDOUT => 1, but that wouldn't
      * be correct, as the IO goes through the socket, may be we should
-     * return the filedescriptor of the socket? 
+     * return the filedescriptor of the socket?
      *
      * -1 in this case indicates that the layer cannot provide fileno
      */
@@ -139,7 +139,7 @@
 
     rv = modperl_wbucket_write(aTHX_ rcfg->wbucket, vbuf, &count);
     if (rv != APR_SUCCESS) {
-        Perl_croak(aTHX_ modperl_error_strerror(aTHX_ rv)); 
+        Perl_croak(aTHX_ modperl_error_strerror(aTHX_ rv));
     }
     bytes += count;
 
@@ -224,7 +224,7 @@
     NULL,                       /* can't seek on STD{IN|OUT}, fail on call*/
     NULL,                       /* can't tell on STD{IN|OUT}, fail on call*/
     PerlIOApache_close,
-    PerlIOApache_flush,        
+    PerlIOApache_flush,
     PerlIOApache_noop_fail,     /* fill */
     PerlIOBase_eof,
     PerlIOBase_error,
@@ -274,7 +274,7 @@
 
         rc = ap_get_brigade(r->input_filters, bb, AP_MODE_READBYTES,
                             APR_BLOCK_READ, len);
-        if (rc != APR_SUCCESS) { 
+        if (rc != APR_SUCCESS) {
             /* if we fail here, we want to stop trying to read data
              * from the client.
              */
@@ -335,7 +335,3 @@
 
     return total;
 }
-
-
-
-
Index: src/modules/perl/modperl_gtop.c
===================================================================
--- src/modules/perl/modperl_gtop.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_gtop.c	(.../trunk)	(revision 630610)
@@ -31,7 +31,7 @@
     }
     else if (size < 1048576) {
         apr_snprintf(size_string, MP_GTOP_SSS, "%dk",
-                     (size + 512) / 1024);
+                     (int)(size + 512) / 1024);
     }
     else if (size < 103809024) {
         apr_snprintf(size_string, MP_GTOP_SSS, "%.1fM",
@@ -39,7 +39,7 @@
     }
     else {
         apr_snprintf(size_string, MP_GTOP_SSS, "%dM",
-                     (size + 524288) / 1048576);
+                     (int)(size + 524288) / 1048576);
     }
 
     return 1;
@@ -53,7 +53,7 @@
 
 modperl_gtop_t *modperl_gtop_new(apr_pool_t *p)
 {
-    modperl_gtop_t *gtop = 
+    modperl_gtop_t *gtop =
         (modperl_gtop_t *)apr_pcalloc(p, sizeof(*gtop));
 
     gtop->pid = getpid();
@@ -83,8 +83,8 @@
 #define SS_TYPE_AFTER  2
 #define SS_TYPE_DIFF   3
 
-/* 
- * XXX: this is pretty ugly, 
+/*
+ * XXX: this is pretty ugly,
  * but avoids allocating buffers for the size string
  */
 static void modperl_gtop_proc_mem_size_string(modperl_gtop_t *gtop, int type)
@@ -110,7 +110,7 @@
 #undef ss_call
 }
 
-void modperl_gtop_report_proc_mem(modperl_gtop_t *gtop, 
+void modperl_gtop_report_proc_mem(modperl_gtop_t *gtop,
                                   char *when, const char *func, char *msg)
 {
 #define ss_item(item) gtop->proc_mem_ss.item
Index: src/modules/perl/modperl_types.h
===================================================================
--- src/modules/perl/modperl_types.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_types.h	(.../trunk)	(revision 630610)
@@ -101,7 +101,6 @@
 struct modperl_interp_pool_t {
     server_rec *server;
     modperl_tipool_t *tipool;
-    modperl_tipool_config_t *tipool_cfg;
     modperl_interp_t *parent; /* from which to perl_clone() */
 };
 
@@ -193,10 +192,10 @@
      * - a subroutine name for named subs
      * - NULL for anon subs
      */
-    const char *name; 
+    const char *name;
     CV *cv;
     U8 flags;
-    U32 attrs;
+    U16 attrs;
     modperl_handler_t *next;
 };
 
Index: src/modules/perl/modperl_config.h
===================================================================
--- src/modules/perl/modperl_config.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_config.h	(.../trunk)	(revision 630610)
@@ -42,9 +42,15 @@
 
 apr_status_t modperl_config_req_cleanup(void *data);
 
+/* use a subpool here to ensure that a PerlCleanupHandler is run before
+ * any other pool cleanup - suppools are destroyed first. Particularly a
+ * PerlCleanupHandler must run before request pnotes are dropped.
+ */
 #define modperl_config_req_cleanup_register(r, rcfg)           \
     if (r && !MpReqCLEANUP_REGISTERED(rcfg)) {                 \
-        apr_pool_cleanup_register(r->pool,                     \
+        apr_pool_t *p;                           \
+        apr_pool_create(&p, r->pool);                   \
+        apr_pool_cleanup_register(p,                   \
                                   (void*)r,                    \
                                   modperl_config_req_cleanup,  \
                                   apr_pool_cleanup_null);      \
@@ -93,7 +99,7 @@
 
 #define MP_dCCFG \
     modperl_config_con_t *ccfg = modperl_config_con_get(c)
-    
+
 #define modperl_config_dir_get(r)                               \
     (r ? (modperl_config_dir_t *)                               \
      modperl_get_module_config(r->per_dir_config) : NULL)
@@ -151,7 +157,7 @@
                                   ap_conf_vector_t *conf,
                                   SV *lines);
 
-const char *modperl_config_insert_parms(pTHX_ cmd_parms *parms, 
+const char *modperl_config_insert_parms(pTHX_ cmd_parms *parms,
                                         SV *lines);
 
 const char *modperl_config_insert_server(pTHX_ server_rec *s, SV *lines);
Index: src/modules/perl/modperl_bucket.c
===================================================================
--- src/modules/perl/modperl_bucket.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_bucket.c	(.../trunk)	(revision 630610)
@@ -53,12 +53,12 @@
     dTHXa(svbucket->perl);
 
     if (!apr_bucket_shared_destroy(svbucket)) {
-        MP_TRACE_f(MP_FUNC, "bucket refcnt=%d\n",
+        MP_TRACE_f(MP_FUNC, "bucket refcnt=%d",
                    ((apr_bucket_refcount *)svbucket)->refcount);
         return;
     }
 
-    MP_TRACE_f(MP_FUNC, "sv=0x%lx, refcnt=%d\n",
+    MP_TRACE_f(MP_FUNC, "sv=0x%lx, refcnt=%d",
                (unsigned long)svbucket->sv, SvREFCNT(svbucket->sv));
 
     SvREFCNT_dec(svbucket->sv);
@@ -66,7 +66,7 @@
     apr_bucket_free(svbucket);
 }
 
-static 
+static
 apr_status_t modperl_bucket_sv_setaside(apr_bucket *bucket, apr_pool_t *pool)
 {
     modperl_bucket_sv_t *svbucket = bucket->data;
@@ -111,7 +111,7 @@
                                           apr_off_t offset,
                                           apr_size_t len)
 {
-    modperl_bucket_sv_t *svbucket; 
+    modperl_bucket_sv_t *svbucket;
 
     svbucket = apr_bucket_alloc(sizeof(*svbucket), bucket->list);
 
@@ -139,14 +139,14 @@
         (void)SvREFCNT_inc(svbucket->sv);
     }
 
-    MP_TRACE_f(MP_FUNC, "sv=0x%lx, refcnt=%d\n",
+    MP_TRACE_f(MP_FUNC, "sv=0x%lx, refcnt=%d",
                (unsigned long)svbucket->sv, SvREFCNT(svbucket->sv));
 
     bucket->type = &modperl_bucket_sv_type;
     return bucket;
 }
 
-apr_bucket *modperl_bucket_sv_create(pTHX_ apr_bucket_alloc_t *list, SV *sv, 
+apr_bucket *modperl_bucket_sv_create(pTHX_ apr_bucket_alloc_t *list, SV *sv,
                                      apr_off_t offset, apr_size_t len)
 {
     apr_bucket *bucket;
Index: src/modules/perl/modperl_util.c
===================================================================
--- src/modules/perl/modperl_util.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_util.c	(.../trunk)	(revision 630610)
@@ -194,7 +194,7 @@
 {
     SV *sv = newSV(0);
 
-    MP_TRACE_h(MP_FUNC, "sv_setref_pv(%s, 0x%lx)\n",
+    MP_TRACE_h(MP_FUNC, "sv_setref_pv(%s, 0x%lx)",
                classname, (unsigned long)ptr);
     sv_setref_pv(sv, classname, ptr);
 
@@ -265,10 +265,10 @@
     void **handles;
 
     if (!librefs) {
-	MP_TRACE_r(MP_FUNC,
-                   "Could not get @%s for unloading.\n",
+        MP_TRACE_r(MP_FUNC,
+                   "Could not get @%s for unloading.",
                    dl_librefs);
-	return NULL;
+        return NULL;
     }
 
     if (!(AvFILL(librefs) >= 0)) {
@@ -279,23 +279,23 @@
     handles = (void **)malloc(sizeof(void *) * (AvFILL(librefs)+2));
 
     for (i=0; i<=AvFILL(librefs); i++) {
-	void *handle;
-	SV *handle_sv = *av_fetch(librefs, i, FALSE);
-	SV *module_sv = *av_fetch(modules, i, FALSE);
+        void *handle;
+        SV *handle_sv = *av_fetch(librefs, i, FALSE);
+        SV *module_sv = *av_fetch(modules, i, FALSE);
 
-	if(!handle_sv) {
-	    MP_TRACE_r(MP_FUNC,
-                       "Could not fetch $%s[%d]!\n",
+        if(!handle_sv) {
+            MP_TRACE_r(MP_FUNC,
+                       "Could not fetch $%s[%d]!",
                        dl_librefs, (int)i);
-	    continue;
-	}
-	handle = INT2PTR(void *, SvIV(handle_sv));
+            continue;
+        }
+        handle = INT2PTR(void *, SvIV(handle_sv));
 
-	MP_TRACE_r(MP_FUNC, "%s dl handle == 0x%lx\n",
+        MP_TRACE_r(MP_FUNC, "%s dl handle == 0x%lx",
                    SvPVX(module_sv), (unsigned long)handle);
-	if (handle) {
-	    handles[i] = handle;
-	}
+        if (handle) {
+            handles[i] = handle;
+        }
     }
 
     av_clear(modules);
@@ -311,11 +311,11 @@
     int i;
 
     if (!handles) {
-	return;
+        return;
     }
 
     for (i=0; handles[i]; i++) {
-        MP_TRACE_r(MP_FUNC, "close 0x%lx\n", (unsigned long)handles[i]);
+        MP_TRACE_r(MP_FUNC, "close 0x%lx", (unsigned long)handles[i]);
         modperl_sys_dlclose(handles[i]);
     }
 
@@ -344,7 +344,7 @@
     sv_free((SV *)tmpav);
 }
 
-static void modperl_package_unload_dynamic(pTHX_ const char *package, 
+static void modperl_package_unload_dynamic(pTHX_ const char *package,
                                            I32 dl_index)
 {
     AV *librefs = get_av(dl_librefs, 0);
@@ -356,7 +356,7 @@
     modperl_av_remove_entry(aTHX_ get_av(dl_librefs, 0), dl_index);
     modperl_av_remove_entry(aTHX_ get_av(dl_modules, 0), dl_index);
 
-    return;    
+    return;
 }
 
 static int modperl_package_is_dynamic(pTHX_ const char *package,
@@ -415,12 +415,12 @@
 
 #ifdef HvREHASH
     if (HvREHASH(hv)) {
-	PERL_HASH_INTERNAL(hash, key, klen);
+        PERL_HASH_INTERNAL(hash, key, klen);
     }
     else
 #endif
     if (!hash) {
-	PERL_HASH(hash, key, klen);
+        PERL_HASH(hash, key, klen);
     }
 
     entry = ((HE**)HvARRAY(hv))[hash & (I32)xhv->xhv_max];
@@ -449,7 +449,7 @@
     }
 }
 
-/* XXX: same as Perl_do_sprintf(); 
+/* XXX: same as Perl_do_sprintf();
  * but Perl_do_sprintf() is not part of the "public" api
  */
 void modperl_perl_do_sprintf(pTHX_ SV *sv, I32 len, SV **sarg)
@@ -476,20 +476,20 @@
                AvFILLp(subs)+1, name);
 
     for (i=0; i<=AvFILLp(subs); i++) {
-	CV *cv = (CV*)ary[i];
-	SV *atsv = ERRSV;
+        CV *cv = (CV*)ary[i];
+        SV *atsv = ERRSV;
 
-	PUSHMARK(PL_stack_sp);
-	call_sv((SV*)cv, G_EVAL|G_DISCARD);
+        PUSHMARK(PL_stack_sp);
+        call_sv((SV*)cv, G_EVAL|G_DISCARD);
 
-	if (SvCUR(atsv)) {
+        if (SvCUR(atsv)) {
             Perl_sv_catpvf(aTHX_ atsv, "%s failed--call queue aborted",
                            name);
-	    while (PL_scopestack_ix > oldscope) {
-		LEAVE;
+            while (PL_scopestack_ix > oldscope) {
+                LEAVE;
             }
             Perl_croak(aTHX_ "%s", SvPVX(atsv));
-	}
+        }
     }
 }
 
@@ -497,7 +497,7 @@
 {
     ENTER;
     SAVESPTR(PL_diehook);
-    PL_diehook = Nullsv; 
+    PL_diehook = Nullsv;
     modperl_croak(aTHX_ MODPERL_RC_EXIT, "ModPerl::Util::exit");
 }
 
@@ -506,7 +506,7 @@
 {
     SV *retval = &PL_sv_undef;
 
-    if (r && r->per_dir_config) {				   
+    if (r && r->per_dir_config) {
         MP_dDCFG;
         retval = modperl_table_get_set(aTHX_ dcfg->configvars,
                                        key, sv_val, FALSE);
@@ -532,31 +532,31 @@
 {
     SV *retval = &PL_sv_undef;
 
-    if (table == NULL) { 
+    if (table == NULL) {
         /* do nothing */
     }
-    else if (key == NULL) { 
+    else if (key == NULL) {
         retval = modperl_hash_tie(aTHX_ "APR::Table",
-                                  Nullsv, (void*)table); 
+                                  Nullsv, (void*)table);
     }
     else if (!sv_val) { /* no val was passed */
-        char *val; 
-        if ((val = (char *)apr_table_get(table, key))) { 
-            retval = newSVpv(val, 0); 
-        } 
-        else { 
-            retval = newSV(0); 
-        } 
-        if (do_taint) { 
-            SvTAINTED_on(retval); 
-        } 
+        char *val;
+        if ((val = (char *)apr_table_get(table, key))) {
+            retval = newSVpv(val, 0);
+        }
+        else {
+            retval = newSV(0);
+        }
+        if (do_taint) {
+            SvTAINTED_on(retval);
+        }
     }
     else if (!SvOK(sv_val)) { /* val was passed in as undef */
-        apr_table_unset(table, key); 
+        apr_table_unset(table, key);
     }
-    else { 
+    else {
         apr_table_set(table, key, SvPV_nolen(sv_val));
-    } 
+    }
 
     return retval;
 }
@@ -629,10 +629,10 @@
     rc = apr_file_read(file, SvPVX(sv), &size);
     SLURP_SUCCESS("reading");
 
-    MP_TRACE_o(MP_FUNC, "read %d bytes from '%s'\n", size, r->filename);
+    MP_TRACE_o(MP_FUNC, "read %d bytes from '%s'", size, r->filename);
 
     if (r->finfo.size != size) {
-        SvREFCNT_dec(sv); 
+        SvREFCNT_dec(sv);
         Perl_croak(aTHX_ "Error: read %d bytes, expected %d ('%s')",
                    size, (apr_size_t)r->finfo.size, r->filename);
     }
@@ -706,10 +706,10 @@
 
 SV *modperl_apr_array_header2avrv(pTHX_ apr_array_header_t *array)
 {
-    AV *av = newAV(); 
+    AV *av = newAV();
 
     if (array) {
-        int i; 
+        int i;
         for (i = 0; i < array->nelts; i++) {
             av_push(av, newSVpv(((char **)array->elts)[i], 0));
         }
@@ -742,7 +742,7 @@
 }
 
 /* Remove a package from %INC */
-static void modperl_package_delete_from_inc(pTHX_ const char *package)  
+static void modperl_package_delete_from_inc(pTHX_ const char *package)
 {
     int len;
     char *filename = package2filename(package, &len);
@@ -753,7 +753,7 @@
 /* Destroy a package's stash */
 #define MP_STASH_SUBSTASH(key, len) ((len >= 2) &&                  \
                                      (key[len-1] == ':') &&         \
-                                     (key[len-2] == ':'))   
+                                     (key[len-2] == ':'))
 #define MP_STASH_DEBUGGER(key, len) ((len >= 2) &&                  \
                                      (key[0] == '_') &&             \
                                      (key[1] == '<'))
@@ -819,7 +819,7 @@
         *counter = 1;
         apr_pool_userdata_set(counter, MP_RESTART_COUNT_KEY,
                               apr_pool_cleanup_null, p);
-    }    
+    }
 }
 
 int modperl_restart_count(void)
@@ -853,36 +853,35 @@
         *pnotes = Nullhv;
     }
 
-    return APR_SUCCESS;   
+    return APR_SUCCESS;
 }
 
-SV *modperl_pnotes(pTHX_ HV **pnotes, SV *key, SV *val, 
+MP_INLINE
+static void *modperl_pnotes_cleanup_data(pTHX_ HV **pnotes, apr_pool_t *p) {
+#ifdef USE_ITHREADS
+    modperl_cleanup_pnotes_data_t *cleanup_data = apr_palloc(p, sizeof(*cleanup_data));
+    cleanup_data->pnotes = pnotes;
+    cleanup_data->perl = aTHX;
+    return cleanup_data;
+#else
+    return pnotes;
+#endif
+}
+
+SV *modperl_pnotes(pTHX_ HV **pnotes, SV *key, SV *val,
                    request_rec *r, conn_rec *c) {
     SV *retval = Nullsv;
 
     if (!*pnotes) {
+        apr_pool_t *pool = r ? r->pool : c->pool;
+        void *cleanup_data;
         *pnotes = newHV();
 
-        /* XXX: It would be nice to be able to do this with r->pnotes, but
-         * it's currently impossible, as modperl_config.c:modperl_config_request_cleanup()
-         * is responsible for running the CleanupHandlers, and it's cleanup callback is
-         * registered very early. If we register our cleanup here, we'll be running 
-         * *before* the CleanupHandlers, and they might still want to use pnotes...
-         */
-        if (c && !r) {
-            apr_pool_t *pool = r ? r->pool : c->pool;
-#ifdef USE_ITHREADS
-            modperl_cleanup_pnotes_data_t *cleanup_data = 
-                apr_palloc(pool, sizeof(*cleanup_data));
-            cleanup_data->pnotes = pnotes;
-            cleanup_data->perl = aTHX;
-#else
-            void *cleanup_data = pnotes;
-#endif
-            apr_pool_cleanup_register(pool, cleanup_data,
-                                      modperl_cleanup_pnotes,
-                                      apr_pool_cleanup_null);
-        }
+        cleanup_data = modperl_pnotes_cleanup_data(aTHX_ pnotes, pool);
+
+        apr_pool_cleanup_register(pool, cleanup_data,
+                                  modperl_cleanup_pnotes,
+                                  apr_pool_cleanup_null);
     }
 
     if (key) {
@@ -895,11 +894,19 @@
         else if (hv_exists(*pnotes, k, len)) {
             retval = *hv_fetch(*pnotes, k, len, FALSE);
         }
+
+        return retval ? SvREFCNT_inc(retval) : &PL_sv_undef;
     }
-    else {
-        retval = newRV_inc((SV *)*pnotes);
+    return newRV_inc((SV *)*pnotes);
+}
+
+U16 *modperl_code_attrs(pTHX_ CV *cv) {
+    MAGIC *mg;    
+
+    if (!SvMAGICAL(cv)) {
+       sv_magic((SV*)cv, Nullsv, PERL_MAGIC_ext, NULL, -1); 
     }
 
-    return retval ? SvREFCNT_inc(retval) : &PL_sv_undef;
+    mg = mg_find((SV*)cv, PERL_MAGIC_ext);
+    return &(mg->mg_private);
 }
- 
Index: src/modules/perl/modperl_gtop.h
===================================================================
--- src/modules/perl/modperl_gtop.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_gtop.h	(.../trunk)	(revision 630610)
@@ -43,7 +43,7 @@
     char share[MP_GTOP_SSS];
     char rss[MP_GTOP_SSS];
 } modperl_gtop_proc_mem_ss;
-    
+
 typedef struct {
     glibtop_union before;
     glibtop_union after;
@@ -54,7 +54,7 @@
 modperl_gtop_t *modperl_gtop_new(apr_pool_t *p);
 void modperl_gtop_get_proc_mem_before(modperl_gtop_t *gtop);
 void modperl_gtop_get_proc_mem_after(modperl_gtop_t *gtop);
-void modperl_gtop_report_proc_mem(modperl_gtop_t *gtop, 
+void modperl_gtop_report_proc_mem(modperl_gtop_t *gtop,
                                   char *when, const char *func, char *msg);
 void modperl_gtop_report_proc_mem_diff(modperl_gtop_t *gtop, const char* func, char *msg);
 void modperl_gtop_report_proc_mem_before(modperl_gtop_t *gtop, const char* func, char *msg);
Index: src/modules/perl/modperl_bucket.h
===================================================================
--- src/modules/perl/modperl_bucket.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_bucket.h	(.../trunk)	(revision 630610)
@@ -17,7 +17,7 @@
 #ifndef MODPERL_BUCKET_H
 #define MODPERL_BUCKET_H
 
-apr_bucket *modperl_bucket_sv_create(pTHX_ apr_bucket_alloc_t *list, SV *sv, 
+apr_bucket *modperl_bucket_sv_create(pTHX_ apr_bucket_alloc_t *list, SV *sv,
                                      apr_off_t offset, apr_size_t len);
 
 #endif /* MODPERL_BUCKET_H */
Index: src/modules/perl/modperl_util.h
===================================================================
--- src/modules/perl/modperl_util.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_util.h	(.../trunk)	(revision 630610)
@@ -27,7 +27,7 @@
     }
 
 /* turn off cgi header parsing. in case we are already inside
- *     modperl_callback_per_dir(MP_RESPONSE_HANDLER, r, MP_HOOK_RUN_FIRST); 
+ *     modperl_callback_per_dir(MP_RESPONSE_HANDLER, r, MP_HOOK_RUN_FIRST);
  * but haven't sent any data yet, it's too late to change
  * MpReqPARSE_HEADERS, so change the wbucket's private flag directly
  */
@@ -35,7 +35,7 @@
     MpReqPARSE_HEADERS_Off(rcfg); \
     if (rcfg->wbucket) { \
         rcfg->wbucket->header_parse = 0; \
-    } 
+    }
 
 MP_INLINE server_rec *modperl_sv2server_rec(pTHX_ SV *sv);
 MP_INLINE request_rec *modperl_sv2request_rec(pTHX_ SV *sv);
@@ -81,7 +81,7 @@
 
 MP_INLINE SV *modperl_dir_config(pTHX_ request_rec *r, server_rec *s,
                                  char *key, SV *sv_val);
-    
+
 SV *modperl_table_get_set(pTHX_ apr_table_t *table, char *key,
                           SV *sv_val, int do_taint);
 
@@ -149,4 +149,6 @@
 SV *modperl_pnotes(pTHX_ HV **pnotes, SV *key, SV *val,
                    request_rec *r, conn_rec *c);
 
+U16 *modperl_code_attrs(pTHX_ CV *cv);
+
 #endif /* MODPERL_UTIL_H */
Index: src/modules/perl/modperl_env.c
===================================================================
--- src/modules/perl/modperl_env.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_env.c	(.../trunk)	(revision 630610)
@@ -130,7 +130,7 @@
             continue;
         }
         MP_ENV_HV_STORE_TABLE_ENTRY(hv, elts[i]);
-    }    
+    }
 
     modperl_env_tie(mg_flags);
 }
@@ -167,10 +167,10 @@
     apr_table_entry_t *elts;
     HV *hv = ENVHV;
     SV **svp;
-    
+
     array = apr_table_elts(table);
     elts  = (apr_table_entry_t *)array->elts;
-    
+
     for (i = 0; i < array->nelts; i++) {
         if (!elts[i].key) {
             continue;
@@ -181,7 +181,7 @@
             MP_TRACE_e(MP_FUNC, "(Set|Pass)Env '%s' '%s'", elts[i].key,
                        SvPV_nolen(*svp));
         }
-    }    
+    }
     TAINT_NOT; /* SvPV_* causes the taint issue */
 }
 
@@ -232,13 +232,13 @@
         }
     }
 
-    MP_TRACE_e(MP_FUNC, "\n\t[%s/0x%lx/%s]"
+    MP_TRACE_e(MP_FUNC, "\t[%s/0x%lx/%s]"
                "\n\t@ENV{keys scfg->SetEnv} = values scfg->SetEnv;",
                modperl_pid_tid(p), modperl_interp_address(aTHX),
                modperl_server_desc(s, p));
     modperl_env_table_populate(aTHX_ scfg->SetEnv);
 
-    MP_TRACE_e(MP_FUNC, "\n\t[%s/0x%lx/%s]"
+    MP_TRACE_e(MP_FUNC, "\t[%s/0x%lx/%s]"
                "\n\t@ENV{keys scfg->PassEnv} = values scfg->PassEnv;",
                modperl_pid_tid(p), modperl_interp_address(aTHX),
                modperl_server_desc(s, p));
@@ -255,7 +255,7 @@
     MP_dRCFG;
     MP_dDCFG;
 
-    /* populate %ENV and r->subprocess_env with per-directory 
+    /* populate %ENV and r->subprocess_env with per-directory
      * PerlSetEnv entries.
      *
      * note that per-server PerlSetEnv entries, as well as
@@ -267,10 +267,10 @@
         apr_table_t *setenv_copy;
 
         /* add per-directory PerlSetEnv entries to %ENV
-         * collisions with per-server PerlSetEnv entries are 
+         * collisions with per-server PerlSetEnv entries are
          * resolved via the nature of a Perl hash
          */
-        MP_TRACE_e(MP_FUNC, "\n\t[%s/0x%lx/%s]"
+        MP_TRACE_e(MP_FUNC, "\t[%s/0x%lx/%s]"
                    "\n\t@ENV{keys dcfg->SetEnv} = values dcfg->SetEnv;",
                    modperl_pid_tid(r->pool), modperl_interp_address(aTHX),
                    modperl_server_desc(r->server, r->pool));
@@ -295,15 +295,15 @@
     MP_dRCFG;
     MP_dSCFG(r->server);
 
-    /* populate %ENV and r->subprocess_env with per-server PerlSetEnv 
-     * and PerlPassEnv entries.  
+    /* populate %ENV and r->subprocess_env with per-server PerlSetEnv
+     * and PerlPassEnv entries.
      *
      * although both are setup in %ENV in modperl_request_configure_server
      * %ENV will be reset via modperl_env_request_unpopulate.
      */
 
     if (!apr_is_empty_table(scfg->SetEnv)) {
-        MP_TRACE_e(MP_FUNC, "\n\t[%s/0x%lx/%s]"
+        MP_TRACE_e(MP_FUNC, "\t[%s/0x%lx/%s]"
                    "\n\t@ENV{keys scfg->SetEnv} = values scfg->SetEnv;",
                    modperl_pid_tid(r->pool), modperl_interp_address(aTHX),
                    modperl_server_desc(r->server, r->pool));
@@ -313,7 +313,7 @@
     }
 
     if (!apr_is_empty_table(scfg->PassEnv)) {
-        MP_TRACE_e(MP_FUNC, "\n\t[%s/0x%lx/%s]"
+        MP_TRACE_e(MP_FUNC, "\t[%s/0x%lx/%s]"
                    "\n\t@ENV{keys scfg->PassEnv} = values scfg->PassEnv;",
                    modperl_pid_tid(r->pool), modperl_interp_address(aTHX),
                    modperl_server_desc(r->server, r->pool));
@@ -356,14 +356,14 @@
      * normally, %ENV is only populated once per request (if at all) -
      * just prior to content generation if +SetupEnv.
      *
-     * however, in the $r->subprocess_env() case it will be called 
+     * however, in the $r->subprocess_env() case it will be called
      * more than once - once for each void call, and once again just
      * prior to content generation.  while costly, the multiple
      * passes are required, otherwise void calls would prohibit later
      * phases from populating %ENV with new subprocess_env table entries
      */
 
-    MP_TRACE_e(MP_FUNC, "\n\t[%s/0x%lx/%s%s]"
+    MP_TRACE_e(MP_FUNC, "\t[%s/0x%lx/%s%s]"
                "\n\t@ENV{keys r->subprocess_env} = values r->subprocess_env;",
                modperl_pid_tid(r->pool), modperl_interp_address(aTHX),
                modperl_server_desc(r->server, r->pool), r->uri);
@@ -382,7 +382,7 @@
 
     /* don't set up CGI variables again this request.
      * this also triggers modperl_env_request_unpopulate, which
-     * resets %ENV between requests - see modperl_config_request_cleanup 
+     * resets %ENV between requests - see modperl_config_request_cleanup
      */
     MpReqSETUP_ENV_On(rcfg);
 }
@@ -411,7 +411,7 @@
     EnvMgLenSet(-1);
 
 #ifdef MP_PERL_HV_GMAGICAL_AWARE
-    MP_TRACE_e(MP_FUNC, "[%s/0x%lx] tie %%ENV, $r\n\t (%s%s)",
+    MP_TRACE_e(MP_FUNC, "[%s/0x%lx] tie %%ENV, $r\t (%s%s)",
                modperl_pid_tid(r->pool), modperl_interp_address(aTHX),
                modperl_server_desc(r->server, r->pool), r->uri);
     SvGMAGICAL_on((SV*)ENVHV);
@@ -423,7 +423,7 @@
     EnvMgObjSet(NULL);
 
 #ifdef MP_PERL_HV_GMAGICAL_AWARE
-    MP_TRACE_e(MP_FUNC, "[%s/0x%lx] untie %%ENV; # from r\n\t (%s%s)",
+    MP_TRACE_e(MP_FUNC, "[%s/0x%lx] untie %%ENV; # from r\t (%s%s)",
                modperl_pid_tid(r->pool), modperl_interp_address(aTHX),
                modperl_server_desc(r->server, r->pool), r->uri);
     SvGMAGICAL_off((SV*)ENVHV);
Index: src/modules/perl/modperl_global.c
===================================================================
--- src/modules/perl/modperl_global.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_global.c	(.../trunk)	(revision 630610)
@@ -77,7 +77,7 @@
 {
     modperl_global_t *global = (modperl_global_t *)data;
 
-    MP_TRACE_g(MP_FUNC, "destroy lock for %s\n", global->name);
+    MP_TRACE_g(MP_FUNC, "destroy lock for %s", global->name);
     MUTEX_DESTROY(&global->glock);
 
     return APR_SUCCESS;
@@ -100,13 +100,13 @@
                               apr_pool_cleanup_null);
 #endif
 
-    MP_TRACE_g(MP_FUNC, "init %s\n", name);
+    MP_TRACE_g(MP_FUNC, "init %s", name);
 }
 
 void modperl_global_lock(modperl_global_t *global)
 {
 #if MP_THREADED
-    MP_TRACE_g(MP_FUNC, "locking %s\n", global->name);
+    MP_TRACE_g(MP_FUNC, "locking %s", global->name);
     MUTEX_LOCK(&global->glock);
 #endif
 }
@@ -114,7 +114,7 @@
 void modperl_global_unlock(modperl_global_t *global)
 {
 #if MP_THREADED
-    MP_TRACE_g(MP_FUNC, "unlocking %s\n", global->name);
+    MP_TRACE_g(MP_FUNC, "unlocking %s", global->name);
     MUTEX_UNLOCK(&global->glock);
 #endif
 }
@@ -185,11 +185,11 @@
 {
     int next;
     /* XXX: inline lock/unlock? */
-    modperl_global_lock(&MP_global_anon_cnt); 
+    modperl_global_lock(&MP_global_anon_cnt);
 
     next = ++*(int *)(MP_global_anon_cnt.data);
 
-    modperl_global_unlock(&MP_global_anon_cnt); 
+    modperl_global_unlock(&MP_global_anon_cnt);
 
     return next;
 }
@@ -250,7 +250,7 @@
 
 static apr_status_t modperl_tls_reset(void *data)
 {
-    modperl_tls_cleanup_data_t *cdata = 
+    modperl_tls_cleanup_data_t *cdata =
         (modperl_tls_cleanup_data_t *)data;
     return modperl_tls_set(cdata->key, cdata->data);
 }
Index: src/modules/perl/modperl_cgi.c
===================================================================
--- src/modules/perl/modperl_cgi.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_cgi.c	(.../trunk)	(revision 630610)
@@ -75,7 +75,7 @@
         r->method_number = M_GET;
 
         /* We already read the message body (if any), so don't allow
-         * the redirected request to think it has one.  We can ignore 
+         * the redirected request to think it has one.  We can ignore
          * Transfer-Encoding, since we used REQUEST_CHUNKED_ERROR.
          */
         apr_table_unset(r->headers_in, "Content-Length");
Index: src/modules/perl/modperl_cmd.c
===================================================================
--- src/modules/perl/modperl_cmd.c	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_cmd.c	(.../trunk)	(revision 630610)
@@ -47,13 +47,13 @@
 
     if (!*handlers) {
         *handlers = modperl_handler_array_new(p);
-        MP_TRACE_d(MP_FUNC, "created handler stack\n");
+        MP_TRACE_d(MP_FUNC, "created handler stack");
     }
 
     /* XXX parse_handler if Perl is running */
 
     modperl_handler_array_push(*handlers, h);
-    MP_TRACE_d(MP_FUNC, "pushed handler: %s\n", h->name);
+    MP_TRACE_d(MP_FUNC, "pushed handler: %s", h->name);
 
     return NULL;
 }
@@ -84,11 +84,11 @@
 
     if (!*handlers) {
         *handlers = modperl_handler_array_new(p);
-        MP_TRACE_d(MP_FUNC, "created handler stack\n");
+        MP_TRACE_d(MP_FUNC, "created handler stack");
     }
 
     modperl_handler_array_push(*handlers, h);
-    MP_TRACE_d(MP_FUNC, "pushed httpd filter handler: %s\n", h->name);
+    MP_TRACE_d(MP_FUNC, "pushed httpd filter handler: %s", h->name);
 
     return NULL;
 }
@@ -107,18 +107,18 @@
 
     if (!*handlers) {
         *handlers = modperl_handler_array_new(p);
-        MP_TRACE_d(MP_FUNC, "created handler stack\n");
+        MP_TRACE_d(MP_FUNC, "created handler stack");
     }
 
     modperl_handler_array_push(*handlers, h);
-    MP_TRACE_d(MP_FUNC, "pushed httpd filter handler: %s\n", h->name);
+    MP_TRACE_d(MP_FUNC, "pushed httpd filter handler: %s", h->name);
 
     return NULL;
 }
 
 
 #define MP_CMD_SRV_TRACE \
-    MP_TRACE_d(MP_FUNC, "%s %s\n", parms->cmd->name, arg)
+    MP_TRACE_d(MP_FUNC, "%s %s", parms->cmd->name, arg)
 
 #define MP_CMD_SRV_CHECK \
 MP_CMD_SRV_TRACE; \
@@ -156,7 +156,7 @@
     if (modperl_vhost_is_running(s)) {
         return modperl_cmd_too_late(parms);
     }
-    MP_TRACE_d(MP_FUNC, "arg = %s\n", arg);
+    MP_TRACE_d(MP_FUNC, "arg = %s", arg);
 
     if (!strncasecmp(arg, "+inherit", 8)) {
         modperl_cmd_options(parms, mconfig, "+InheritSwitches");
@@ -184,7 +184,7 @@
     if (modperl_is_running()) {
         char *error = NULL;
 
-        MP_TRACE_d(MP_FUNC, "load PerlModule %s\n", arg);
+        MP_TRACE_d(MP_FUNC, "load PerlModule %s", arg);
 
         MP_PERL_CONTEXT_STORE_OVERRIDE(scfg->mip->parent->perl);
         if (!modperl_require_module(aTHX_ arg, FALSE)) {
@@ -199,7 +199,7 @@
         return error;
     }
     else {
-        MP_TRACE_d(MP_FUNC, "push PerlModule %s\n", arg);
+        MP_TRACE_d(MP_FUNC, "push PerlModule %s", arg);
         *(const char **)apr_array_push(scfg->PerlModule) = arg;
         return NULL;
     }
@@ -222,7 +222,7 @@
     if (modperl_is_running()) {
         char *error = NULL;
 
-        MP_TRACE_d(MP_FUNC, "load PerlRequire %s\n", arg);
+        MP_TRACE_d(MP_FUNC, "load PerlRequire %s", arg);
 
         MP_PERL_CONTEXT_STORE_OVERRIDE(scfg->mip->parent->perl);
         if (!modperl_require_file(aTHX_ arg, FALSE)) {
@@ -237,14 +237,14 @@
         return error;
     }
     else {
-        MP_TRACE_d(MP_FUNC, "push PerlRequire %s\n", arg);
+        MP_TRACE_d(MP_FUNC, "push PerlRequire %s", arg);
         *(const char **)apr_array_push(scfg->PerlRequire) = arg;
         return NULL;
     }
 }
 
 MP_CMD_SRV_DECLARE(config_requires)
-{    
+{
     /* we must init earlier than normal */
     modperl_run();
 
@@ -261,7 +261,7 @@
     MP_dSCFG(parms->server);
 
     modperl_require_file_t *require = apr_pcalloc(p, sizeof(*require));
-    MP_TRACE_d(MP_FUNC, "push PerlPostConfigRequire for %s\n", arg);
+    MP_TRACE_d(MP_FUNC, "push PerlPostConfigRequire for %s", arg);
     require->file = arg;
     require->dcfg = dcfg;
 
@@ -295,7 +295,7 @@
 {
     varfunc(dcfg->configvars, dcfg->setvars, arg1, arg2);
 
-    MP_TRACE_d(MP_FUNC, "%s DIR: arg1 = %s, arg2 = %s\n",
+    MP_TRACE_d(MP_FUNC, "%s DIR: arg1 = %s, arg2 = %s",
                parms->cmd->name, arg1, arg2);
 
     /* make available via Apache2->server->dir_config */
@@ -303,7 +303,7 @@
         MP_dSCFG(parms->server);
         varfunc(scfg->configvars, scfg->setvars, arg1, arg2);
 
-        MP_TRACE_d(MP_FUNC, "%s SRV: arg1 = %s, arg2 = %s\n",
+        MP_TRACE_d(MP_FUNC, "%s SRV: arg1 = %s, arg2 = %s",
                    parms->cmd->name, arg1, arg2);
     }
 
@@ -335,7 +335,7 @@
     modperl_str_toupper((char *)arg1);
 #endif
 
-    MP_TRACE_d(MP_FUNC, "arg1 = %s, arg2 = %s\n", arg1, arg2);
+    MP_TRACE_d(MP_FUNC, "arg1 = %s, arg2 = %s", arg1, arg2);
 
     if (!parms->path) {
         /* will be propagated to environ */
@@ -375,10 +375,10 @@
             modperl_env_hv_store(aTHX_ arg, val);
             MP_PERL_CONTEXT_RESTORE;
         }
-        MP_TRACE_d(MP_FUNC, "arg = %s, val = %s\n", arg, val);
+        MP_TRACE_d(MP_FUNC, "arg = %s, val = %s", arg, val);
     }
     else {
-        MP_TRACE_d(MP_FUNC, "arg = %s: not found via getenv()\n", arg);
+        MP_TRACE_d(MP_FUNC, "arg = %s: not found via getenv()", arg);
     }
 
     return NULL;
@@ -393,7 +393,7 @@
     apr_pool_t *p = parms->temp_pool;
     const char *error;
 
-    MP_TRACE_d(MP_FUNC, "arg = %s\n", arg);
+    MP_TRACE_d(MP_FUNC, "arg = %s", arg);
     if ((error = modperl_options_set(p, opts, arg)) && !is_per_dir) {
         /* maybe a per-directory option outside of a container */
         if (modperl_options_set(p, dcfg->flags, arg) == NULL) {
@@ -542,14 +542,14 @@
 
         pkg_namespace = modperl_file2package(p, directive->filename);
 
-        pkg_name = apr_psprintf(p, "%s::%s::line_%d", 
-                                    pkg_base, 
-                                    pkg_namespace, 
+        pkg_name = apr_psprintf(p, "%s::%s::line_%d",
+                                    pkg_base,
+                                    pkg_namespace,
                                     directive->line_num);
 
         apr_table_set(options, "package", pkg_name);
 
-        line_header = apr_psprintf(p, "\n#line %d %s\n", 
+        line_header = apr_psprintf(p, "\n#line %d %s\n",
                                    directive->line_num,
                                    directive->filename);
 
@@ -564,7 +564,7 @@
         GV *gv = gv_fetchpv("0", TRUE, SVt_PV);
         ENTER;SAVETMPS;
         save_scalar(gv); /* local $0 */
-#if PERL_REVISION == 5 && PERL_VERSION >= 9
+#if MP_PERL_VERSION_AT_LEAST(5, 9, 0)
         TAINT_NOT; /* XXX: temp workaround, see my p5p post */
 #endif
         sv_setref_pv(server, "Apache2::ServerRec", (void*)s);
@@ -619,7 +619,7 @@
 {
     char line[MAX_STRING_LEN];
 
-    if (arg && *arg && !(MP_POD_FORMAT(arg) || strstr("pod", arg))) {  
+    if (arg && *arg && !(MP_POD_FORMAT(arg) || strstr("pod", arg))) {
         return "Unknown =back format";
     }
 
@@ -660,7 +660,7 @@
 {
     const char *errmsg;
 
-    MP_TRACE_d(MP_FUNC, "PerlLoadModule %s\n", arg);
+    MP_TRACE_d(MP_FUNC, "PerlLoadModule %s", arg);
 
     /* we must init earlier than normal */
     modperl_run();
@@ -822,7 +822,7 @@
     MP_dSCFG(parms->server); \
     int item = atoi(arg); \
     scfg->interp_pool_cfg->xitem = item; \
-    MP_TRACE_d(MP_FUNC, "%s %d\n", parms->cmd->name, item); \
+    MP_TRACE_d(MP_FUNC, "%s %d", parms->cmd->name, item); \
     return NULL; \
 }
 
Index: src/modules/perl/modperl_time.h
===================================================================
--- src/modules/perl/modperl_time.h	(.../tags/2_0_3)	(revision 630610)
+++ src/modules/perl/modperl_time.h	(.../trunk)	(revision 630610)
@@ -44,7 +44,7 @@
         double stime = \
              (double)(end_time.tms_stime - start_time.tms_stime)/MP_HZ; \
         if (utime || stime) { \
-            MP_TRACE_t(MP_FUNC, "%s %5.2f user %5.2f sys\n", \
+            MP_TRACE_t(MP_FUNC, "%s %5.2f user %5.2f sys", \
                        label, utime, stime); \
         } \
     })
Index: xs/modperl_xs_util.h
===================================================================
--- xs/modperl_xs_util.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/modperl_xs_util.h	(.../trunk)	(revision 630610)
@@ -73,7 +73,7 @@
 
 #define mpxs_sv_object_deref(sv, type)                  \
     (mpxs_sv_is_object(sv) ?                            \
-        INT2PTR(type *, SvIVX((SV*)SvRV(sv))) : NULL) 
+        INT2PTR(type *, SvIVX((SV*)SvRV(sv))) : NULL)
 
 #define mpxs_sv2_obj(obj, sv)                   \
     (obj = mp_xs_sv2_##obj(sv))
Index: xs/maps/apache2_structures.map
===================================================================
--- xs/maps/apache2_structures.map	(.../tags/2_0_3)	(revision 630610)
+++ xs/maps/apache2_structures.map	(.../trunk)	(revision 630610)
@@ -12,7 +12,7 @@
 <  next
 <  prev
 <  main
-<  the_request
+   the_request
    assbackwards
 ~  proxyreq
 <  header_only
Index: xs/maps/apr_types.map
===================================================================
--- xs/maps/apr_types.map	(.../tags/2_0_3)	(revision 630610)
+++ xs/maps/apr_types.map	(.../trunk)	(revision 630610)
@@ -102,7 +102,7 @@
 struct apr_thread_mutex_t    | APR::ThreadMutex
 struct apr_thread_once_t     | UNDEFINED
 struct apr_thread_cond_t     | UNDEFINED
-struct apr_thread_rwlock_t   | UNDEFINED
+struct apr_thread_rwlock_t   | APR::ThreadRWLock
 
 #signal stuff
 apr_signum_t                 | UNDEFINED
Index: xs/maps/apr_functions.map
===================================================================
--- xs/maps/apr_functions.map	(.../tags/2_0_3)	(revision 630610)
+++ xs/maps/apr_functions.map	(.../trunk)	(revision 630610)
@@ -397,9 +397,9 @@
  apr_thread_cond_pool_get
  apr_thread_cond_timedwait
 
--MODULE=APR::ThreadRWLock
- apr_thread_rwlock_create
- apr_thread_rwlock_destroy
+MODULE=APR::ThreadRWLock   PREFIX=apr_thread_rwlock_
+ SV *:apr_thread_rwlock_create | mpxs_ | SV *:classname, SV *:p_sv | new
+ void:apr_thread_rwlock_destroy | | | apr_thread_rwlock_DESTROY
  apr_thread_rwlock_rdlock
  apr_thread_rwlock_tryrdlock
  apr_thread_rwlock_trywrlock
Index: xs/maps/apache2_functions.map
===================================================================
--- xs/maps/apache2_functions.map	(.../tags/2_0_3)	(revision 630610)
+++ xs/maps/apache2_functions.map	(.../trunk)	(revision 630610)
@@ -176,6 +176,8 @@
 !ap_get_local_host
 ~ap_get_server_built
 ~ap_get_server_version
+~ap_get_server_banner
+~ap_get_server_description
 ~ap_server_root
 
 
Index: xs/APR/APR/Makefile.PL
===================================================================
--- xs/APR/APR/Makefile.PL	(.../tags/2_0_3)	(revision 630610)
+++ xs/APR/APR/Makefile.PL	(.../trunk)	(revision 630610)
@@ -15,7 +15,7 @@
 
 my %args;
 
-%args = map { split /=/, $_ } @ARGV;
+%args = map { split /=/, $_, 2 } @ARGV;
 
 $args{NAME}         = 'APR';
 $args{VERSION_FROM} = 'APR.pm';
Index: xs/APR/Base64/APR__Base64.h
===================================================================
--- xs/APR/Base64/APR__Base64.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/APR/Base64/APR__Base64.h	(.../trunk)	(revision 630610)
@@ -17,7 +17,7 @@
 /* apr_base64_encode_len and apr_base64_encode_binary give length that
  * includes the terminating '\0' */
 #define mpxs_APR__Base64_encode_len(len) (apr_base64_encode_len(len) - 1)
-    
+
 static MP_INLINE void mpxs_apr_base64_encode(pTHX_ SV *sv, SV *arg)
 {
     STRLEN len;
Index: xs/APR/Table/APR__Table.h
===================================================================
--- xs/APR/Table/APR__Table.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/APR/Table/APR__Table.h	(.../trunk)	(revision 630610)
@@ -91,8 +91,8 @@
     return rv;
 }
 
-static MP_INLINE 
-int mpxs_apr_table_do(pTHX_ I32 items, SV **MARK, SV **SP) 
+static MP_INLINE
+int mpxs_apr_table_do(pTHX_ I32 items, SV **MARK, SV **SP)
 {
     apr_table_t *table;
     SV *sub;
@@ -119,8 +119,8 @@
         }
     }
 
-    /* XXX: would be nice to be able to call apr_table_vdo directly, 
-     * but I don't think it's possible to create/populate something 
+    /* XXX: would be nice to be able to call apr_table_vdo directly,
+     * but I don't think it's possible to create/populate something
      * that smells like a va_list with our list of filters specs
      */
 
@@ -154,7 +154,7 @@
                    "first argument not an APR::Table object");
     }
 
-    t = INT2PTR(apr_table_t *, SvIVX(SvRV(rv))); 
+    t = INT2PTR(apr_table_t *, SvIVX(SvRV(rv)));
 
     if (apr_is_empty_table(t)) {
         return NULL;
Index: xs/APR/Socket/APR__Socket.h
===================================================================
--- xs/APR/Socket/APR__Socket.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/APR/Socket/APR__Socket.h	(.../trunk)	(revision 630610)
@@ -59,7 +59,7 @@
 apr_interval_time_t mpxs_apr_socket_timeout_get(pTHX_ I32 items,
                                                 SV **MARK, SV **SP)
 {
-    apr_interval_time_t	t;
+    apr_interval_time_t t;
     APR__Socket APR__Socket;
 
     /* this also magically assings to APR_Socket ;-) */
Index: xs/APR/Lock/APR__Lock.h
===================================================================
--- xs/APR/Lock/APR__Lock.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/APR/Lock/APR__Lock.h	(.../trunk)	(revision 630610)
@@ -13,4 +13,3 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
Index: xs/APR/BucketAlloc/APR__BucketAlloc.h
===================================================================
--- xs/APR/BucketAlloc/APR__BucketAlloc.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/APR/BucketAlloc/APR__BucketAlloc.h	(.../trunk)	(revision 630610)
@@ -27,4 +27,3 @@
     mpxs_add_pool_magic(ba_sv, p_sv);
     return ba_sv;
 }
-
Index: xs/APR/Error/APR__Error.h
===================================================================
--- xs/APR/Error/APR__Error.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/APR/Error/APR__Error.h	(.../trunk)	(revision 630610)
@@ -15,4 +15,3 @@
  */
 
 #define mpxs_APR__Error_strerror(rc) modperl_error_strerror(aTHX_ rc)
-
Index: xs/APR/ThreadRWLock/APR__ThreadRWLock.h
===================================================================
--- xs/APR/ThreadRWLock/APR__ThreadRWLock.h	(.../tags/2_0_3)	(revision 0)
+++ xs/APR/ThreadRWLock/APR__ThreadRWLock.h	(.../trunk)	(revision 630610)
@@ -0,0 +1,29 @@
+/* Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define apr_thread_rwlock_DESTROY apr_thread_rwlock_destroy
+
+static MP_INLINE
+SV *mpxs_apr_thread_rwlock_create(pTHX_ SV *classname, SV *p_sv)
+{
+    apr_pool_t *p = mp_xs_sv2_APR__Pool(p_sv);
+    apr_thread_rwlock_t *rwlock = NULL;
+    SV *rwlock_sv;
+    (void)apr_thread_rwlock_create(&rwlock, p);
+    rwlock_sv = sv_setref_pv(NEWSV(0, 0), "APR::ThreadRWLock", (void*)rwlock);
+    mpxs_add_pool_magic(rwlock_sv, p_sv);
+    return rwlock_sv;
+}
Index: xs/APR/PerlIO/modperl_apr_perlio.c
===================================================================
--- xs/APR/PerlIO/modperl_apr_perlio.c	(.../tags/2_0_3)	(revision 630610)
+++ xs/APR/PerlIO/modperl_apr_perlio.c	(.../trunk)	(revision 630610)
@@ -86,7 +86,7 @@
     switch (*mode) {
       case 'a':
         apr_flag = APR_APPEND | APR_CREATE;
-        break; 
+        break;
       case 'w':
         apr_flag = APR_WRITE | APR_CREATE | APR_TRUNCATE;
         break;
@@ -176,7 +176,7 @@
 
     rc = apr_file_read(st->file, vbuf, &count);
 
-    MP_TRACE_o(MP_FUNC, "%db [%s]\n", (int)count,
+    MP_TRACE_o(MP_FUNC, "%db [%s]", (int)count,
                MP_TRACE_STR_TRUNC(st->pool, (char *)vbuf, (int)count));
 
     if (rc == APR_EOF) {
@@ -184,7 +184,7 @@
         return count;
     }
     else if (rc != APR_SUCCESS) {
-        modperl_croak(aTHX_ rc, "APR::PerlIO::read");  
+        modperl_croak(aTHX_ rc, "APR::PerlIO::read");
     }
 
     return count;
@@ -195,7 +195,7 @@
     PerlIOAPR *st = PerlIOSelf(f, PerlIOAPR);
     apr_status_t rc;
 
-    MP_TRACE_o(MP_FUNC, "%db [%s]\n", (int)count,
+    MP_TRACE_o(MP_FUNC, "%db [%s]", (int)count,
                MP_TRACE_STR_TRUNC(st->pool, (char *)vbuf, (int)count));
 
     rc = apr_file_write(st->file, vbuf, &count);
@@ -294,7 +294,7 @@
         apr_file_name_get(&new_path, st->file);
     }
 
-    rc = apr_os_file_get(&os_file, st->file); 
+    rc = apr_os_file_get(&os_file, st->file);
     if (rc != APR_SUCCESS) {
         Perl_croak(aTHX_ "filedes retrieval failed!");
     }
@@ -408,7 +408,7 @@
     PerlIOAPR_read,
     PerlIOBase_unread,
     PerlIOAPR_write,
-    PerlIOAPR_seek, 
+    PerlIOAPR_seek,
     PerlIOAPR_tell,
     PerlIOAPR_close,
     PerlIOAPR_flush,            /* flush */
@@ -475,7 +475,7 @@
         apr_os_file_t os_file;
 
         /* convert to the OS representation of file */
-        rc = apr_os_file_get(&os_file, file); 
+        rc = apr_os_file_get(&os_file, file);
         if (rc != APR_SUCCESS) {
             croak("filedes retrieval failed!");
         }
@@ -495,10 +495,10 @@
 static SV *modperl_apr_perlio_PerlIO_to_glob(pTHX_ PerlIO *pio,
                                              modperl_apr_perlio_hook_e type)
 {
-    SV *retval = modperl_perl_gensym(aTHX_ "APR::PerlIO"); 
-    GV *gv = (GV*)SvRV(retval); 
+    SV *retval = modperl_perl_gensym(aTHX_ "APR::PerlIO");
+    GV *gv = (GV*)SvRV(retval);
 
-    gv_IOadd(gv); 
+    gv_IOadd(gv);
 
     switch (type) {
       case MODPERL_APR_PERLIO_HOOK_WRITE:
@@ -553,7 +553,7 @@
     };
 
     /* convert to the OS representation of file */
-    rc = apr_os_file_get(&os_file, file); 
+    rc = apr_os_file_get(&os_file, file);
     if (rc != APR_SUCCESS) {
         Perl_croak(aTHX_ "filedes retrieval failed!");
     }
@@ -563,8 +563,8 @@
     /* let's try without the dup, it seems to work fine:
 
        fd = PerlLIO_dup(os_file);
-       MP_TRACE_o(MP_FUNC, "fd old: %d, new %d\n", os_file, fd);
-       if (!(retval = PerlIO_fdopen(fd, mode))) { 
+       MP_TRACE_o(MP_FUNC, "fd old: %d, new %d", os_file, fd);
+       if (!(retval = PerlIO_fdopen(fd, mode))) {
        ...
        }
 
@@ -576,22 +576,22 @@
 
     */
 
-    if (!(retval = PerlIO_fdopen(os_file, mode))) { 
+    if (!(retval = PerlIO_fdopen(os_file, mode))) {
         PerlLIO_close(fd);
         Perl_croak(aTHX_ "fdopen failed!");
-    } 
+    }
 
     return retval;
 }
 
-SV *modperl_apr_perlio_apr_file_to_glob(pTHX_ apr_file_t *file, 
+SV *modperl_apr_perlio_apr_file_to_glob(pTHX_ apr_file_t *file,
                                         apr_pool_t *pool,
                                         modperl_apr_perlio_hook_e type)
 {
-    SV *retval = modperl_perl_gensym(aTHX_ "APR::PerlIO"); 
-    GV *gv = (GV*)SvRV(retval); 
+    SV *retval = modperl_perl_gensym(aTHX_ "APR::PerlIO");
+    GV *gv = (GV*)SvRV(retval);
 
-    gv_IOadd(gv); 
+    gv_IOadd(gv);
 
     switch (type) {
       case MODPERL_APR_PERLIO_HOOK_WRITE:
@@ -616,4 +616,3 @@
 }
 
 #endif /* PERLIO_LAYERS */
-
Index: xs/APR/PerlIO/modperl_apr_perlio.h
===================================================================
--- xs/APR/PerlIO/modperl_apr_perlio.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/APR/PerlIO/modperl_apr_perlio.h	(.../trunk)	(revision 630610)
@@ -19,7 +19,7 @@
 
 #ifdef PERLIO_LAYERS
 #include "perliol.h"
-#else 
+#else
 #include "iperlsys.h"
 #endif
 
@@ -54,7 +54,7 @@
 #ifndef MP_SOURCE_SCAN
 
 #ifdef PERLIO_LAYERS
-PerlIO *modperl_apr_perlio_apr_file_to_PerlIO(pTHX_ apr_file_t *file, 
+PerlIO *modperl_apr_perlio_apr_file_to_PerlIO(pTHX_ apr_file_t *file,
                                               apr_pool_t *pool,
                                               modperl_apr_perlio_hook_e type);
 APR_DECLARE_OPTIONAL_FN(PerlIO *,
@@ -64,7 +64,7 @@
 #endif /* PERLIO_LAYERS */
 
 
-SV *modperl_apr_perlio_apr_file_to_glob(pTHX_ apr_file_t *file, 
+SV *modperl_apr_perlio_apr_file_to_glob(pTHX_ apr_file_t *file,
                                         apr_pool_t *pool,
                                         modperl_apr_perlio_hook_e type);
 APR_DECLARE_OPTIONAL_FN(SV *,
Index: xs/APR/Brigade/APR__Brigade.h
===================================================================
--- xs/APR/Brigade/APR__Brigade.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/APR/Brigade/APR__Brigade.h	(.../trunk)	(revision 630610)
@@ -97,7 +97,7 @@
 static MP_INLINE
 apr_pool_t *mpxs_APR__Brigade_pool(apr_bucket_brigade *brigade)
 {
-    /* eesh, it's r->pool, and c->pool, but bb->p 
+    /* eesh, it's r->pool, and c->pool, but bb->p
      * let's make Perl consistent, otherwise this could be autogenerated
      */
 
Index: xs/APR/URI/APR__URI.h
===================================================================
--- xs/APR/URI/APR__URI.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/APR/URI/APR__URI.h	(.../trunk)	(revision 630610)
@@ -47,7 +47,7 @@
 
     uri_sv = sv_setref_pv(NEWSV(0, 0), "APR::URI", (void*)uri);
     mpxs_add_pool_magic(uri_sv, p_sv);
-    
+
     return uri_sv;
 }
 
Index: xs/APR/Finfo/APR__Finfo.h
===================================================================
--- xs/APR/Finfo/APR__Finfo.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/APR/Finfo/APR__Finfo.h	(.../trunk)	(revision 630610)
@@ -21,12 +21,12 @@
     apr_pool_t *p = mp_xs_sv2_APR__Pool(p_sv);
     apr_finfo_t *finfo = (apr_finfo_t *)apr_pcalloc(p, sizeof(apr_finfo_t));
     SV *finfo_sv;
-    
+
     MP_RUN_CROAK(apr_stat(finfo, fname, wanted, p),
                  "APR::Finfo::stat");
 
     finfo_sv = sv_setref_pv(NEWSV(0, 0), "APR::Finfo", (void*)finfo);
     mpxs_add_pool_magic(finfo_sv, p_sv);
-    
+
     return finfo_sv;
 }
Index: xs/APR/String/APR__String.h
===================================================================
--- xs/APR/String/APR__String.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/APR/String/APR__String.h	(.../trunk)	(revision 630610)
@@ -21,5 +21,5 @@
 
     apr_strfsize(size, buff);
 
-    return newSVpvn(buff, 4);    
+    return newSVpvn(buff, 4);
 }
Index: xs/APR/Pool/APR__Pool.h
===================================================================
--- xs/APR/Pool/APR__Pool.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/APR/Pool/APR__Pool.h	(.../trunk)	(revision 630610)
@@ -39,10 +39,12 @@
  */
 
 #ifndef MP_SOURCE_SCAN
+#ifdef USE_ITHREADS
 #include "apr_optional.h"
-static
 APR_OPTIONAL_FN_TYPE(modperl_interp_unselect) *modperl_opt_interp_unselect;
+APR_OPTIONAL_FN_TYPE(modperl_thx_interp_get) *modperl_opt_thx_interp_get;
 #endif
+#endif
 
 #define MP_APR_POOL_SV_HAS_OWNERSHIP(sv) mpxs_pool_is_custom(sv)
 
@@ -64,7 +66,7 @@
     mg_free(acct->sv);                                              \
     SvIVX(acct->sv) = 0;                                            \
 } STMT_END
-    
+
 #ifdef USE_ITHREADS
 
 #define MP_APR_POOL_SV_DROPS_OWNERSHIP(acct) STMT_START {               \
@@ -95,8 +97,10 @@
     /* make sure interpreter is not putback into the mip                \
      * until this cleanup has run.                                      \
      */                                                                 \
-    if ((acct->interp = MP_THX_INTERP_GET(aTHX))) {                     \
-        acct->interp->refcnt++;                                         \
+    if (modperl_opt_thx_interp_get) {                                   \
+        if ((acct->interp = modperl_opt_thx_interp_get(aTHX))) {        \
+            acct->interp->refcnt++;                                     \
+        }                                                               \
     }                                                                   \
 } STMT_END
 
@@ -152,7 +156,7 @@
     apr_pool_t *parent_pool = mpxs_sv_object_deref(parent_pool_obj, apr_pool_t);
     apr_pool_t *child_pool  = NULL;
 
-    MP_POOL_TRACE(MP_FUNC, "parent pool 0x%lx\n", (unsigned long)parent_pool);
+    MP_POOL_TRACE(MP_FUNC, "parent pool 0x%l", (unsigned long)parent_pool);
     (void)apr_pool_create(&child_pool, parent_pool);
 
 #if APR_POOL_DEBUG
@@ -176,11 +180,11 @@
         apr_pool_t *pp;
 
         while ((pp = apr_pool_parent_get(p))) {
-            MP_POOL_TRACE(MP_FUNC, "parent 0x%lx, child 0x%lx\n",
+            MP_POOL_TRACE(MP_FUNC, "parent 0x%lx, child 0x%lx",
                     (unsigned long)pp, (unsigned long)p);
 
             if (apr_pool_is_ancestor(pp, p)) {
-                MP_POOL_TRACE(MP_FUNC, "0x%lx is a subpool of 0x%lx\n",
+                MP_POOL_TRACE(MP_FUNC, "0x%lx is a subpool of 0x%lx",
                         (unsigned long)p, (unsigned long)pp);
             }
             p = pp;
@@ -217,7 +221,7 @@
         if (parent_pool) {
             mpxs_add_pool_magic(rv, parent_pool_obj);
         }
-        
+
         return rv;
     }
 }
@@ -335,8 +339,10 @@
     /* make sure interpreter is not putback into the mip
      * until this cleanup has run.
      */
-    if ((data->interp = MP_THX_INTERP_GET(data->perl))) {
-        data->interp->refcnt++;
+    if (modperl_opt_thx_interp_get) {
+        if ((data->interp = modperl_opt_thx_interp_get(data->perl))) {
+            data->interp->refcnt++;
+        }
     }
 #endif
 
@@ -374,4 +380,3 @@
         apr_pool_destroy(p);
     }
 }
-
Index: xs/APR/Bucket/APR__Bucket.h
===================================================================
--- xs/APR/Bucket/APR__Bucket.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/APR/Bucket/APR__Bucket.h	(.../trunk)	(revision 630610)
@@ -119,6 +119,6 @@
      * by modperl_bucket_sv_setaside) if the pool goes out of scope,
      * copying the data to the heap.
      */
-    
+
     return rc;
 }
Index: xs/Apache2/RequestIO/Apache2__RequestIO.h
===================================================================
--- xs/Apache2/RequestIO/Apache2__RequestIO.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/Apache2/RequestIO/Apache2__RequestIO.h	(.../trunk)	(revision 630610)
@@ -97,7 +97,7 @@
     mpxs_output_flush(r, rcfg, "Apache2::RequestIO::print");
 
     return bytes ? newSVuv(bytes) : newSVpvn("0E0", 3);
-}  
+}
 
 static MP_INLINE
 apr_size_t mpxs_ap_rprintf(pTHX_ I32 items, SV **MARK, SV **SP)
@@ -129,7 +129,7 @@
     mpxs_output_flush(r, rcfg, "Apache2::RequestIO::printf");
 
     return bytes;
-}  
+}
 
 /* alias */
 #define mpxs_Apache2__RequestRec_WRITE(r, buffer, len, offset) \
@@ -252,7 +252,7 @@
 
     if (total > 0) {
         mpxs_sv_cur_set(buffer, offset+total);
-    } 
+    }
     else {
         sv_setpvn(buffer, "", 0);
     }
Index: xs/Apache2/Log/Apache2__Log.h
===================================================================
--- xs/Apache2/Log/Apache2__Log.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/Apache2/Log/Apache2__Log.h	(.../trunk)	(revision 630610)
@@ -16,9 +16,9 @@
 
 static void mpxs_Apache2__Log_BOOT(pTHX)
 {
-    av_push(get_av("Apache2::Log::Request::ISA", TRUE), 
+    av_push(get_av("Apache2::Log::Request::ISA", TRUE),
             newSVpv("Apache2::Log", 12));
-    av_push(get_av("Apache2::Log::Server::ISA", TRUE), 
+    av_push(get_av("Apache2::Log::Server::ISA", TRUE),
             newSVpv("Apache2::Log", 12));
 }
 
@@ -54,7 +54,7 @@
         line = CopLINE(cop); /* (caller)[2] */
     }
 
-    if ((s->loglevel >= lmask) && 
+    if ((s->loglevel >= lmask) &&
         SvROK(msg) && (SvTYPE(SvRV(msg)) == SVt_PVCV)) {
         dSP;
         ENTER;SAVETMPS;
Index: xs/Apache2/RequestRec/Apache2__RequestRec.h
===================================================================
--- xs/Apache2/RequestRec/Apache2__RequestRec.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/Apache2/RequestRec/Apache2__RequestRec.h	(.../trunk)	(revision 630610)
@@ -35,10 +35,10 @@
 SV *mpxs_Apache2__RequestRec_content_languages(pTHX_ request_rec *r,
                                               SV *languages)
 {
-    SV *retval = modperl_apr_array_header2avrv(aTHX_ 
+    SV *retval = modperl_apr_array_header2avrv(aTHX_
                                                r->content_languages);
     if (languages) {
-        r->content_languages = modperl_avrv2apr_array_header(aTHX_ 
+        r->content_languages = modperl_avrv2apr_array_header(aTHX_
                                                              r->pool,
                                                              languages);
     }
@@ -52,11 +52,11 @@
 
     if (!val && !r->proxyreq &&
         r->parsed_uri.scheme &&
-	!(r->parsed_uri.hostname && 
-	  strEQ(r->parsed_uri.scheme, ap_http_scheme(r)) &&
-	  ap_matches_request_vhost(r, r->parsed_uri.hostname,
-                                   r->parsed_uri.port_str ? 
-                                   r->parsed_uri.port : 
+        !(r->parsed_uri.hostname &&
+          strEQ(r->parsed_uri.scheme, ap_http_scheme(r)) &&
+          ap_matches_request_vhost(r, r->parsed_uri.hostname,
+                                   r->parsed_uri.port_str ?
+                                   r->parsed_uri.port :
                                    ap_default_port(r))))
     {
         retval = r->proxyreq = 1;
@@ -146,5 +146,3 @@
 
     return RETVAL;
 }
-
-
Index: xs/Apache2/Module/Apache2__Module.h
===================================================================
--- xs/Apache2/Module/Apache2__Module.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/Apache2/Module/Apache2__Module.h	(.../trunk)	(revision 630610)
@@ -75,7 +75,7 @@
     return mod->minor_version;
 }
 
-static MP_INLINE void mpxs_Apache2__Module_add(pTHX_ 
+static MP_INLINE void mpxs_Apache2__Module_add(pTHX_
                                               char *package,
                                               SV *cmds)
 {
@@ -90,7 +90,7 @@
     error = modperl_module_add(s->process->pconf, s, package, cmds);
 
     if (error) {
-        Perl_croak(aTHX_ "Apache2::Module::add(%s) failed : %s", 
+        Perl_croak(aTHX_ "Apache2::Module::add(%s) failed : %s",
                    package, error);
     }
 
Index: xs/Apache2/Filter/Apache2__Filter.h
===================================================================
--- xs/Apache2/Filter/Apache2__Filter.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/Apache2/Filter/Apache2__Filter.h	(.../trunk)	(revision 630610)
@@ -32,8 +32,8 @@
 
     mpxs_usage_va_1(modperl_filter, "$filter->print(...)");
 
-    MP_TRACE_f(MP_FUNC, "from %s\n",
-               ((modperl_filter_ctx_t *)modperl_filter->f->ctx)->handler->name);    
+    MP_TRACE_f(MP_FUNC, "from %s",
+               ((modperl_filter_ctx_t *)modperl_filter->f->ctx)->handler->name);
     if (modperl_filter->mode == MP_OUTPUT_FILTER_MODE) {
         mpxs_write_loop(modperl_output_filter_write,
                         modperl_filter, "Apache2::Filter::print");
@@ -57,7 +57,7 @@
 
     mpxs_usage_va_2(modperl_filter, buffer, "$filter->read(buf, [len])");
 
-    MP_TRACE_f(MP_FUNC, "from %s\n",
+    MP_TRACE_f(MP_FUNC, "from %s",
                ((modperl_filter_ctx_t *)modperl_filter->f->ctx)->handler->name);
 
     if (items > 2) {
@@ -86,14 +86,14 @@
     return len;
 }
 
-static MP_INLINE U32 *modperl_filter_attributes(SV *package, SV *cvrv)
+static MP_INLINE U16 *modperl_filter_attributes(pTHX_ SV *package, SV *cvrv)
 {
-    return (U32 *)&MP_CODE_ATTRS(SvRV(cvrv));
+    return modperl_code_attrs(aTHX_ (CV*)SvRV(cvrv));
 }
 
 #ifdef MP_TRACE
 #define trace_attr()                                                       \
-    MP_TRACE_f(MP_FUNC, "applied %s attribute to %s handler\n", attribute, \
+    MP_TRACE_f(MP_FUNC, "applied %s attribute to %s handler", attribute, \
                HvNAME(stash))
 #else
 #define trace_attr()
@@ -118,7 +118,7 @@
 MP_STATIC XS(MPXS_modperl_filter_attributes)
 {
     dXSARGS;
-    U32 *attrs = modperl_filter_attributes(ST(0), ST(1));
+    U16 *attrs = modperl_filter_attributes(aTHX_ ST(0), ST(1));
     I32 i;
 #ifdef MP_TRACE
     HV *stash = gv_stashsv(ST(0), TRUE);
@@ -295,7 +295,7 @@
     if (!modperl_filter) {
         f = INT2PTR(ap_filter_t *, SvIV(SvRV(*MARK)));
         MP_TRACE_f(MP_FUNC,
-                   "   %s\n\n\t non-modperl filter removes itself\n",
+                   "   %s\n\n\t non-modperl filter removes itself",
                    f->frec->name);
 
         /* the filter can reside in only one chain. hence we try to
@@ -310,7 +310,7 @@
 
     f = modperl_filter->f;
 
-    MP_TRACE_f(MP_FUNC, "   %s\n\n\tfilter removes itself\n",
+    MP_TRACE_f(MP_FUNC, "   %s\n\n\tfilter removes itself",
                ((modperl_filter_ctx_t *)f->ctx)->handler->name);
 
     if (modperl_filter->mode == MP_INPUT_FILTER_MODE) {
Index: xs/Apache2/RequestUtil/Apache2__RequestUtil.h
===================================================================
--- xs/Apache2/RequestUtil/Apache2__RequestUtil.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/Apache2/RequestUtil/Apache2__RequestUtil.h	(.../trunk)	(revision 630610)
@@ -81,7 +81,7 @@
     r->server     = s;
 
     r->request_time = apr_time_now();
-    
+
     r->user            = NULL;
     r->ap_auth_type    = NULL;
 
@@ -125,7 +125,7 @@
     if (base_pool_sv) {
         mpxs_add_pool_magic(r_sv, base_pool_sv);
     }
-    
+
     return r_sv;
 }
 
@@ -320,7 +320,7 @@
         struct mp_docroot_info *di;
         core_server_config *conf;
         MP_CROAK_IF_THREADS_STARTED("setting $r->document_root");
-        conf = ap_get_module_config(r->server->module_config, 
+        conf = ap_get_module_config(r->server->module_config,
                                     &core_module);
         di = apr_palloc(r->pool, sizeof *di);
         di->docroot = &conf->ap_document_root;
@@ -340,7 +340,7 @@
     /* On the first pass, re-register so we end up last */
     if (data) {
         apr_pool_cleanup_register(pool, NULL, child_terminate,
-                                  apr_pool_cleanup_null);    
+                                  apr_pool_cleanup_null);
     }
     else {
         exit(0);
Index: xs/Apache2/SubProcess/Apache2__SubProcess.h
===================================================================
--- xs/Apache2/SubProcess/Apache2__SubProcess.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/Apache2/SubProcess/Apache2__SubProcess.h	(.../trunk)	(revision 630610)
@@ -68,7 +68,7 @@
     if (FAILED(apr_procattr_create(&procattr, p)) ||
         FAILED(apr_procattr_io_set(procattr, e_info.in_pipe,
                                    e_info.out_pipe, e_info.err_pipe)) ||
-        FAILED(apr_procattr_dir_set(procattr, 
+        FAILED(apr_procattr_dir_set(procattr,
                                     ap_make_dirstr_parent(r->pool,
                                                           r->filename))) ||
         FAILED(apr_procattr_cmdtype_set(procattr, e_info.cmd_type)))
Index: xs/Apache2/MPM/Apache2__MPM.h
===================================================================
--- xs/Apache2/MPM/Apache2__MPM.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/Apache2/MPM/Apache2__MPM.h	(.../trunk)	(revision 630610)
@@ -38,7 +38,7 @@
     apr_status_t retval = ap_mpm_query(AP_MPMQ_IS_THREADED, &mpm_query_info);
 
     if (retval == APR_SUCCESS) {
-        MP_TRACE_g(MP_FUNC, "defined Apache2::MPM->is_threaded() as %i\n", 
+        MP_TRACE_g(MP_FUNC, "defined Apache2::MPM->is_threaded() as %i",
                    mpm_query_info);
 
         newCONSTSUB(PL_defstash, "Apache2::MPM::is_threaded",
@@ -46,13 +46,13 @@
     }
     else {
         /* assign false (0) to sub if ap_mpm_query didn't succeed */
-        MP_TRACE_g(MP_FUNC, "defined Apache2::MPM->is_threaded() as 0\n");
+        MP_TRACE_g(MP_FUNC, "defined Apache2::MPM->is_threaded() as 0");
 
         newCONSTSUB(PL_defstash, "Apache2::MPM::is_threaded",
                     newSViv(0));
     }
 
-    MP_TRACE_g(MP_FUNC, "defined Apache2::MPM->show() as %s\n",
+    MP_TRACE_g(MP_FUNC, "defined Apache2::MPM->show() as %s",
                ap_show_mpm());
 
     newCONSTSUB(PL_defstash, "Apache2::MPM::show",
Index: xs/Apache2/ConnectionUtil/Apache2__ConnectionUtil.h
===================================================================
--- xs/Apache2/ConnectionUtil/Apache2__ConnectionUtil.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/Apache2/ConnectionUtil/Apache2__ConnectionUtil.h	(.../trunk)	(revision 630610)
@@ -20,7 +20,7 @@
     MP_dCCFG;
 
     modperl_config_con_init(c, ccfg);
-    
+
     if (!ccfg) {
         return &PL_sv_undef;
     }
Index: xs/Apache2/Connection/Apache2__Connection.h
===================================================================
--- xs/Apache2/Connection/Apache2__Connection.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/Apache2/Connection/Apache2__Connection.h	(.../trunk)	(revision 630610)
@@ -40,4 +40,3 @@
 {
     return ap_get_remote_host(c, (void *)dir_config, type, NULL);
 }
-
Index: xs/Apache2/Access/Apache2__Access.h
===================================================================
--- xs/Apache2/Access/Apache2__Access.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/Apache2/Access/Apache2__Access.h	(.../trunk)	(revision 630610)
@@ -37,16 +37,16 @@
 
         hv = newHV();
 
-        hv_store(hv, "method_mask", 11, 
+        hv_store(hv, "method_mask", 11,
                  newSViv((IV)reqs[x].method_mask), 0);
 
-        hv_store(hv, "requirement", 11, 
+        hv_store(hv, "requirement", 11,
                  newSVpv(reqs[x].requirement,0), 0);
 
         av_push(av, newRV_noinc((SV*)hv));
     }
 
-    return newRV_noinc((SV*)av); 
+    return newRV_noinc((SV*)av);
 }
 
 static MP_INLINE
@@ -81,7 +81,7 @@
     errmsg =
         modperl_config_insert_request(aTHX_ r,
                                       newRV_noinc((SV*)config),
-                                      OR_AUTHCFG, NULL, 
+                                      OR_AUTHCFG, NULL,
                                       MP_HTTPD_OVERRIDE_OPTS_UNSET);
 
     if (errmsg) {
@@ -147,7 +147,7 @@
 int mpxs_Apache2__RequestRec_allow_override_opts(pTHX_ request_rec *r)
 {
 #ifdef MP_HTTPD_HAS_OVERRIDE_OPTS
-    core_dir_config *cfg = ap_get_module_config(r->per_dir_config, 
+    core_dir_config *cfg = ap_get_module_config(r->per_dir_config,
                                                 &core_module);
     return cfg->override_opts;
 #else
Index: xs/Apache2/SubRequest/Apache2__SubRequest.h
===================================================================
--- xs/Apache2/SubRequest/Apache2__SubRequest.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/Apache2/SubRequest/Apache2__SubRequest.h	(.../trunk)	(revision 630610)
@@ -23,8 +23,10 @@
 
     if (r->main) {
         modperl_config_req_t *rcfg = modperl_config_req_get(r->main);
-        MP_RUN_CROAK(modperl_wbucket_flush(rcfg->wbucket, FALSE),
-                     "Apache2::SubRequest::run");
+        if (rcfg->wbucket) {
+            MP_RUN_CROAK(modperl_wbucket_flush(rcfg->wbucket, FALSE),
+                         "Apache2::SubRequest::run");
+        }
     }
 
     return ap_run_sub_req(r);
Index: xs/Apache2/ServerUtil/Apache2__ServerUtil.h
===================================================================
--- xs/Apache2/ServerUtil/Apache2__ServerUtil.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/Apache2/ServerUtil/Apache2__ServerUtil.h	(.../trunk)	(revision 630610)
@@ -195,4 +195,10 @@
 
     newCONSTSUB(PL_defstash, "Apache2::ServerUtil::get_server_version",
                 newSVpv(ap_get_server_version(), 0));
+
+    newCONSTSUB(PL_defstash, "Apache2::ServerUtil::get_server_banner",
+                newSVpv(ap_get_server_banner(), 0));
+
+    newCONSTSUB(PL_defstash, "Apache2::ServerUtil::get_server_description",
+                newSVpv(ap_get_server_description(), 0));
 }
Index: xs/Apache2/CmdParms/Apache2__CmdParms.h
===================================================================
--- xs/Apache2/CmdParms/Apache2__CmdParms.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/Apache2/CmdParms/Apache2__CmdParms.h	(.../trunk)	(revision 630610)
@@ -25,7 +25,7 @@
         return newSVpv(data, 0);
     }
 
-    return &PL_sv_undef;    
+    return &PL_sv_undef;
 }
 
 static MP_INLINE
Index: xs/Apache2/Directive/Apache2__Directive.h
===================================================================
--- xs/Apache2/Directive/Apache2__Directive.h	(.../tags/2_0_3)	(revision 630610)
+++ xs/Apache2/Directive/Apache2__Directive.h	(.../trunk)	(revision 630610)
@@ -35,8 +35,8 @@
 
 
 /* Adds an entry to a hash, vivifying hash/array for multiple entries */
-static void hash_insert(pTHX_ HV *hash, const char *key, 
-                        int keylen, const char *args, 
+static void hash_insert(pTHX_ HV *hash, const char *key,
+                        int keylen, const char *args,
                         int argslen, SV *value)
 {
     HV *subhash;
@@ -73,7 +73,7 @@
 }
 
 static MP_INLINE SV *mpxs_Apache2__Directive_as_hash(pTHX_
-                                                    ap_directive_t *tree)      
+                                                    ap_directive_t *tree)
 {
     const char *directive;
     int directive_len;
@@ -103,12 +103,12 @@
             }
 
             subtree = mpxs_Apache2__Directive_as_hash(aTHX_ tree->first_child);
-            hash_insert(aTHX_ hash, directive, directive_len, 
+            hash_insert(aTHX_ hash, directive, directive_len,
                         args, args_len, subtree);
         }
         else {
-            hash_insert(aTHX_ hash, directive, directive_len, 
-                        args, args_len, Nullsv);   
+            hash_insert(aTHX_ hash, directive, directive_len,
+                        args, args_len, Nullsv);
         }
 
         tree = tree->next;
@@ -122,7 +122,7 @@
     dXSARGS;
 
     if (items < 2 || items > 3) {
-	    Perl_croak(aTHX_
+            Perl_croak(aTHX_
                        "Usage: Apache2::Directive::lookup(self, key, [args])");
     }
 
@@ -137,20 +137,20 @@
         char *key = (char *)SvPV_nolen(ST(1));
         int scalar_context = (G_SCALAR == GIMME_V);
 
-	    if (SvROK(ST(0)) && sv_derived_from(ST(0), "Apache2::Directive")) {
-	        IV tmp = SvIV((SV*)SvRV(ST(0)));
-	        tree = INT2PTR(Apache2__Directive,tmp);
-	    }
-	    else {
-	        tree = ap_conftree;
+            if (SvROK(ST(0)) && sv_derived_from(ST(0), "Apache2::Directive")) {
+                IV tmp = SvIV((SV*)SvRV(ST(0)));
+                tree = INT2PTR(Apache2__Directive,tmp);
             }
+            else {
+                tree = ap_conftree;
+            }
 
-	    if (items < 3) {
-	        value = NULL;
+            if (items < 3) {
+                value = NULL;
             }
-	    else {
-	        value = (char *)SvPV_nolen(ST(2));
-	    }
+            else {
+                value = (char *)SvPV_nolen(ST(2));
+            }
 
         while (tree) {
             directive = tree->directive;
Index: xs/tables/current/ModPerl/FunctionTable.pm
===================================================================
--- xs/tables/current/ModPerl/FunctionTable.pm	(.../tags/2_0_3)	(revision 630610)
+++ xs/tables/current/ModPerl/FunctionTable.pm	(.../trunk)	(revision 630610)
@@ -1239,6 +1239,20 @@
     ]
   },
   {
+    'return_type' => 'U16 *',
+    'name' => 'modperl_code_attrs',
+    'args' => [
+     {
+        'type' => 'PerlInterpreter *',
+        'name' => 'my_perl'
+      },
+      {
+        'type' => 'CV *',
+        'name' => 'cv'
+      }
+    ]
+  },
+  {
     'return_type' => 'int',
     'name' => 'modperl_config_apply_PerlModule',
     'args' => [
@@ -5030,7 +5044,31 @@
     'args' => []
   },
   {
+    'return_type' => 'modperl_interp_t *',
+    'name' => 'modperl_thx_interp_get',
+    'args' => [
+      {
+        'type' => 'PerlInterpreter *',
+        'name' => 'thx',
+      },
+    ],
+  },
+  {
     'return_type' => 'void',
+    'name' => 'modperl_thx_interp_set',
+    'args' => [
+      {
+        'type' => 'PerlInterpreter *',
+        'name' => 'thx',
+      },
+      {
+        'type' => 'modperl_interp_t *',
+        'name' => 'interp',
+      },
+    ],
+  },
+  {
+    'return_type' => 'void',
     'name' => 'modperl_tipool_add',
     'args' => [
       {
Index: xs/tables/current/Apache2/FunctionTable.pm
===================================================================
--- xs/tables/current/Apache2/FunctionTable.pm	(.../tags/2_0_3)	(revision 630610)
+++ xs/tables/current/Apache2/FunctionTable.pm	(.../trunk)	(revision 630610)
@@ -1476,6 +1476,16 @@
   },
   {
     'return_type' => 'const char *',
+    'name' => 'ap_get_server_description',
+    'args' => []
+  },
+  {
+    'return_type' => 'const char *',
+    'name' => 'ap_get_server_banner',
+    'args' => []
+  },
+  {
+    'return_type' => 'const char *',
     'name' => 'ap_get_status_line',
     'args' => [
       {
Index: BRANCHING
===================================================================
--- BRANCHING	(.../tags/2_0_3)	(revision 630610)
+++ BRANCHING	(.../trunk)	(revision 630610)
@@ -1,53 +1,81 @@
 This doc explains how to create/work/re-merge svn branches
 
 #######################################
-### make a new branch               ###
+### PREREQUISITE                    ###
 #######################################
 
-we will create a branch clone-skip-unstable
+You need to have svnmerge installed and working
+before you can proceed with rest of the instructions.
 
-tag before the branch:
+You can find it here:
 
-  svn copy https://svn.apache.org/repos/asf/perl/modperl/trunk \
-    https://svn.apache.org/repos/asf/perl/modperl/tags/pre-clone-skip \
-    -m "tag before branching for CLONE_SKIP support"
+http://www.orcaware.com/svn/wiki/Svnmerge.py
 
+#######################################
+### make a new branch               ###
+#######################################
+
+we will create a branch mybranch
+
 branch:
 
   svn copy https://svn.apache.org/repos/asf/perl/modperl/trunk \
-    https://svn.apache.org/repos/asf/perl/modperl/branches/clone-skip-unstable \
-    -m "branching to provide CLONE_SKIP support"
+    https://svn.apache.org/repos/asf/perl/modperl/branches/mybranch \
+    -m "creating mybranch"
 
 check out:
 
-  svn co https://svn.apache.org/repos/asf/perl/modperl/branches/clone-skip-unstable mp2-clone-skip-unstable
+  svn co https://svn.apache.org/repos/asf/perl/modperl/branches/mybranch
 
 change externals to point to the new A-T branch (if one was done)
 
   svn propedit svn:externals .
 
-#######################################
-### sync the branch with the trunk  ###
-#######################################
+initialize svnmerge tracking in the branch (if you plan to pull trunk/ changes into the branch)
 
-the branch was created @r165203
+mybranch/ $> svnmerge init
+property 'svnmerge-integrated' set on '.'
+mybranch/ $> svn ci -F svnmerge-commit-message.txt 
 
-  svn co https://svn.apache.org/repos/asf/perl/modperl/branches/clone-skip-unstable \
-         mp2-clone-skip-unstable
-  cd mp2-clone-skip-unstable
-  svn propset merge-point 165203 .
-  build/svn.remerge
 
-now resolve any conflicts and commit the changes
+initialize svnmerge tracking on the trunk:
 
-from now on, all you need to do is to run:
+trunk/ $> svnmerge init https://svn.apache.org/repos/asf/perl/modperl/branches/mybranch
+property 'svnmerge-integrated' set on '.'
+mybranch/ $> svn ci -F svnmerge-commit-message.txt
 
-    build/svn.remerge
 
-as it automatically sets the merge-point during the last run
+##############################################
+### merging changes from branch to brahch  ###
+##############################################
 
+Work from a clean checkout of the branch you want to merge *to*
 
-#######################################
-### merge the branch into the trunk ###
-#######################################
+Check on the availability of changes to merge
 
+$> svnmerge avail -b -l
+
+------------------------------------------------------------------------
+r584362 | gozer | 2007-10-12 21:00:47 -0700 (Fri, 12 Oct 2007) | 1 line
+Changed paths:
+   A /perl/modperl/branches/mybranch (from /perl/modperl/trunk:584361)
+
+creating mybranch
+------------------------------------------------------------------------
+r584363 | gozer | 2007-10-12 21:05:32 -0700 (Fri, 12 Oct 2007) | 3 lines
+Changed paths:
+   M /perl/modperl/branches/mybranch
+
+Initialized merge tracking via "svnmerge" with revisions "1-584361" from 
+https://svn.apache.org/repos/asf/perl/modperl/trunk
+
+Then merge the ones you want to merge
+
+$> svnmerge -r 584362-584363
+
+review the changes, fix conflicts, etc
+
+Check in the merged version
+
+$> svn ci -F svnmerge-commit-message.txt
+
Index: build/svn.remerge
===================================================================
--- build/svn.remerge	(.../tags/2_0_3)	(revision 630610)
+++ build/svn.remerge	(.../trunk)	(revision 630610)
@@ -1,28 +0,0 @@
-#!/bin/bash
-# automatic SVN merging
-#
-# when used for the first time, first run:
-#  svn propset merge-point $revision
-# where $revision is the rev number when a branch was made
-
-root=`svn info . | perl -007 -ne 'm|URL: (.*?)/branches|s and print $1'`
-trunk=${root}/trunk
-
-# svn 1.2.x supports "svn info URL".  Without that, a stupid
-# ls command is needed to find the current revision of the trunk
-#next=`svn info $trunk | sed -n '/^Revision: /{s/.*: //g;p}'`
-
-next=`svn ls --verbose $root | perl -ne 'm|^\s+(\d+).*trunk/$| and print $1'`
-last=`svn propget merge-point .`
-
-echo "$0: merging from trunk from r$last to r$next"
-
-echo + svn merge -r$last:$next $trunk .
-svn merge -r$last:$next $trunk .
-echo + svn propset merge-point $next
-svn propset merge-point $next .
-last=$((last + 1))
-echo Merge r$last to r$next from trunk: > clog
-echo >> clog
-echo + svn log -r$last:$next $trunk
-svn log -r$last:$next $trunk | sed '/^------/,/^$/d' >> clog
Index: README-SVN
===================================================================
--- README-SVN	(.../tags/2_0_3)	(revision 630610)
+++ README-SVN	(.../trunk)	(revision 630610)
@@ -28,7 +28,7 @@
 
 DEVELOPER ACCESS
 
-assuming you have already been granted commit access to the repository,
+assuming that you have already been granted commit access to the repository,
 you should follow the following steps to checkout mod_perl
 
 Change your password via:
Index: t/apr-ext/threadrwlock.t
===================================================================
--- t/apr-ext/threadrwlock.t	(.../tags/2_0_3)	(revision 0)
+++ t/apr-ext/threadrwlock.t	(.../trunk)	(revision 630610)
@@ -0,0 +1,11 @@
+#!perl -T
+
+use strict;
+use warnings FATAL => 'all';
+use Apache::Test;
+
+use TestAPRlib::threadrwlock;
+
+plan tests => TestAPRlib::threadrwlock::num_of_tests(), need_threads;
+
+TestAPRlib::threadrwlock::test();
Index: t/apr-ext/perlio.t
===================================================================
--- t/apr-ext/perlio.t	(.../tags/2_0_3)	(revision 630610)
+++ t/apr-ext/perlio.t	(.../trunk)	(revision 630610)
@@ -25,7 +25,7 @@
 # prerequisite
 # also need to check whether we build against the source tree, in
 # which case we APR.so won't be linked against libapr/libaprutil
-my $has_apr_config = $build->{apr_config_path} && 
+my $has_apr_config = $build->{apr_config_path} &&
     !$build->httpd_is_source_tree;
 
 my $has_perlio_layers = 0;
@@ -230,11 +230,11 @@
 }
 
 
-# XXX: need tests 
+# XXX: need tests
 # - for stdin/out/err as they are handled specially
 
 # XXX: tmpfile is missing:
-# consider to use 5.8's syntax: 
+# consider to use 5.8's syntax:
 #   open $fh, "+>", undef;
 
 # cleanup: t_mkdir will remove the whole tree including the file
Index: t/apr-ext/uuid.t
===================================================================
--- t/apr-ext/uuid.t	(.../tags/2_0_3)	(revision 630610)
+++ t/apr-ext/uuid.t	(.../trunk)	(revision 630610)
@@ -16,7 +16,7 @@
 #######
 # my $build = Apache2::Build->build_config;
 #
-# my $has_apr_config = $build->{apr_config_path} && 
+# my $has_apr_config = $build->{apr_config_path} &&
 #    !$build->httpd_is_source_tree;
 # plan tests => TestAPRlib::uuid::num_of_tests(),
 #    need {"the build couldn't find apr-config" => $has_apr_config};
Index: t/apache/content_length_header.t
===================================================================
--- t/apache/content_length_header.t	(.../tags/2_0_3)	(revision 630610)
+++ t/apache/content_length_header.t	(.../trunk)	(revision 630610)
@@ -72,13 +72,13 @@
         ## to protect against wierd SVN checkout building.
         ## XXX: I'm starting to think this test is more
         ## trouble then its worth.
-        if (have_min_apache_version("2.2.1")) { 
+        if (have_min_apache_version("2.2.1")) {
           $head_cl = 25;
         }
         elsif (have_min_apache_version("2.2.0")) {
           # $head_cl = undef; # avoid warnings
         }
-        elsif (have_min_apache_version("2.0.56")) { 
+        elsif (have_min_apache_version("2.0.56")) {
           $head_cl = 25;
         }
         else {
Index: t/apache/constants.t
===================================================================
--- t/apache/constants.t	(.../tags/2_0_3)	(revision 630610)
+++ t/apache/constants.t	(.../trunk)	(revision 630610)
@@ -8,7 +8,7 @@
 # -compile puts constants into the Apache2:: namespace
 use Apache2::Const -compile => qw(:http :common :mpmq :proxy
                                   TAKE23 &OPT_EXECCGI
-                                  DECLINE_CMD DIR_MAGIC_TYPE 
+                                  DECLINE_CMD DIR_MAGIC_TYPE
                                   CRLF);
 
 # without -compile, constants are in the
@@ -29,11 +29,11 @@
 
 ok t_cmp(Apache2::Const::HTTP_GONE, 410, 'Apache2::Const::HTTP_GONE');
 
-ok t_cmp(Apache2::Const::DIR_MAGIC_TYPE, 
+ok t_cmp(Apache2::Const::DIR_MAGIC_TYPE,
          'httpd/unix-directory',
          'Apache2::Const::DIR_MAGIC_TYPE');
 
-ok t_cmp(Apache2::Const::MPMQ_MAX_SPARE_DAEMONS, 
+ok t_cmp(Apache2::Const::MPMQ_MAX_SPARE_DAEMONS,
          9,
          'Apache2::Const::MPMQ_MAX_SPARE_DAEMONS');
 
Index: t/apr/pool_lifetime.t
===================================================================
--- t/apr/pool_lifetime.t	(.../tags/2_0_3)	(revision 630610)
+++ t/apr/pool_lifetime.t	(.../trunk)	(revision 630610)
@@ -4,26 +4,20 @@
 use Apache::Test;
 use Apache::TestUtil;
 use Apache::TestRequest;
-use TestCommon::SameInterp;
+Apache::TestRequest::user_agent(keep_alive => 1);
 
 plan tests => 2, need 'HTML::HeadParser';
 
 my $module   = 'TestAPR::pool_lifetime';
 my $location = '/' . Apache::TestRequest::module2path($module);
 
-t_debug "getting the same interp ID for $location";
-my $same_interp = Apache::TestRequest::same_interp_tie($location);
-
-my $skip = $same_interp ? 0 : 1;
-
 for (1..2) {
     my $expected = "Pong";
-    my $received = same_interp_req_body($same_interp, \&GET, $location);
-    $skip++ unless defined $received;
-    same_interp_skip_not_found(
-        $skip,
+    my $received = GET $location;
+
+    ok t_cmp(
+        $received->content,
         $expected,
-        $received,
-        "Pong"
+        "Pong",
     );
 }

Property changes on: t/apr
___________________________________________________________________
Name: svn:ignore
   - base64.t
brigade.t
bucket.t
constants.t
date.t
finfo.t
flatten.t
lib.t
ipsubnet.t
os.t
perlio.t
pool.t
status.t
sockaddr.t
socket.t
string.t
table.t
threadmutex.t
uri.t
util.t
uuid.t

   + base64.t
brigade.t
bucket.t
constants.t
date.t
finfo.t
flatten.t
lib.t
ipsubnet.t
os.t
perlio.t
pool.t
status.t
sockaddr.t
socket.t
string.t
table.t
threadmutex.t
threadrwlock.t
uri.t
util.t
uuid.t


Index: t/hooks/TestHooks/cleanup2.pm
===================================================================
--- t/hooks/TestHooks/cleanup2.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/hooks/TestHooks/cleanup2.pm	(.../trunk)	(revision 630610)
@@ -19,7 +19,7 @@
 use Apache2::Const -compile => qw(OK DECLINED);
 use APR::Const    -compile => 'SUCCESS';
 
-my $file = catfile Apache::Test::config->{vars}->{documentroot}, 
+my $file = catfile Apache::Test::config->{vars}->{documentroot},
     "hooks", "cleanup2";
 
 sub handler {
Index: t/hooks/TestHooks/push_handlers_anon.pm
===================================================================
--- t/hooks/TestHooks/push_handlers_anon.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/hooks/TestHooks/push_handlers_anon.pm	(.../trunk)	(revision 630610)
@@ -46,9 +46,9 @@
     <Perl >
     my $s = Apache2::PerlSections->server;
 
-    $s->push_handlers(PerlFixupHandler => 
+    $s->push_handlers(PerlFixupHandler =>
                        sub { &TestHooks::push_handlers_anon::add_note });
-    $s->push_handlers(PerlFixupHandler => 
+    $s->push_handlers(PerlFixupHandler =>
                        \&TestHooks::push_handlers_anon::add_note       );
     $s->push_handlers(PerlFixupHandler =>
                       "TestHooks::push_handlers_anon::add_note"        );
Index: t/hooks/TestHooks/stacked_handlers2.pm
===================================================================
--- t/hooks/TestHooks/stacked_handlers2.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/hooks/TestHooks/stacked_handlers2.pm	(.../trunk)	(revision 630610)
@@ -1,6 +1,6 @@
 package TestHooks::stacked_handlers2;
 
-# this test exercises the execution of the stacked handlers 
+# this test exercises the execution of the stacked handlers
 # connection, translation, authen, authz, type, and response
 # phases should end for the first handler that returns OK
 
@@ -17,28 +17,28 @@
 
 use Apache2::Const -compile => qw(OK DECLINED AUTH_REQUIRED SERVER_ERROR);
 
-sub ok { 
+sub ok {
 
     callback(shift);
 
     return Apache2::Const::OK;
 }
 
-sub declined { 
+sub declined {
 
     callback(shift);
 
     return Apache2::Const::DECLINED;
 }
 
-sub auth_required { 
+sub auth_required {
 
     callback(shift);
 
     return Apache2::Const::AUTH_REQUIRED;
 }
 
-sub server_error { 
+sub server_error {
 
     callback(shift);
 
@@ -88,9 +88,9 @@
     foreach my $callback (qw(PerlPostReadRequestHandler
                              PerlTransHandler
                              PerlMapToStorageHandler
-                             PerlHeaderParserHandler 
-                             PerlAccessHandler 
-                             PerlAuthenHandler 
+                             PerlHeaderParserHandler
+                             PerlAccessHandler
+                             PerlAuthenHandler
                              PerlAuthzHandler
                              PerlTypeHandler
                              PerlFixupHandler
@@ -165,14 +165,14 @@
         PerlHeaderParserHandler TestHooks::stacked_handlers2::declined TestHooks::stacked_handlers2::ok
 
         # all 2 run
-        PerlAccessHandler TestHooks::stacked_handlers2::ok TestHooks::stacked_handlers2::ok 
+        PerlAccessHandler TestHooks::stacked_handlers2::ok TestHooks::stacked_handlers2::ok
 
         # 2 run, 1 left behind
-        PerlAuthenHandler TestHooks::stacked_handlers2::declined TestHooks::stacked_handlers2::ok 
+        PerlAuthenHandler TestHooks::stacked_handlers2::declined TestHooks::stacked_handlers2::ok
         PerlAuthenHandler TestHooks::stacked_handlers2::auth_required
 
         # 2 run, 1 left behind
-        PerlAuthzHandler TestHooks::stacked_handlers2::declined TestHooks::stacked_handlers2::ok 
+        PerlAuthzHandler TestHooks::stacked_handlers2::declined TestHooks::stacked_handlers2::ok
         PerlAuthzHandler TestHooks::stacked_handlers2::auth_required
 
         # 1 run, 1 left behind
@@ -183,7 +183,7 @@
         PerlFixupHandler TestHooks::stacked_handlers2::push_handlers
 
         # 2 run, 2 left behind
-        PerlResponseHandler TestHooks::stacked_handlers2::declined TestHooks::stacked_handlers2 
+        PerlResponseHandler TestHooks::stacked_handlers2::declined TestHooks::stacked_handlers2
         PerlResponseHandler TestHooks::stacked_handlers2::ok TestHooks::stacked_handlers2::server_error
 
         SetHandler modperl
Index: t/hooks/TestHooks/push_handlers_same_phase.pm
===================================================================
--- t/hooks/TestHooks/push_handlers_same_phase.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/hooks/TestHooks/push_handlers_same_phase.pm	(.../trunk)	(revision 630610)
@@ -1,6 +1,6 @@
 package TestHooks::push_handlers_same_phase;
 
-# test that we 
+# test that we
 # - can push handlers into the same phase that is currently running
 # - cannot switch 'perl-script' to 'modperl' and vice versa once
 #   inside the response phase
Index: t/hooks/TestHooks/authz.pm
===================================================================
--- t/hooks/TestHooks/authz.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/hooks/TestHooks/authz.pm	(.../trunk)	(revision 630610)
@@ -16,8 +16,8 @@
     unless($r->user and $sent_pw) {
         # testing $r->note_auth_failure:
         # AuthType Basic + note_auth_failure == note_basic_auth_failure;
-	$r->note_auth_failure;
-	return Apache2::Const::HTTP_UNAUTHORIZED;
+        $r->note_auth_failure;
+        return Apache2::Const::HTTP_UNAUTHORIZED;
     }
 
     return Apache2::Const::OK;
Index: t/hooks/TestHooks/push_handlers.pm
===================================================================
--- t/hooks/TestHooks/push_handlers.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/hooks/TestHooks/push_handlers.pm	(.../trunk)	(revision 630610)
@@ -17,7 +17,7 @@
     $r->handler("modperl");
 
     $r->push_handlers(PerlResponseHandler => \&coderef);
-    $r->push_handlers(PerlResponseHandler => 
+    $r->push_handlers(PerlResponseHandler =>
         \&TestHooks::push_handlers::full_coderef);
 
     $r->push_handlers(PerlResponseHandler =>
Index: t/hooks/TestHooks/inlined_handlers.pm
===================================================================
--- t/hooks/TestHooks/inlined_handlers.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/hooks/TestHooks/inlined_handlers.pm	(.../trunk)	(revision 630610)
@@ -5,10 +5,6 @@
 # previously there was a bug in non-ithreaded-perl implementation
 # where the cached compiled CODE ref didn't have the reference count
 # right.
-#
-# this test needs to run via the same_interpr framework, since it must
-# test that the same perl interprter/process gets to run the same
-# inlined handler
 
 use strict;
 use warnings FATAL => 'all';
@@ -30,7 +26,6 @@
 <NoAutoConfig>
   <Location /TestHooks__inlined_handlers>
       SetHandler modperl
-      PerlInitHandler     Apache::TestHandler::same_interp_fixup
       PerlFixupHandler    'sub { use Apache2::Const qw(DECLINED); DECLINED }'
       PerlResponseHandler TestHooks::inlined_handlers
   </Location>
Index: t/hooks/push_handlers.t
===================================================================
--- t/hooks/push_handlers.t	(.../tags/2_0_3)	(revision 630610)
+++ t/hooks/push_handlers.t	(.../trunk)	(revision 630610)
@@ -7,7 +7,7 @@
 
 plan tests => 1;
 
-my @refs = qw(conf conf1 conf2 coderef 
+my @refs = qw(conf conf1 conf2 coderef
              full_coderef coderef1 coderef2 coderef3);
 my @anon = qw(anonymous anonymous1 coderef4 anonymous3);
 
Index: t/hooks/inlined_handlers.t
===================================================================
--- t/hooks/inlined_handlers.t	(.../tags/2_0_3)	(revision 630610)
+++ t/hooks/inlined_handlers.t	(.../trunk)	(revision 630610)
@@ -10,19 +10,14 @@
 
 my $location = "/TestHooks__inlined_handlers";
 
-t_debug "getting the same interp ID for $location";
-my $same_interp = Apache::TestRequest::same_interp_tie($location);
-
-my $skip = $same_interp ? 0 : 1;
 my $expected = "ok";
 for (1..2) {
-    my $received = same_interp_req_body($same_interp, \&GET, $location);
-    $skip++ unless defined $received;
-    same_interp_skip_not_found(
-        $skip,
-        $received,
+    my $received = GET $location;
+
+    ok t_cmp(
+        $received->content,
         $expected,
-        "anonymous handlers in httpd.conf test"
+        "anonymous handlers in httpd.conf test",
     );
 }
 
Index: t/filter/out_str_req_mix.t
===================================================================
--- t/filter/out_str_req_mix.t	(.../tags/2_0_3)	(revision 630610)
+++ t/filter/out_str_req_mix.t	(.../trunk)	(revision 630610)
@@ -15,5 +15,5 @@
 my $received = POST_BODY $location, content => $content;
 $received =~ s{\r?\n$}{};
 
-ok t_cmp($expected, $received, 
+ok t_cmp($expected, $received,
     "mixing output httpd and mod_perl filters, while preserving order");
Index: t/filter/TestFilter/out_str_subreq_default.pm
===================================================================
--- t/filter/TestFilter/out_str_subreq_default.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/filter/TestFilter/out_str_subreq_default.pm	(.../trunk)	(revision 630610)
@@ -15,7 +15,7 @@
 use Apache2::Const -compile => qw(OK);
 
 # include the contents of a subrequest
-# in the filter, a la mod_include's 
+# in the filter, a la mod_include's
 # <!--#include virtual="/subrequest" -->
 
 sub include {
Index: t/filter/TestFilter/out_str_reverse.pm
===================================================================
--- t/filter/TestFilter/out_str_reverse.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/filter/TestFilter/out_str_reverse.pm	(.../trunk)	(revision 630610)
@@ -49,9 +49,9 @@
     $r->content_type('text/plain');
 
     # unbuffer stdout, so we get the data split across several bbs
-    local $_ = 1; 
+    local $_ = 1;
     if ($r->method_number == Apache2::Const::M_POST) {
-        my $data = TestCommon::Utils::read_post($r); 
+        my $data = TestCommon::Utils::read_post($r);
         $r->print($_) for grep length $_, split /(.{5})/, $data;
     }
 
Index: t/filter/TestFilter/with_subrequest.pm
===================================================================
--- t/filter/TestFilter/with_subrequest.pm	(.../tags/2_0_3)	(revision 0)
+++ t/filter/TestFilter/with_subrequest.pm	(.../trunk)	(revision 630610)
@@ -0,0 +1,38 @@
+package TestFilter::with_subrequest;
+
+use strict;
+use warnings FATAL => 'all';
+
+use Apache2::Filter ();
+use Apache2::SubRequest ();
+
+use TestCommon::Utils;
+
+use Apache2::Const -compile => 'OK';
+
+sub handler {
+    my $f = shift;
+    my $r = $f->r;
+
+    my $subr;
+    while ($f->read(my $buffer, 1024)) {
+        $f->print(lc $buffer);
+	if (!$subr) {
+            $subr = $r->lookup_uri($r->uri);
+            my $rc = $subr->run;
+        }
+    }
+
+    Apache2::Const::OK;
+}
+
+1;
+__DATA__
+
+<Location /with_subrequest>
+  PerlOutputFilterHandler TestFilter::with_subrequest
+</Location>
+
+<IfModule mod_alias.c>
+    Alias /with_subrequest @top_dir@
+</IfModule>
Index: t/filter/TestFilter/out_str_declined.pm
===================================================================
--- t/filter/TestFilter/out_str_declined.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/filter/TestFilter/out_str_declined.pm	(.../trunk)	(revision 630610)
@@ -34,7 +34,7 @@
 
 # this filter ignores all the data that comes through, though on the
 # last invocation it prints how many times the filter 'decline' was called
-# which it could count by itself, but we want to test that 
+# which it could count by itself, but we want to test that
 # 'return Apache2::Const::DECLINED' works properly in output filters
 sub black_hole {
     my $filter = shift;
Index: t/filter/TestFilter/in_bbs_inject_header.pm
===================================================================
--- t/filter/TestFilter/in_bbs_inject_header.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/filter/TestFilter/in_bbs_inject_header.pm	(.../trunk)	(revision 630610)
@@ -188,7 +188,7 @@
             # normally the body will start coming in the next call to
             # get_brigade, so if your filter only wants to work with
             # the headers, it can decline all other invocations if that
-            # flag is set. However since in this test we need to send 
+            # flag is set. However since in this test we need to send
             # a few extra bucket brigades, we will turn another flag
             # 'done_with_headers' when 'seen_body_separator' is on and
             # all headers were sent out
@@ -232,7 +232,7 @@
 
     # propogate the input headers and the input back to the client
     # as we need to do the validations on the client side
-    $r->headers_out->set($header1_key => 
+    $r->headers_out->set($header1_key =>
                          $r->headers_in->get($header1_key)||'');
 
     for my $key (sort keys %headers) {
Index: t/filter/TestFilter/out_str_subreq_modperl.pm
===================================================================
--- t/filter/TestFilter/out_str_subreq_modperl.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/filter/TestFilter/out_str_subreq_modperl.pm	(.../trunk)	(revision 630610)
@@ -15,7 +15,7 @@
 use Apache2::Const -compile => qw(OK);
 
 # include the contents of a subrequest
-# in the filter, a la mod_include's 
+# in the filter, a la mod_include's
 # <!--#include virtual="/subrequest" -->
 
 sub include {
Index: t/filter/with_subrequest.t
===================================================================
--- t/filter/with_subrequest.t	(.../tags/2_0_3)	(revision 0)
+++ t/filter/with_subrequest.t	(.../trunk)	(revision 630610)
@@ -0,0 +1,13 @@
+use strict;
+use warnings FATAL => 'all';
+
+use Apache::Test;
+use Apache::TestRequest;
+
+plan tests => 1, need 'mod_alias';
+
+my $location = "/with_subrequest/Makefile";
+
+my $str = GET_BODY $location;
+
+ok $str !~ /[A-Z]/;
Index: t/conf/modperl_extra.pl
===================================================================
--- t/conf/modperl_extra.pl	(.../tags/2_0_3)	(revision 630610)
+++ t/conf/modperl_extra.pl	(.../trunk)	(revision 630610)
@@ -19,7 +19,7 @@
 use warnings FATAL => 'all';
 
 die '$ENV{MOD_PERL} not set!' unless $ENV{MOD_PERL};
-die '$ENV{MOD_PERL_API_VERSION} not set!' 
+die '$ENV{MOD_PERL_API_VERSION} not set!'
     unless $ENV{MOD_PERL_API_VERSION} == 2;
 
 use File::Spec::Functions qw(canonpath catdir);
Index: t/response/TestApache/conftree.pm
===================================================================
--- t/response/TestApache/conftree.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestApache/conftree.pm	(.../trunk)	(revision 630610)
@@ -45,7 +45,7 @@
     #XXX: This test isn't so good, but its quite problematic to try
     #and _really_ compare $cfg and $tree...
     {
-        my %vhosts = map { 
+        my %vhosts = map {
             $cfg->{vhosts}{$_}{name} => { %{$cfg->{vhosts}{$_}}, index => $_ }
         } keys %{$cfg->{vhosts}};
 
@@ -55,7 +55,7 @@
 
         my $vhost_failed;
         for my $vhost ($tree->lookup("VirtualHost")) {
-            unless (exists $vhosts{$vhost->{'ServerName'} 
+            unless (exists $vhosts{$vhost->{'ServerName'}
                 || $vhost->{'PerlProcessConnectionHandler'}}) {
                 $vhost_failed++;
             }
@@ -87,7 +87,7 @@
         $sub->($data, $node);
         if (my $kid = $node->first_child) {
             $node = $kid;
-        } 
+        }
         elsif (my $next = $node->next) {
             $node = $next;
         }
Index: t/response/TestAPR/pool_lifetime.pm
===================================================================
--- t/response/TestAPR/pool_lifetime.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestAPR/pool_lifetime.pm	(.../trunk)	(revision 630610)
@@ -23,5 +23,3 @@
 }
 
 1;
-__END__
-PerlFixupHandler Apache::TestHandler::same_interp_fixup
Index: t/response/TestAPR/threadrwlock.pm
===================================================================
--- t/response/TestAPR/threadrwlock.pm	(.../tags/2_0_3)	(revision 0)
+++ t/response/TestAPR/threadrwlock.pm	(.../trunk)	(revision 630610)
@@ -0,0 +1,24 @@
+package TestAPR::threadrwlock;
+
+use strict;
+use warnings FATAL => 'all';
+
+use Apache::Test;
+use Apache::TestUtil;
+
+use Apache2::Const -compile => 'OK';
+
+use TestAPRlib::threadrwlock;
+
+sub handler {
+    my $r = shift;
+
+    my $tests = TestAPRlib::threadrwlock::num_of_tests();
+    plan $r, tests => $tests, need_threads;
+
+    TestAPRlib::threadrwlock::test();
+
+    Apache2::Const::OK;
+}
+
+1;
Index: t/response/TestAPR/perlio.pm
===================================================================
--- t/response/TestAPR/perlio.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestAPR/perlio.pm	(.../trunk)	(revision 630610)
@@ -22,7 +22,7 @@
 # apr_file_dup has a bug on win32,
 # should be fixed in apr 0.9.4 / httpd-2.0.48
 require Apache2::Build;
-use constant APR_WIN32_FILE_DUP_BUG => 
+use constant APR_WIN32_FILE_DUP_BUG =>
     Apache2::Build::WIN32() && !have_min_apache_version('2.0.48');
 
 sub handler {
@@ -224,7 +224,7 @@
     # tests reading and writing text and binary files
     {
         for my $file ('MoonRise.jpeg', 'redrum.txt') {
-            my $in = catfile $dir, $file; 
+            my $in = catfile $dir, $file;
             my $out = catfile $dir, "$file.out";
             my ($apr_content, $perl_content);
             open my $rfh, "<:APR", $in, $r->pool
@@ -331,11 +331,11 @@
         unlink $scratch;
     }
 
-    # XXX: need tests 
+    # XXX: need tests
     # - for stdin/out/err as they are handled specially
 
     # XXX: tmpfile is missing:
-    # consider to use 5.8's syntax: 
+    # consider to use 5.8's syntax:
     #   open $fh, "+>", undef;
 
     # cleanup: t_mkdir will remove the whole tree including the file
Index: t/response/TestModperl/sameinterp.pm
===================================================================
--- t/response/TestModperl/sameinterp.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestModperl/sameinterp.pm	(.../trunk)	(revision 630610)
@@ -1,26 +0,0 @@
-package TestModperl::sameinterp;
-
-use warnings FATAL => 'all';
-use strict;
-
-use Apache2::RequestIO ();
-
-use Apache::TestHandler ();
-
-use Apache2::Const -compile => qw(OK);
-
-my $value = '';
-
-sub handler {
-    my $r = shift;
-
-    # test the actual global data
-    $value = Apache::TestHandler::same_interp_counter();
-    $r->puts($value);
-
-    Apache2::Const::OK;
-}
-
-1;
-__END__
-PerlFixupHandler Apache::TestHandler::same_interp_fixup
Index: t/response/TestModperl/pnotes.pm
===================================================================
--- t/response/TestModperl/pnotes.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestModperl/pnotes.pm	(.../trunk)	(revision 630610)
@@ -16,7 +16,7 @@
 
     # make it ok to call ok() here while plan()ing elsewhere
     Apache::Test::init_test_pm($r);
-    
+
     Test::_reset_globals() if Test->can('_reset_globals');
     $Test::ntest   = 1 + (26 * ($r->args - 1));
     $Test::planned = 26;
@@ -102,7 +102,7 @@
         else {
           skip ('skipping $dbh retrival test - no DBI or DBD::DBM');
           skip ('skipping $dbh->quote() test - no DBI or DBD::DBM');
-        } 
+        }
     }
 
     # set pnotes so we can test unset on later connections
Index: t/response/TestModperl/pnotes2.pm
===================================================================
--- t/response/TestModperl/pnotes2.pm	(.../tags/2_0_3)	(revision 0)
+++ t/response/TestModperl/pnotes2.pm	(.../trunk)	(revision 630610)
@@ -0,0 +1,89 @@
+package TestModperl::pnotes2;
+
+use strict;
+use warnings FATAL => 'all';
+
+use Apache2::Log ();
+use Apache2::RequestUtil ();
+use Apache2::ConnectionUtil ();
+
+use Apache2::Const -compile => 'OK';
+
+{
+    package TestModerl::pnotes2::x;
+    use strict;
+    use warnings FATAL => 'all';
+
+    sub new {shift;bless [@_];}
+    sub DESTROY {my $f=shift @{$_[0]}; $f->(@{$_[0]});}
+}
+
+sub line {
+    our $cleanup;
+
+    Apache2::ServerRec::warn "pnotes are destroyed after cleanup ".$cleanup;
+}
+
+sub cleanup {
+    our $cleanup;
+    $cleanup='passed';
+
+    return Apache2::Const::OK;
+}
+
+sub handler {
+    my $r = shift;
+
+    our $cleanup;
+    $cleanup='';
+
+    $r->push_handlers( PerlCleanupHandler=>__PACKAGE__.'::cleanup' );
+
+    if(!defined $r->args) {
+    } elsif($r->args == 1) {
+        $r->pnotes(x1 => TestModerl::pnotes2::x->new(\&line));
+    } elsif($r->args == 2) {
+        $r->pnotes->{x1} = TestModerl::pnotes2::x->new(\&line);
+    } elsif($r->args == 3) {
+        $r->pnotes(x1 => TestModerl::pnotes2::x->new(\&line));
+        $r->pnotes(x2 => 2);
+    } elsif($r->args == 4) {
+        $r->pnotes->{x1} = TestModerl::pnotes2::x->new(\&line);
+        $r->pnotes->{x2} = 2;
+    } elsif($r->args == 5) {
+        $r->pnotes(x1 => TestModerl::pnotes2::x->new(\&line));
+        $r->pnotes->{x2} = 2;
+    } elsif($r->args == 6) {
+        $r->pnotes->{x1} = TestModerl::pnotes2::x->new(\&line);
+        $r->pnotes(x2 => 2);
+    } elsif($r->args == 7) {
+        $r->connection->pnotes(x1 => TestModerl::pnotes2::x->new(\&line));
+    } elsif($r->args == 8) {
+        $r->connection->pnotes->{x1} = TestModerl::pnotes2::x->new(\&line);
+    } elsif($r->args == 9) {
+        $r->connection->pnotes(x1 => TestModerl::pnotes2::x->new(\&line));
+        $r->connection->pnotes(x2 => 2);
+    } elsif($r->args == 10) {
+        $r->connection->pnotes->{x1} = TestModerl::pnotes2::x->new(\&line);
+        $r->connection->pnotes->{x2} = 2;
+    } elsif($r->args == 11) {
+        $r->connection->pnotes(x1 => TestModerl::pnotes2::x->new(\&line));
+        $r->connection->pnotes->{x2} = 2;
+    } elsif($r->args == 12) {
+        $r->connection->pnotes->{x1} = TestModerl::pnotes2::x->new(\&line);
+        $r->connection->pnotes(x2 => 2);
+    }
+
+    $r->content_type('text/plain');
+    $r->print("OK");
+
+    Apache2::Const::OK;
+}
+
+1;
+__END__
+
+# Local Variables: #
+# mode: cperl #
+# cperl-indent-level: 4 #
+# End: #
Index: t/response/TestModperl/cookie2.pm
===================================================================
--- t/response/TestModperl/cookie2.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestModperl/cookie2.pm	(.../trunk)	(revision 630610)
@@ -44,6 +44,5 @@
 __DATA__
 SetHandler modperl
 PerlModule          TestModperl::cookie2
-PerlInitHandler     Apache::TestHandler::same_interp_fixup
 PerlAccessHandler   TestModperl::cookie2::access
 PerlResponseHandler TestModperl::cookie2
Index: t/response/TestModperl/perl_options2.pm
===================================================================
--- t/response/TestModperl/perl_options2.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestModperl/perl_options2.pm	(.../trunk)	(revision 630610)
@@ -52,7 +52,7 @@
 
     ok t_cmp($s->is_perl_option_enabled('Response'), 1,
              "Response is off under PerlOptions None");
-           
+
     return Apache2::Const::OK;
 }
 
Index: t/response/TestModperl/printf.pm
===================================================================
--- t/response/TestModperl/printf.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestModperl/printf.pm	(.../trunk)	(revision 630610)
@@ -31,7 +31,7 @@
     # ok 4 (gets input from the fixup handler via notes)
     {
         my $note = $r->notes->get("fixup") || '';
-        my $ok = $note =~ 
+        my $ok = $note =~
             /\$r->printf can't be called before the response phase/;
         $r->print("not ") unless $ok;
         $r->print("ok 4\n");
Index: t/response/TestModperl/subenv.pm
===================================================================
--- t/response/TestModperl/subenv.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestModperl/subenv.pm	(.../trunk)	(revision 630610)
@@ -32,7 +32,7 @@
         ok ! $ENV{$key};               # %ENV not populated yet
     }
 
-    # subprocess_env in void context with no arguments 
+    # subprocess_env in void context with no arguments
     # populates the same as +SetEnv
     {
         my $env = $r->subprocess_env;
Index: t/response/TestModperl/dir_config.pm
===================================================================
--- t/response/TestModperl/dir_config.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestModperl/dir_config.pm	(.../trunk)	(revision 630610)
@@ -16,7 +16,7 @@
 sub handler {
     my $r = shift;
 
-    plan $r, tests => 14;
+    plan $r, tests => 15;
 
     #Apache2::RequestRec::dir_config tests
 
@@ -28,6 +28,13 @@
     my $dir_config = $r->dir_config;
     ok defined $dir_config && ref($dir_config) eq 'APR::Table';
 
+    # make sure trying to get something that's not defined
+    # doesn't blow up
+    my $undef = $r->dir_config('EDOESNOTEXIST');
+
+    ok t_cmp($undef, undef,
+             'no PerlSetVar to get data from');
+
     # PerlAddVar ITERATE2 test
     {
         my $key = make_key('1');
Index: t/response/TestModperl/setupenv.pm
===================================================================
--- t/response/TestModperl/setupenv.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestModperl/setupenv.pm	(.../trunk)	(revision 630610)
@@ -321,7 +321,7 @@
         PerlSetEnv DIR_PERLSETENV psvoid
     </Location>
 
-    # equivalent to modperl handler with $r->subprocess_env() - 
+    # equivalent to modperl handler with $r->subprocess_env() -
     # CGI variables are there, but not subprocess_env entries
     # that are populated after the void call
     <Location /TestModperl__setupenv_psnosetupvoid>
Index: t/response/TestModperl/cookie.pm
===================================================================
--- t/response/TestModperl/cookie.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestModperl/cookie.pm	(.../trunk)	(revision 630610)
@@ -48,7 +48,6 @@
 __DATA__
 SetHandler perl-script
 PerlModule          TestModperl::cookie
-PerlInitHandler     Apache::TestHandler::same_interp_fixup
 PerlAccessHandler   TestModperl::cookie::access
 PerlResponseHandler TestModperl::cookie
 PerlOptions -SetupEnv
Index: t/response/TestModperl/method.pm
===================================================================
--- t/response/TestModperl/method.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestModperl/method.pm	(.../trunk)	(revision 630610)
@@ -40,7 +40,7 @@
 
     ok t_cmp(
         $r->uri,
-        '/' . Apache::TestRequest::module2path($class), 
+        '/' . Apache::TestRequest::module2path($class),
         '$r->uri eq $location');
 
     if ($is_obj) {
Index: t/response/TestModperl/request_rec_perlio_api.pm
===================================================================
--- t/response/TestModperl/request_rec_perlio_api.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestModperl/request_rec_perlio_api.pm	(.../trunk)	(revision 630610)
@@ -93,7 +93,7 @@
     # now close it completely and restore it, without using any dupped
     # filehandle
     close STDOUT;
-    open STDOUT, ">:Apache2", $r 
+    open STDOUT, ">:Apache2", $r
         or die "can't open STDOUT via :Apache2 layer : $!";
     print "next you reincarnate...";
 
Index: t/response/TestModperl/current_callback.pm
===================================================================
--- t/response/TestModperl/current_callback.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestModperl/current_callback.pm	(.../trunk)	(revision 630610)
@@ -33,7 +33,7 @@
 sub check {
     my $expected = 'Perl' . shift() . 'Handler';
     my $callback = ModPerl::Util::current_callback();
-    die "expecting $expected callback, instead got $callback" 
+    die "expecting $expected callback, instead got $callback"
         unless $callback eq $expected;
     #warn "in callback: $callback\n";
     return Apache2::Const::OK;
Index: t/response/TestModperl/local_env.pm
===================================================================
--- t/response/TestModperl/local_env.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestModperl/local_env.pm	(.../trunk)	(revision 630610)
@@ -22,16 +22,16 @@
 
     my %copy_ENV = %ENV;  ## this is not a deep copy;
 
-    ok t_cmp($ENV{MOD_PERL_API_VERSION}, 2, 
+    ok t_cmp($ENV{MOD_PERL_API_VERSION}, 2,
       "\$ENV{MOD_PERL_API_VERSION} is 2 before local \%ENV");
 
     {
       local %ENV;
 
-      ok t_cmp($ENV{MOD_PERL_API_VERSION}, undef, 
+      ok t_cmp($ENV{MOD_PERL_API_VERSION}, undef,
           "\$ENV{MOD_PERL_API_VERSION} is undef after local \%ENV");
 
-      ok t_cmp(scalar keys %ENV, 0, 
+      ok t_cmp(scalar keys %ENV, 0,
           "\%ENV has 0 keys after local");
 
       $ENV{LOCAL} = 1;
Index: t/response/TestPerl/hash_attack.pm
===================================================================
--- t/response/TestPerl/hash_attack.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestPerl/hash_attack.pm	(.../trunk)	(revision 630610)
@@ -92,7 +92,7 @@
         $stash->{$s}++;
         debug sprintf "%2d: %5s, %10s, %s", $c, $s, $h, scalar(%$stash);
         push @keys, $s;
-        debug "The hash collision attack has been successful" 
+        debug "The hash collision attack has been successful"
             if Internals::HvREHASH(%$stash);
     } continue {
         $s++;
Index: t/response/TestPerl/ithreads_eval.pm
===================================================================
--- t/response/TestPerl/ithreads_eval.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestPerl/ithreads_eval.pm	(.../trunk)	(revision 630610)
@@ -3,7 +3,7 @@
 # reproducing a bug in perl ithreads: [perl #34341]
 # https://rt.perl.org/rt3/Ticket/Display.html?id=34341
 #
-# $thr->join triggers the following leak: 
+# $thr->join triggers the following leak:
 # - due to to local $0, (its second MAGIC's MG_OBJ,
 #   you can see it in the output of Dump $0). This leak was first
 #   spotted in the RegistryCooker.pm which localizes $0
Index: t/response/TestPerl/ithreads.pm
===================================================================
--- t/response/TestPerl/ithreads.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestPerl/ithreads.pm	(.../trunk)	(revision 630610)
@@ -62,9 +62,9 @@
 
         $counter_priv += $counter_priv for 1..10;
         {
-	    lock $counter_shar;
-	    $counter_shar += $counter_shar for 1..10;
-	}
+            lock $counter_shar;
+            $counter_shar += $counter_shar for 1..10;
+        }
 
         $thr->join;
         ok t_cmp($counter_shar, 2**20, "shared counter");
Index: t/response/TestCompat/apache.pm
===================================================================
--- t/response/TestCompat/apache.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestCompat/apache.pm	(.../trunk)	(revision 630610)
@@ -128,6 +128,5 @@
 __END__
 # so we can test whether send_httpd_header() works fine
 PerlOptions +ParseHeaders +GlobalRequest
-AllowOverride Options
 PerlModule TestCompat::apache
 PerlFixupHandler TestCompat::apache::fixup
Index: t/response/TestModules/reload.pm
===================================================================
--- t/response/TestModules/reload.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestModules/reload.pm	(.../trunk)	(revision 630610)
@@ -1,50 +0,0 @@
-package TestModules::reload;
-
-use strict;
-use warnings FATAL => 'all';
-
-use ModPerl::Util ();
-
-use Apache2::Const -compile => qw(OK);
-
-my $package = 'Apache2::Reload::Test';
-
-our $pass = 0;
-
-sub handler {
-    my $r = shift;
-    $pass++;
-    if ($r->args eq 'last') {
-        Apache2::Reload->unregister_module($package);
-        ModPerl::Util::unload_package($package);
-        $pass = 0;
-        $r->print("unregistered OK");
-        return Apache2::Const::OK;
-    }
-
-    eval "use $package";
-
-    Apache2::Reload::Test::run($r);
-
-    return Apache2::Const::OK;
-}
-
-#This one shouldn't be touched
-package Apache2::Reload::Test::SubPackage;
-
-sub subpackage { 
-    if ($TestModules::reload::pass == '2') {
-        return 'subpackage';
-    }
-    else {
-        return 'SUBPACKAGE';
-    }
-}
-
-1;
-__END__
-
-PerlModule Apache2::Reload
-PerlInitHandler Apache::TestHandler::same_interp_fixup Apache2::Reload
-PerlSetVar ReloadDebug Off
-PerlSetVar ReloadAll Off
Index: t/response/TestAPI/request_rec.pm
===================================================================
--- t/response/TestAPI/request_rec.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestAPI/request_rec.pm	(.../trunk)	(revision 630610)
@@ -24,7 +24,7 @@
 sub handler {
     my $r = shift;
 
-    plan $r, tests => 54;
+    plan $r, tests => 55;
 
     #Apache2::RequestUtil->request($r); #PerlOptions +GlobalRequest takes care
     my $gr = Apache2::RequestUtil->request;
@@ -127,6 +127,13 @@
         ok t_cmp $r->the_request, "GET $base_uri$path_info?$args HTTP/1.0",
             '$r->the_request';
 
+        {
+            my $new_request = "GET $base_uri$path_info?$args&foo=bar HTTP/1.0";
+            my $old_request = $r->the_request($new_request);
+            ok t_cmp $r->the_request, $new_request, '$r->the_request rw';
+            $r->the_request($old_request);
+        }
+
         ok $r->filename;
 
         my $location = '/' . Apache::TestRequest::module2path(__PACKAGE__);
Index: t/response/TestAPI/status.pm
===================================================================
--- t/response/TestAPI/status.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestAPI/status.pm	(.../trunk)	(revision 630610)
@@ -22,7 +22,7 @@
     if ($string) {
         # status_line must be valid and match status
         # or it is 'zapped' by httpd as of 2.2.1
-        $r->status($code); 
+        $r->status($code);
         $r->status_line("$code $string");
     }
     else {
Index: t/response/TestAPI/access2.pm
===================================================================
--- t/response/TestAPI/access2.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestAPI/access2.pm	(.../trunk)	(revision 630610)
@@ -55,7 +55,7 @@
     return $rc if $rc != Apache2::Const::OK;
 
     # extract just the requirement entries
-    my %require = 
+    my %require =
         map { my ($k, $v) = split /\s+/, $_->{requirement}, 2; ($k, $v||'') }
         @{ $r->requires };
     debug \%require;
Index: t/response/TestAPI/uri.pm
===================================================================
--- t/response/TestAPI/uri.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestAPI/uri.pm	(.../trunk)	(revision 630610)
@@ -104,7 +104,7 @@
     }
     {
         # this time include args and a pool object
-        my $curl = $r->construct_url(sprintf "%s?%s", $r->uri, $r->args, 
+        my $curl = $r->construct_url(sprintf "%s?%s", $r->uri, $r->args,
                                      $r->pool->new);
         t_debug("construct_url: $curl");
         t_debug("r->uri: ", $r->uri);
@@ -167,7 +167,7 @@
         ok t_cmp($puri->port, $port, "port");
 
         ok t_cmp($puri->unparse,
-                 "ftp://perl.apache.org:$port$path?$query#$fragment", 
+                 "ftp://perl.apache.org:$port$path?$query#$fragment",
                  "unparse");
     }
 
Index: t/response/TestAPI/server_util.pm
===================================================================
--- t/response/TestAPI/server_util.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestAPI/server_util.pm	(.../trunk)	(revision 630610)
@@ -110,7 +110,7 @@
 
     # no file argument gives ServerRoot
     {
-        my $server_root_relative = 
+        my $server_root_relative =
             Apache2::ServerUtil::server_root_relative($r->pool);
 
         ok t_filepath_cmp(canonpath($server_root_relative),
Index: t/response/TestAPI/server_const.pm
===================================================================
--- t/response/TestAPI/server_const.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestAPI/server_const.pm	(.../trunk)	(revision 630610)
@@ -24,7 +24,7 @@
 
     my $r = shift;
 
-    plan $r, tests => 3;
+    plan $r, tests => 5;
 
     # test Apache2::ServerUtil constant subroutines
 
@@ -36,10 +36,20 @@
              $built,
              'Apache2::ServerUtil::get_server_built()');
 
-    ok t_cmp(Apache2::ServerUtil::get_server_version,
+    ok t_cmp(Apache2::ServerUtil::get_server_description,
              $version,
+             'Apache2::ServerUtil::get_server_description()');
+
+    my $server_version = Apache2::ServerUtil::get_server_version;
+    ok t_cmp($version,
+             qr/^$server_version/,
              'Apache2::ServerUtil::get_server_version()');
 
+    my $server_banner = Apache2::ServerUtil::get_server_banner;
+    ok t_cmp($version,
+             qr/^$server_banner/,
+             'Apache2::ServerUtil::get_server_banner()');
+
     Apache2::Const::OK;
 }
 
Index: t/response/TestAPI/add_config.pm
===================================================================
--- t/response/TestAPI/add_config.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestAPI/add_config.pm	(.../trunk)	(revision 630610)
@@ -58,6 +58,14 @@
     };
     $r->pnotes(followsymlinks => "$@");
 
+    eval {
+        my $path="/a/path/to/somewhere";
+        $r->add_config(['PerlResponseHandler '.__PACKAGE__], -1, $path);
+        # now overwrite the path in place to see if the location pointer
+        # is really copied: see modperl_config_dir_create
+        $path=~tr[a-z][n-za-m];
+    };
+
     return Apache2::Const::DECLINED;
 }
 
@@ -82,7 +90,7 @@
     my ($self, $r) = @_;
     my $cf = $self->get_config($r->server);
 
-    plan $r, tests => 8;
+    plan $r, tests => 9;
 
     ok t_cmp $r->pnotes('add_config1'), qr/.+\n/;
     ok t_cmp $r->pnotes('add_config2'), (APACHE22 ? qr/.+\n/ : '');
@@ -102,6 +110,8 @@
     my $opts = APACHE22 ? Apache2::Const::OPT_SYM_LINKS : $expect;
     ok t_cmp $r->allow_override_opts, $opts;
 
+    ok t_cmp $r->location, '/a/path/to/somewhere';
+
     return Apache2::Const::OK;
 }
 
@@ -117,7 +127,6 @@
         <Directory @DocumentRoot@>
             AllowOverride All
         </Directory>
-        PerlResponseHandler TestAPI::add_config
         PerlMapToStorageHandler TestAPI::add_config::map2storage
         PerlFixupHandler TestAPI::add_config::fixup
     </VirtualHost>
Index: t/response/TestAPI/request_util.pm
===================================================================
--- t/response/TestAPI/request_util.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestAPI/request_util.pm	(.../trunk)	(revision 630610)
@@ -40,7 +40,7 @@
     }
     else {
         eval { $r->document_root('/tmp/foo') };
-        ok t_cmp($@, qr/Can't run.*in the threaded env/, 
+        ok t_cmp($@, qr/Can't run.*in the threaded env/,
                  "document_root is read-only under threads");
         ok 1;
     }
Index: t/response/TestError/api.pm
===================================================================
--- t/response/TestError/api.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestError/api.pm	(.../trunk)	(revision 630610)
@@ -21,7 +21,7 @@
 
     # PerlOptions -GlobalRequest is in effect
     eval { my $gr = Apache2::RequestUtil->request; };
-    ok t_cmp($@, 
+    ok t_cmp($@,
              qr/\$r object is not available/,
              "unavailable global $r object");
 
Index: t/response/TestDirective/perldo.pm
===================================================================
--- t/response/TestDirective/perldo.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestDirective/perldo.pm	(.../trunk)	(revision 630610)
@@ -12,7 +12,7 @@
 sub handler {
     my $r = shift;
 
-    plan $r, tests => 22, need_module('mod_alias'); 
+    plan $r, tests => 22, need_module('mod_alias');
 
     ok t_cmp('yes', $TestDirective::perl::worked);
 
@@ -53,22 +53,22 @@
     ok t_cmp($@, "", "PerlSections dump syntax check");
 
     ok t_cmp($TestDirective::perldo::test::Include, qr/perlsection.conf/);
-    
+
     #Check for correct Apache2::ServerUtil->server behavior
     my $bport = $TestDirective::perl::base_server->port;
     my $vport = $TestDirective::perl::vhost_server->port;
     ok defined $bport && defined $vport && $vport != $bport;
-    
+
     foreach my $url (qw(scalar scalar1 scalar2)) {
         my $res = GET "/perl_sections_perlconfig_$url/";
         ok t_cmp($res->is_success, 1, '$PerlConfig');
     }
-    
+
     foreach my $url (qw(array1 array2)) {
         my $res = GET "/perl_sections_perlconfig_$url/";
         ok t_cmp($res->is_success, 1, '@PerlConfig');
     }
-    
+
     Apache2::Const::OK;
 }
 
Index: t/response/TestDirective/cmdparms.pm
===================================================================
--- t/response/TestDirective/cmdparms.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestDirective/cmdparms.pm	(.../trunk)	(revision 630610)
@@ -47,7 +47,7 @@
     foreach my $method (@methods) {
         $srv_cfg->{$args}{$method} = $parms->$method();
     }
-    $srv_cfg->{$args}{check_ctx} = 
+    $srv_cfg->{$args}{check_ctx} =
         $parms->check_cmd_context(Apache2::Const::NOT_IN_LOCATION);
 
     $srv_cfg->{$args}{limited} = $parms->method_is_limited('GET');
Index: t/response/TestDirective/env.pm
===================================================================
--- t/response/TestDirective/env.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestDirective/env.pm	(.../trunk)	(revision 630610)
@@ -18,7 +18,7 @@
 
     # %ENV
     ok t_cmp(env_get('srv1'),
-             'env_dir1', 
+             'env_dir1',
              '%ENV per-dir override per-srv');
 
     ok t_cmp(env_get('srv2'),
Index: t/response/TestDirective/perlloadmodule.pm
===================================================================
--- t/response/TestDirective/perlloadmodule.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestDirective/perlloadmodule.pm	(.../trunk)	(revision 630610)
@@ -38,7 +38,7 @@
     my ($class, $parms) = @_;
 
     bless {
-	path => $parms->path || "/",
+        path => $parms->path || "/",
     }, $class;
 }
 
@@ -48,7 +48,7 @@
     my %new = ();
 
     @new{keys %$base, keys %$add} =
-	(values %$base, values %$add);
+        (values %$base, values %$add);
 
     return bless \%new, ref($base);
 }
@@ -69,7 +69,7 @@
     my ($class, $parms) = @_;
     debug "$class->SERVER_CREATE\n";
     return bless {
-	name => __PACKAGE__,
+        name => __PACKAGE__,
     }, $class;
 }
 
Index: t/response/TestDirective/perlloadmodule3.pm
===================================================================
--- t/response/TestDirective/perlloadmodule3.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestDirective/perlloadmodule3.pm	(.../trunk)	(revision 630610)
@@ -112,7 +112,7 @@
         $secs{"2: Location"}     = $dir_cfg;
      }
 
-    $r->printf("Processing by %s.\n", 
+    $r->printf("Processing by %s.\n",
         $s->is_virtual ? "virtual host" : "main server");
 
     for my $sec (sort keys %secs) {
Index: t/response/TestDirective/perlrequire.pm
===================================================================
--- t/response/TestDirective/perlrequire.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/response/TestDirective/perlrequire.pm	(.../trunk)	(revision 630610)
@@ -26,7 +26,7 @@
     Apache2::Const::OK;
 }
 
-my %require_tests = 
+my %require_tests =
     (
      main => 'PerlRequired by Parent',
      vh   => 'PerlRequired by VirtualHost',
Index: t/protocol/eliza.t
===================================================================
--- t/protocol/eliza.t	(.../tags/2_0_3)	(revision 630610)
+++ t/protocol/eliza.t	(.../trunk)	(revision 630610)
@@ -5,9 +5,9 @@
 use Apache::TestUtil;
 use Apache::TestRequest ();
 
-my @test_strings = ('Hello Eliza', 
-                    'How are you?', 
-                    'Why do I have core dumped?', 
+my @test_strings = ('Hello Eliza',
+                    'How are you?',
+                    'Why do I have core dumped?',
                     'I feel like writing some tests today, what about you?',
                     'Good bye, Eliza');
 
Index: t/perl/hash_attack.t
===================================================================
--- t/perl/hash_attack.t	(.../tags/2_0_3)	(revision 630610)
+++ t/perl/hash_attack.t	(.../trunk)	(revision 630610)
@@ -7,7 +7,7 @@
 
 use Apache::TestRequest 'GET_BODY_ASSERT';
 
-plan tests => 1, 
+plan tests => 1,
     need { "relevant only for perl 5.8.2 and higher" => ($] >= 5.008002) };
 
 my $expected = "ok";
Index: t/modperl/sameinterp.t
===================================================================
--- t/modperl/sameinterp.t	(.../tags/2_0_3)	(revision 630610)
+++ t/modperl/sameinterp.t	(.../trunk)	(revision 630610)
@@ -1,78 +0,0 @@
-use strict;
-use warnings FATAL => 'all';
-
-# run tests through the same interpreter, even if the server is
-# running more than one
-
-use Apache::Test;
-use Apache::TestUtil;
-use Apache::TestRequest;
-
-use TestCommon::SameInterp;
-
-plan tests => 12, need 'HTML::HeadParser';
-
-my $url = "/TestModperl__sameinterp";
-
-# test the tie and re-tie
-for (1..2) {
-    my $same_interp = Apache::TestRequest::same_interp_tie($url);
-    ok $same_interp;
-
-    my $expected = 1;
-    my $skip  = 0;
-    # test GET over the same same_interp
-    for (1..2) {
-        $expected++;
-        my $res = same_interp_req($same_interp, \&GET, $url, foo => 'bar');
-        $skip++ unless defined $res;
-        same_interp_skip_not_found(
-            $skip,
-            defined $res && $res->content,
-            $expected,
-            "GET over the same interp"
-        );
-    }
-}
-
-{
-    # test POST over the same same_interp
-    my $same_interp = Apache::TestRequest::same_interp_tie($url);
-    ok $same_interp;
-
-    my $expected = 1;
-    my $skip  = 0;
-    for (1..2) {
-        $expected++;
-        my $content = join ' ', 'ok', $_ + 3;
-        my $res = same_interp_req($same_interp, \&POST, $url,
-            content => $content);
-        $skip++ unless defined $res;
-        same_interp_skip_not_found(
-            $skip,
-            defined $res && $res->content,
-            $expected,
-            "POST over the same interp"
-        );
-    }
-}
-
-{
-    # test HEAD over the same same_interp
-    my $same_interp = Apache::TestRequest::same_interp_tie($url);
-    ok $same_interp;
-
-    my $expected = 1;
-    my $skip  = 0;
-    for (1..2) {
-        $expected++;
-        my $res = same_interp_req($same_interp, \&HEAD, $url);
-        $skip++ unless defined $res;
-        same_interp_skip_not_found(
-            $skip,
-            defined $res && $res->header(Apache::TestRequest::INTERP_KEY),
-            $same_interp,
-            "HEAD over the same interp"
-        );
-    }
-}
Index: t/modperl/pnotes2.t
===================================================================
--- t/modperl/pnotes2.t	(.../tags/2_0_3)	(revision 0)
+++ t/modperl/pnotes2.t	(.../trunk)	(revision 630610)
@@ -0,0 +1,32 @@
+use strict;
+use warnings FATAL => 'all';
+
+use Apache::TestRequest qw(GET_BODY);
+use Apache::Test;
+use Apache::TestUtil;
+use Apache::TestUtil qw/t_start_error_log_watch t_finish_error_log_watch/;
+
+my $module = 'TestModperl::pnotes2';
+my $url    = Apache::TestRequest::module2url($module);
+my ($u, $ok);
+
+t_debug("connecting to $url");
+
+plan tests => 12, need_lwp;
+
+Apache::TestRequest::user_agent(reset => 1, keep_alive => 0);
+
+for my $i (1..12) {
+    t_client_log_warn_is_expected();
+    t_start_error_log_watch;
+    $u="$url?$i"; $ok=GET_BODY $u;
+    select undef, undef, undef, 0.2;  # give it time to write the logfile
+    ok t_cmp scalar(grep {
+        /pnotes are destroyed after cleanup passed/;
+    } t_finish_error_log_watch), 1, $u;
+}
+
+# Local Variables: #
+# mode: cperl #
+# cperl-indent-level: 4 #
+# End: #
Index: t/modperl/cookie2.t
===================================================================
--- t/modperl/cookie2.t	(.../tags/2_0_3)	(revision 630610)
+++ t/modperl/cookie2.t	(.../trunk)	(revision 630610)
@@ -14,7 +14,7 @@
 use Apache::Test;
 use Apache::TestUtil;
 use Apache::TestRequest;
-use TestCommon::SameInterp;
+Apache::TestRequest::user_agent(keep_alive => 1);
 
 plan tests => 3, need 'HTML::HeadParser';
 
@@ -30,21 +30,14 @@
 
 my @tests_ordered = qw(header subprocess_env env);
 
-t_debug "getting the same interp ID for $location";
-my $same_interp = Apache::TestRequest::same_interp_tie($location);
-
-my $skip = $same_interp ? 0 : 1;
 for my $test (@tests_ordered) {
     my $cookie = "key=$test";
 
-    my $received = same_interp_req_body($same_interp, \&GET,
-                                        "$location?$test",
-                                        Cookie => $cookie);
-    $skip++ unless defined $received;
-    same_interp_skip_not_found(
-        $skip,
-        $received,
+    my $received = GET "$location?$test", Cookie => $cookie;
+
+    ok t_cmp(
+        $received->content,
         $expected{$test},
-        "perl-script+SetupEnv/cookie: $test"
+        "perl-script+SetupEnv/cookie: $test",
     );
 }
Index: t/modperl/cookie.t
===================================================================
--- t/modperl/cookie.t	(.../tags/2_0_3)	(revision 630610)
+++ t/modperl/cookie.t	(.../trunk)	(revision 630610)
@@ -9,7 +9,7 @@
 # this test we call $r->subprocess_env, which adds them on demand, and
 # we are able to get the cookie via %ENV.
 #
-# the last sub-test makes sure that mod_cgi env vars don't persist 
+# the last sub-test makes sure that mod_cgi env vars don't persist
 # and are properly re-set at the end of each request.
 #
 # since the test is run against the same interpreter we also test that
@@ -19,9 +19,8 @@
 use Apache::Test;
 use Apache::TestUtil;
 use Apache::TestRequest;
+Apache::TestRequest::user_agent(keep_alive => 1);
 
-use TestCommon::SameInterp;
-
 plan tests => 3, need 'HTML::HeadParser';
 
 my $module   = 'TestModperl::cookie';
@@ -41,21 +40,17 @@
 
 my @tests_ordered = qw(header env nocookie);
 
-t_debug "getting the same interp ID for $location";
-my $same_interp = Apache::TestRequest::same_interp_tie($location);
+GET $location;
 
-my $skip = $same_interp ? 0 : 1;
 for my $test (@tests_ordered) {
     my $expected = $test eq 'nocookie' ? '' : "bar";
     my @headers = ();
     push @headers, (Cookie => $cookies{$test}) unless $test eq 'nocookie';
 
-    my $received = same_interp_req_body($same_interp, \&GET,
-                                        "$location?$test", @headers);
-    $skip++ unless defined $received;
-    same_interp_skip_not_found(
-        $skip,
-        $received,
+    my $received = GET "$location?$test", @headers;
+    
+    ok t_cmp(
+        $received->content,
         $expected,
         "perl-script+SetupEnv/cookie: $test"
     );
Index: t/lib/TestCommon/MemoryLeak.pm
===================================================================
--- t/lib/TestCommon/MemoryLeak.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/lib/TestCommon/MemoryLeak.pm	(.../trunk)	(revision 630610)
@@ -18,7 +18,7 @@
 #  % t/TEST -maxclients 1 -start
 #
 # of course use maxclients 1 only if your test be handled with one
-# client, e.g. proxy tests need at least two clients. 
+# client, e.g. proxy tests need at least two clients.
 #
 # Now repeat the same test several times (more than 3)
 #
Index: t/lib/TestCommon/SameInterp.pm
===================================================================
--- t/lib/TestCommon/SameInterp.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/lib/TestCommon/SameInterp.pm	(.../trunk)	(revision 630610)
@@ -100,7 +100,7 @@
 
 in the same_interp framework one runs
 
-  my $res = Apache::TestRequest::same_interp_do($same_interp, 
+  my $res = Apache::TestRequest::same_interp_do($same_interp,
       \&GET, $url, @data);
 
 but if there is a failure to find the same interpreter we get an
Index: t/lib/TestAPRlib/date.pm
===================================================================
--- t/lib/TestAPRlib/date.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/lib/TestAPRlib/date.pm	(.../trunk)	(revision 630610)
@@ -45,7 +45,7 @@
     # parse_http
     for my $date_str (@http_dates) {
         ok t_cmp(APR::Date::parse_http($date_str),
-                 $date_msec, 
+                 $date_msec,
                  "parse_http: $date_str");
         #t_debug "testing : parse_http: $date_str";
     }
@@ -53,7 +53,7 @@
     # parse_rfc
     for my $date_str (@rfc_dates) {
         ok t_cmp(APR::Date::parse_rfc($date_str),
-                 $date_msec, 
+                 $date_msec,
                  "parse_rfc: $date_str");
         #t_debug "testing : parse_rfc: $date_str";
     }
Index: t/lib/TestAPRlib/status.pm
===================================================================
--- t/lib/TestAPRlib/status.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/lib/TestAPRlib/status.pm	(.../trunk)	(revision 630610)
@@ -15,7 +15,7 @@
     return 2;
 }
 
-sub test {    
+sub test {
     ok APR::Status::is_EAGAIN(APR::Const::EAGAIN);
     ok ! APR::Status::is_EAGAIN(APR::Const::ENOPOLL);
 }
Index: t/lib/TestAPRlib/table.pm
===================================================================
--- t/lib/TestAPRlib/table.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/lib/TestAPRlib/table.pm	(.../trunk)	(revision 630610)
@@ -334,7 +334,7 @@
         $table2->set($_**2 => $_**2) for 1..20;
         my $table2_copy = APR::Table::make($pool, 1);
         $table2_copy->set($_ => $_) for 1..20;
-        
+
         my $overlay = $table2_copy->overlay($table2, $pool->new);
         {
             # see the comment for above's:
Index: t/lib/TestAPRlib/threadrwlock.pm
===================================================================
--- t/lib/TestAPRlib/threadrwlock.pm	(.../tags/2_0_3)	(revision 0)
+++ t/lib/TestAPRlib/threadrwlock.pm	(.../trunk)	(revision 630610)
@@ -0,0 +1,39 @@
+package TestAPRlib::threadrwlock;
+
+use strict;
+use warnings FATAL => 'all';
+
+use Apache::Test;
+use Apache::TestUtil;
+
+use APR::Const -compile => qw(EBUSY SUCCESS);
+use APR::Pool();
+
+sub num_of_tests {
+    return 5;
+}
+
+sub test {
+
+    require APR::ThreadRWLock;
+
+    my $pool = APR::Pool->new();
+    my $mutex = APR::ThreadRWLock->new($pool);
+
+    ok $mutex;
+
+    ok t_cmp($mutex->rdlock, APR::Const::SUCCESS,
+             'rdlock == APR::Const::SUCCESS');
+
+    ok t_cmp($mutex->unlock, APR::Const::SUCCESS,
+             'unlock == APR::Const::SUCCESS');
+
+    ok t_cmp($mutex->wrlock, APR::Const::SUCCESS,
+             'wrlock == APR::Const::SUCCESS');
+
+    ok t_cmp($mutex->unlock, APR::Const::SUCCESS,
+             'unlock == APR::Const::SUCCESS');
+
+}
+
+1;
Index: t/lib/TestAPRlib/finfo.pm
===================================================================
--- t/lib/TestAPRlib/finfo.pm	(.../tags/2_0_3)	(revision 630610)
+++ t/lib/TestAPRlib/finfo.pm	(.../trunk)	(revision 630610)
@@ -144,7 +144,7 @@
             ok t_cmp($finfo->protection & APR::Const::FPROT_WREAD,
                      $stat->{protection} & S_IROTH,
                      '$finfo->protection() & APR::Const::FPROT_WREAD');
-	}
+        }
         if (WIN32 and APACHE_2_2_PLUS) {
             skip "broken apr stat on Win32", 0;
         }
@@ -152,7 +152,7 @@
             ok t_cmp($finfo->protection & APR::Const::FPROT_WWRITE,
                      $stat->{protection} & S_IWOTH,
                      '$finfo->protection() & APR::Const::FPROT_WWRITE');
-	}
+        }
         if (WIN32) {
             skip "different file semantics", 0;
         }
Index: t/modules/reload.t
===================================================================
--- t/modules/reload.t	(.../tags/2_0_3)	(revision 630610)
+++ t/modules/reload.t	(.../trunk)	(revision 630610)
@@ -1,107 +0,0 @@
-use strict;
-use warnings FATAL => 'all';
-
-use Apache::Test;
-use Apache::TestUtil;
-use Apache::TestRequest;
-use File::Spec::Functions qw(catfile);
-
-use TestCommon::SameInterp;
-
-plan tests => 3, need 'HTML::HeadParser';
-
-my $test_file = catfile Apache::Test::vars("serverroot"),
-    qw(lib Apache2 Reload Test.pm);
-
-my $module   = 'TestModules::reload';
-my $location = '/' . Apache::TestRequest::module2path($module);
-
-my @tests = qw(simple const prototype subpackage);
-
-my $header = join '', <DATA>;
-
-my $initial = <<'EOF';
-sub simple { 'simple' }
-use constant const => 'const';
-sub prototype($) { 'prototype' }
-sub promised;
-EOF
-
-my $modified = <<'EOF';
-sub simple { 'SIMPLE' }
-use constant const => 'CONST';
-sub prototype($$) { 'PROTOTYPE' }
-EOF
-
-t_write_file($test_file, $header, $initial);
-
-t_debug "getting the same interp ID for $location";
-my $same_interp = Apache::TestRequest::same_interp_tie($location);
-
-my $skip = $same_interp ? 0 : 1;
-
-{
-    my $expected = join '', map { "$_:$_\n" } sort @tests;
-    my $received = same_interp_req_body($same_interp, \&GET,
-                                        $location);
-    $skip++ unless defined $received;
-    same_interp_skip_not_found(
-        $skip,
-        $received,
-        $expected,
-        "Initial"
-    );
-}
-
-t_write_file($test_file, $header, $modified);
-touch_mtime($test_file);
-
-{
-    my $expected = join '', map { "$_:" . uc($_) . "\n" } sort @tests;
-    my $received = same_interp_req_body($same_interp, \&GET,
-                                        $location);
-    $skip++ unless defined $received;
-    same_interp_skip_not_found(
-        $skip,
-        $received,
-        $expected,
-        "Reload"
-    );
-}
-
-{
-    my $expected = "unregistered OK";
-    my $received = same_interp_req_body($same_interp, \&GET, 
-                                        $location . '?last' );
-    $skip++ unless defined $received;
-    same_interp_skip_not_found(
-        $skip,
-        $received,
-        $expected,
-        "Unregister"
-    );
-}
-
-sub touch_mtime {
-    my $file = shift;
-    # push the mtime into the future (at least 2 secs to work on win32)
-    # so Apache2::Reload will reload the package
-    my $time = time + 5; # make it 5 to be sure
-    utime $time, $time, $file;
-}
-
-__DATA__
-package Apache2::Reload::Test;
-
-use Apache2::Reload;
-
-our @methods = qw(simple const prototype subpackage);
-
-sub subpackage { return Apache2::Reload::Test::SubPackage::subpackage() } 
-
-sub run {
-    my $r = shift;
-    foreach my $m (sort @methods) {
-        $r->print($m, ':', __PACKAGE__->$m(), "\n");
-    }
-}
Index: t/modules/apache_status.t
===================================================================
--- t/modules/apache_status.t	(.../tags/2_0_3)	(revision 630610)
+++ t/modules/apache_status.t	(.../trunk)	(revision 630610)
@@ -18,13 +18,9 @@
 {
     my $url = "$base_url";
     my $body = GET_BODY_ASSERT $url;
-    (my $pver = $]) =~ s/00//;
-    $pver =~ s/(\d\.\d)(.*)/"$1." . ($2 ? int($2) : 0)/e;
-    #t_debug $body;
-    t_debug $pver;
-    # expecting: Embedded Perl version v5.8.2 for ...
-    ok $body =~ /$pver/;
-
+    # expecting: Embedded Perl version <b>v5.8.2</b> for ...
+    my $pver = $^V ? sprintf "v%vd", $^V : $];
+    ok t_cmp($body, qr[Embedded Perl version <b>$pver</b> for]);
     # menu_item, part 1
     # expecting: Test Entry
     ok $body =~ /Test Menu Entry/;
Index: t/directive/perl.t
===================================================================
--- t/directive/perl.t	(.../tags/2_0_3)	(revision 630610)
+++ t/directive/perl.t	(.../trunk)	(revision 630610)
@@ -10,7 +10,7 @@
 my @auth = (Authorization => 'Basic ZG91Z206Zm9v'); #dougm:foo
 
 
-foreach my $location ("/perl_sections/index.html", 
+foreach my $location ("/perl_sections/index.html",
                       "/perl_sections_readconfig/index.html") {
 
     sok {
Index: lib/ModPerl/WrapXS.pm
===================================================================
--- lib/ModPerl/WrapXS.pm	(.../tags/2_0_3)	(revision 630610)
+++ lib/ModPerl/WrapXS.pm	(.../trunk)	(revision 630610)
@@ -289,7 +289,7 @@
 EOF
             }
             elsif ($access_mode eq 'rw_char_undef') {
-                my $pool = $e->{pool} 
+                my $pool = $e->{pool}
                     or die "rw_char_undef accessors need pool";
                 $pool .= '(obj)';
 # XXX: not sure where val=$default is coming from, but for now use
@@ -595,8 +595,9 @@
         }
     }
 
-    if ($module eq 'APR::Pool') {
+    if ($module eq 'APR::Pool' && Apache2::Build::PERL_HAS_ITHREADS) {
         print $fh "    modperl_opt_interp_unselect = APR_RETRIEVE_OPTIONAL_FN(modperl_interp_unselect);\n\n";
+        print $fh "    modperl_opt_thx_interp_get  = APR_RETRIEVE_OPTIONAL_FN(modperl_thx_interp_get);\n\n";
     }
 
     close $fh;
@@ -778,7 +779,7 @@
 my $objects;
 
 sub _get_modules {
-    for my $method (sort keys %$methods) { 
+    for my $method (sort keys %$methods) {
         for my $item ( @{ $methods->{$method} }) {
             push @{ $modules->{$item->[MODULE]} }, [$method, $item->[OBJECT]];
         }
@@ -786,7 +787,7 @@
 }
 
 sub _get_objects {
-    for my $method (sort keys %$methods) { 
+    for my $method (sort keys %$methods) {
         for my $item ( @{ $methods->{$method} }) {
             next unless defined $item->[OBJECT];
             push @{ $objects->{$item->[OBJECT]} }, [$method, $item->[MODULE]];
@@ -945,7 +946,7 @@
     my @args = @_ ? @_ : @ARGV;
     while (@args) {
          my $method = shift @args;
-         my $object = (@args && 
+         my $object = (@args &&
              (ref($args[0]) || $args[0] =~ /^(Apache2|ModPerl|APR)/))
              ? shift @args
              : undef;
@@ -1065,7 +1066,7 @@
     my $format = "%-${max_len}s %s\n";
     my $banner = sprintf($format, "Method", "Invoked on object type");
     my $hint = join '',
-        ("\nModule '$module' contains the following XS methods:\n\n", 
+        ("\nModule '$module' contains the following XS methods:\n\n",
          $banner,  sep(length($banner)),
          map( { sprintf $format, $_->[0], $_->[1]||'???'}
              @{ $modules->{$module} }),
@@ -1225,10 +1226,10 @@
     if (my $attr = $entry->{attr}) {
         return 1 if grep { $_ eq 'static' } @$attr;
     }
-    
+
     #C::Scan doesnt always pickup static __inline__
     return 1 if $entry->{name} =~ /^mpxs_/o;
-    
+
     return 0;
 }
 
@@ -1297,7 +1298,7 @@
     while (my ($key, $table) = each %files) {
         my $handles = $self->open_export_files($key, $ext);
 
-	my %seen; #only write header once if this is a single file
+        my %seen; #only write header once if this is a single file
         for my $fh (values %$handles) {
             next if $seen{$fh}++;
             print $fh $self->$header();
@@ -1356,14 +1357,14 @@
 EOF
         return;
     }
-    
+
     print $fh <<"EOF";
-/* 
+/*
  * This is indeed a ugly hack!
  * See also src/modules/perl/mod_perl.c for modperl_ugly_hack
  * If we don't build such a list of exported API functions, the over-zealous
  * linker can and will remove the unused functions completely. In order to
- * avoid this, we create this object and modperl_ugly_hack to create a 
+ * avoid this, we create this object and modperl_ugly_hack to create a
  * dependency between all the exported API and mod_perl.c
  */
 const void *modperl_ugly_hack = NULL;
Index: lib/ModPerl/Config.pm
===================================================================
--- lib/ModPerl/Config.pm	(.../tags/2_0_3)	(revision 630610)
+++ lib/ModPerl/Config.pm	(.../trunk)	(revision 630610)
@@ -56,7 +56,7 @@
         $cfg .= qx{$command};
 
         $cfg .= Apache::TestConfig::ldd_as_string($httpd);
-    } 
+    }
     else {
         $cfg .= "\n\n*** The httpd binary was not found\n";
     }
Index: lib/ModPerl/Manifest.pm
===================================================================
--- lib/ModPerl/Manifest.pm	(.../tags/2_0_3)	(revision 630610)
+++ lib/ModPerl/Manifest.pm	(.../trunk)	(revision 630610)
@@ -40,7 +40,7 @@
     my @files;
 
     my $cwd = Cwd::cwd();
-    my @lines = `svn status -v`	;
+    my @lines = `svn status -v` ;
     foreach my $line (@lines) {
         chomp $line;
         if ($line =~ /(?:\d+)\s+(?:\d+)\s+(?:\w+)\s+(.*)\s*/) {
Index: lib/ModPerl/CScan.pm
===================================================================
--- lib/ModPerl/CScan.pm	(.../tags/2_0_3)	(revision 630610)
+++ lib/ModPerl/CScan.pm	(.../trunk)	(revision 630610)
@@ -8,7 +8,7 @@
 # it's not a requirement for mod_perl users
 use Data::Flow qw(0.05);
 
-use strict;			# Earlier it catches ISA and EXPORT.
+use strict;                     # Earlier it catches ISA and EXPORT.
 
 @ModPerl::CScan::ISA = qw(Exporter Data::Flow);
 
@@ -17,9 +17,9 @@
 # Do not simply export all your public functions/methods/constants.
 
 @ModPerl::CScan::EXPORT = qw(
-	    );
+            );
 @ModPerl::CScan::EXPORT_OK = qw(
-			);
+                        );
 # this flag tells cpp to only output macros
 $ModPerl::CScan::MACROS_ONLY = '-dM';
 
@@ -38,8 +38,8 @@
 for (qw(__func__ _Complex _Imaginary _Bool inline restrict)) {
   $style_keywords{'C9X'}{$_}++;
 }
-for (qw(inline const asm noreturn section 
-	constructor destructor unused weak)) {
+for (qw(inline const asm noreturn section
+        constructor destructor unused weak)) {
   $style_keywords{'GNU'}{$_}++;
   $style_keywords{'GNU'}{"__$ {_}__"}++;
 }
@@ -57,37 +57,37 @@
       c_styles => { default => [qw(C++ GNU C9X)] },
       add_cppflags => { default => '' },
       keywords => { prerequisites => ['c_styles'],
-		    output => sub {
-		      my %kw = %keywords;
-		      my %add;
-		      for ( @{ shift->{c_styles} } ) {
-			%add = %{ $style_keywords{$_} };
-			%kw = (%kw, %add);
-		      }
-		      \%kw;
-		    }, },
+                    output => sub {
+                      my %kw = %keywords;
+                      my %add;
+                      for ( @{ shift->{c_styles} } ) {
+                        %add = %{ $style_keywords{$_} };
+                        %kw = (%kw, %add);
+                      }
+                      \%kw;
+                    }, },
       'undef' => { default => undef },
       filename_filter => { default => undef },
       full_text => { class_filter => [ 'text', 'C::Preprocessed',
-				       qw(undef filename Defines includeDirs Cpp)] },
+                                       qw(undef filename Defines includeDirs Cpp)] },
       text => { class_filter => [ 'text', 'C::Preprocessed',
-				  qw(filename_filter filename Defines includeDirs Cpp)] },
+                                  qw(filename_filter filename Defines includeDirs Cpp)] },
       text_only_from => { class_filter => [ 'text_only_from', 'C::Preprocessed',
-					    qw(filename_filter filename Defines includeDirs Cpp)] },
-      includes => { filter => [ \&includes, 
-				qw(filename Defines includeDirs Cpp) ], },
-      includeDirs =>  { prerequisites => ['filedir'], 
-			output => sub {
-			  my $data = shift;
-			  [ $data->{filedir}, '/usr/local/include', '.'];
-			} },
-      Cpp => { prerequisites => [qw(cppminus add_cppflags cppflags cppstdin)], 
-	       output => sub {
-		 my $data = shift;
-		 return { cppstdin => $data->{cppstdin},
-			  cppflags => "$data->{cppflags} $data->{add_cppflags}",
-			  cppminus => $data->{cppminus} };
-	       } },
+                                            qw(filename_filter filename Defines includeDirs Cpp)] },
+      includes => { filter => [ \&includes,
+                                qw(filename Defines includeDirs Cpp) ], },
+      includeDirs =>  { prerequisites => ['filedir'],
+                        output => sub {
+                          my $data = shift;
+                          [ $data->{filedir}, '/usr/local/include', '.'];
+                        } },
+      Cpp => { prerequisites => [qw(cppminus add_cppflags cppflags cppstdin)],
+               output => sub {
+                 my $data = shift;
+                 return { cppstdin => $data->{cppstdin},
+                          cppflags => "$data->{cppflags} $data->{add_cppflags}",
+                          cppminus => $data->{cppminus} };
+               } },
       filedir => { output => sub { dirname ( shift->{filename} || '.' ) } },
       sanitized => { filter => [ \&sanitize, 'text'], },
       toplevel => { filter => [ \&top_level, 'sanitized'], },
@@ -97,30 +97,30 @@
       typedef_chunks => { filter => [ \&typedef_chunks, 'full_toplevel'], },
       struct_chunks => { filter => [ \&struct_chunks, 'full_toplevel'], },
       typedefs_whited => { filter => [ \&typedefs_whited,
-				       'full_sanitized', 'typedef_chunks',
-				       'keywords_rex'], },
+                                       'full_sanitized', 'typedef_chunks',
+                                       'keywords_rex'], },
       typedef_texts => { filter => [ \&typedef_texts,
-				     'full_text', 'typedef_chunks'], },
+                                     'full_text', 'typedef_chunks'], },
       struct_texts => { filter => [ \&typedef_texts,
-				    'full_text', 'struct_chunks'], },
+                                    'full_text', 'struct_chunks'], },
       typedef_hash => { filter => [ \&typedef_hash,
-				    'typedef_texts', 'typedefs_whited'], },
+                                    'typedef_texts', 'typedefs_whited'], },
       typedef_structs => { filter => [ \&typedef_structs,
-				       'typedef_hash', 'struct_texts'], },
+                                       'typedef_hash', 'struct_texts'], },
       typedefs_maybe => { filter => [ sub {[keys %{+shift}]},
-				      'typedef_hash'], },
+                                      'typedef_hash'], },
       defines_maybe => { filter => [ \&defines_maybe, 'filename'], },
       defines_no_args => { prerequisites => ['defines_maybe'],
-			   output => sub { shift->{defines_maybe}->[0] }, },
+                           output => sub { shift->{defines_maybe}->[0] }, },
       defines_args => { prerequisites => ['defines_maybe'],
-			output => sub { shift->{defines_maybe}->[1] }, },
+                        output => sub { shift->{defines_maybe}->[1] }, },
 
-      defines_full => { filter => [ \&defines_full, 
-				    qw(filename Defines includeDirs Cpp) ], },
+      defines_full => { filter => [ \&defines_full,
+                                    qw(filename Defines includeDirs Cpp) ], },
       defines_no_args_full => { prerequisites => ['defines_full'],
-				output => sub { shift->{defines_full}->[0] }, },
+                                output => sub { shift->{defines_full}->[0] }, },
       defines_args_full => { prerequisites => ['defines_full'],
-			output => sub { shift->{defines_full}->[1] }, },
+                        output => sub { shift->{defines_full}->[1] }, },
 
       decl_inlines => { filter => [ \&functions_in, 'no_type_decl'], },
       inline_chunks => { filter => [ sub { shift->[0] }, 'decl_inlines'], },
@@ -134,13 +134,13 @@
       vdecl_chunks => { filter => [ sub { shift->[3] }, 'decl_inlines'], },
       vdecls => { filter => [ \&from_chunks, 'vdecl_chunks', 'text'], },
       vdecl_hash => { filter => [ \&vdecl_hash, 'vdecls', 'mdecls' ], },
-      parsed_fdecls => { filter => [ \&do_declarations, 'fdecls', 
-				     'typedef_hash', 'keywords'], },
+      parsed_fdecls => { filter => [ \&do_declarations, 'fdecls',
+                                     'typedef_hash', 'keywords'], },
       keywords_rex => { filter => [ sub { my @k = keys %{ shift() };
-					  local $" = '|';
-					  my $r = "(?:@k)";
-					  eval 'qr/$r/' or $r	# Older Perls
-					}, 'keywords'], },
+                                          local $" = '|';
+                                          my $r = "(?:@k)";
+                                          eval 'qr/$r/' or $r   # Older Perls
+                                        }, 'keywords'], },
     };
 
 sub from_chunks {
@@ -164,11 +164,11 @@
     or die "Cannot open pipe from cppstdin: $!\n";
 
   while (<$stream>) {
-    next unless m(^\s*\#\s*	# Leading hash
-		  (line\s*)?	# 1: Optional line
-		  ([0-9]+)\s*	# 2: Line number
-		  (.*)		# 3: The rest
-		 )x;
+    next unless m(^\s*\#\s*     # Leading hash
+                  (line\s*)?    # 1: Optional line
+                  ([0-9]+)\s*   # 2: Line number
+                  (.*)          # 3: The rest
+                 )x;
     my $include = $3;
     $include = $1 if $include =~ /"(.*)"/; # Filename may be in quotes
     $include =~ s,\\\\,/,g if $^O eq 'os2';
@@ -182,19 +182,19 @@
   my ($mline,$line,%macros,%macrosargs,$sym,$args);
   open(C, $file) or die "Cannot open file $file: $!\n";
   while (not eof(C) and $line = <C>) {
-    next unless 
+    next unless
       ( $line =~ s[
-		   ^ \s* \# \s*	# Start of directive
-		   define \s+
-		   (\w+)	# 1: symbol
-		   (?:
-		    \( (.*?) \s* \) # 2: Minimal match for arguments
+                   ^ \s* \# \s* # Start of directive
+                   define \s+
+                   (\w+)        # 1: symbol
+                   (?:
+                    \( (.*?) \s* \) # 2: Minimal match for arguments
                                     # in parenths (without trailing
                                     # spaces)
-		   )?		# optional, no grouping
-		   \s*		# rest is the definition
-		   ([\s\S]*)	# 3: the rest
-		  ][]x );
+                   )?           # optional, no grouping
+                   \s*          # rest is the definition
+                   ([\s\S]*)    # 3: the rest
+                  ][]x );
     ($sym, $args, $mline) = ($1, $2, $3);
     $mline .= <C> while not eof(C) and $mline =~ s/\\\n/\n/;
     chomp $mline;
@@ -221,19 +221,19 @@
     or die "Cannot open pipe from cppstdin: $!\n";
 
   while (defined ($line = <$stream>)) {
-    next unless 
+    next unless
       ( $line =~ s[
-		   ^ \s* \# \s*	# Start of directive
-		   define \s+
-		   (\w+)	# 1: symbol
-		   (?:
-		    \( (.*?) \s* \) # 2: Minimal match for arguments
+                   ^ \s* \# \s* # Start of directive
+                   define \s+
+                   (\w+)        # 1: symbol
+                   (?:
+                    \( (.*?) \s* \) # 2: Minimal match for arguments
                                     # in parenths (without trailing
                                     # spaces)
-		   )?		# optional, no grouping
-		   \s*		# rest is the definition
-		   ([\s\S]*)	# 3: the rest
-		  ][]x );
+                   )?           # optional, no grouping
+                   \s*          # rest is the definition
+                   ([\s\S]*)    # 3: the rest
+                  ][]x );
     ($sym, $args, $mline) = ($1, $2, $3);
     $mline .= <$stream> while ($mline =~ s/\\\n/\n/);
     chomp $mline;
@@ -249,7 +249,7 @@
   [\%macros, \%macrosargs];
 }
 
-sub typedef_chunks {		# Input is toplevel, output: starts and ends
+sub typedef_chunks {            # Input is toplevel, output: starts and ends
   my $txt = shift;
   pos $txt = 0;
   my ($b, $e, @out);
@@ -273,7 +273,7 @@
   \@out;
 }
 
-sub typedefs_whited {		# Input is sanitized text, and list of beg/end.
+sub typedefs_whited {           # Input is sanitized text, and list of beg/end.
   my @lst = @{$_[1]};
   my @out;
   my ($b, $e);
@@ -325,35 +325,35 @@
       $wh =~ /,/g;
       my $p = pos $wh;
       my ($s, $e);
-      if (matchingbrace($wh)) {	# Inside.  Easy part: just split on /,/...
-	$e = pos($wh) - 1;
-	$s = $e;
-	my $d = 0;
-	# Skip back
-	while (--$s >= 0) {
-	  my $c = substr $wh, $s, 1;
-	  if ($c =~ /[\(\{\[]/) {
-	    $d--;
-	  } elsif ($c =~ /[\)\]\}]/) {
-	    $d++;
-	  }
-	  last if $d < 0;
-	}
-	if ($s < 0) {		# Should not happen
-	  warn("panic: could not match braces in\n\t$td\nwhited as\n\t$wh\n");
-	  next loop;
-	}
-	$s++;
-      } else {			# We are at toplevel
-	# We need to skip back all the modifiers attached to the first thingy
-	# Guesstimates: everything after the first '*' (inclusive)
-	pos $wh = 0;
-	$wh = /(?=\w)/g;
-	my $ws = pos $wh;
-	my $pre = substr $wh, 0, $ws;
-	$s = $ws;
-	$s = pos $pre if $pre =~ /(?=\*)/g;
-	$e = length $wh;
+      if (matchingbrace($wh)) { # Inside.  Easy part: just split on /,/...
+        $e = pos($wh) - 1;
+        $s = $e;
+        my $d = 0;
+        # Skip back
+        while (--$s >= 0) {
+          my $c = substr $wh, $s, 1;
+          if ($c =~ /[\(\{\[]/) {
+            $d--;
+          } elsif ($c =~ /[\)\]\}]/) {
+            $d++;
+          }
+          last if $d < 0;
+        }
+        if ($s < 0) {           # Should not happen
+          warn("panic: could not match braces in\n\t$td\nwhited as\n\t$wh\n");
+          next loop;
+        }
+        $s++;
+      } else {                  # We are at toplevel
+        # We need to skip back all the modifiers attached to the first thingy
+        # Guesstimates: everything after the first '*' (inclusive)
+        pos $wh = 0;
+        $wh = /(?=\w)/g;
+        my $ws = pos $wh;
+        my $pre = substr $wh, 0, $ws;
+        $s = $ws;
+        $s = pos $pre if $pre =~ /(?=\*)/g;
+        $e = length $wh;
       }
       # Now: need to split $td based on commas in $wh!
       # And need to split each chunk of $td based on word in the chunk of $wh!
@@ -364,29 +364,29 @@
       my $td_s = 0;
       my (@td_decl, @td_pre, @td_post, @td_word);
       for my $wh_d (@wh_decls) {
-	my $td_d = substr $td, $td_s, length $wh_d;
-	push @td_decl, $td_d;
-	$wh_d =~ /(\w+)/g;
-	push @td_word, $1;
-	push @td_post, substr $td_d, pos($wh_d);
-	push @td_pre,  substr $td_d, pos($wh_d) - length $1, length $1;
-	$td_s += 1 + length $wh_d; # Skip over ','
+        my $td_d = substr $td, $td_s, length $wh_d;
+        push @td_decl, $td_d;
+        $wh_d =~ /(\w+)/g;
+        push @td_word, $1;
+        push @td_post, substr $td_d, pos($wh_d);
+        push @td_pre,  substr $td_d, pos($wh_d) - length $1, length $1;
+        $td_s += 1 + length $wh_d; # Skip over ','
       }
       for my $i (0..$#wh_decls) {
-	my $p = "$td_post[$i]$post";
-	$p = '' unless $p =~ /\S/;
-	$out{$td_word[$i]} = ["$pre$td_pre[$i]", $p];
+        my $p = "$td_post[$i]$post";
+        $p = '' unless $p =~ /\S/;
+        $out{$td_word[$i]} = ["$pre$td_pre[$i]", $p];
       }
-    } elsif ($td =~ /\(\s* \*? \s* ([^)]+) \s* \) \s* \(.*\)/gxs){	# XXX: function pointer typedef
+    } elsif ($td =~ /\(\s* \*? \s* ([^)]+) \s* \) \s* \(.*\)/gxs){      # XXX: function pointer typedef
       $out{$1} = ['XXX: pre_foo', 'XXX: post_bar']; # XXX: not sure what to stuff here
       #warn "[$1] [$td]" if $verb;
-    } else {			# Only one thing defined...
+    } else {                    # Only one thing defined...
       $wh =~ /(\w+)/g;
-      my $e	= pos $wh;
-      my $s	= $e - length $1;
-      my $type	= $1;
-      my $pre	= substr $td, 0, $s;
-      my $post	= substr $td, $e, length($td) - $e;
+      my $e     = pos $wh;
+      my $s     = $e - length $1;
+      my $type  = $1;
+      my $pre   = substr $td, 0, $s;
+      my $post  = substr $td, $e, length($td) - $e;
       $post = '' unless $post =~ /\S/;
       $out{$type} = [$pre, $post];
     }
@@ -459,18 +459,18 @@
     $word = $1;
     if ($word eq ';' || $word eq '') {
       next unless defined $id;
-      $type = 'int' unless defined $type;	# or is this an error?
+      $type = 'int' unless defined $type;       # or is this an error?
       push @$vars, [ $type, $post, $id ];
       ($type, $post, $id, $func) = (undef, undef, undef);
     } elsif ($word eq ',') {
       warn "panic: expecting name before comma in '$in'\n" unless defined $id;
-      $type = 'int' unless defined $type;	# or is this an error?
+      $type = 'int' unless defined $type;       # or is this an error?
       push @$vars, [ $type, $post, $id ];
       $type =~ s/[ *]*$//;
       $id = undef;
     } elsif ($word eq '[') {
       warn "panic: expecting name before '[' in '$in'\n" unless defined $id;
-      $type = 'int' unless defined $type;	# or is this an error?
+      $type = 'int' unless defined $type;       # or is this an error?
       my $b = pos $in;
       matchingbrace($in);
       $post .= $word . substr $in, $b, pos($in) - $b;
@@ -479,15 +479,15 @@
       $type = join ' ', grep defined, $type, $id if defined $id;
       $type = 'int' unless defined $type;
       if ($in =~ /\G\s*(\*[\s\*]*?)\s*(\w+)[\[\]\d\s]*(\)\s*\()/gc) {
-	$type .= "($1";
-	$id = $2;
-	$post = $3;
-	my $b = pos $in;
-	matchingbrace($in);
-	$post .= substr $in, $b, pos($in) - $b;
+        $type .= "($1";
+        $id = $2;
+        $post = $3;
+        my $b = pos $in;
+        matchingbrace($in);
+        $post .= substr $in, $b, pos($in) - $b;
       } else {
-	warn "panic: can't parse function pointer declaration in '$in'\n";
-	return;
+        warn "panic: can't parse function pointer declaration in '$in'\n";
+        return;
       }
     } elsif ($word =~ /^:/) {
       # bitfield
@@ -495,14 +495,14 @@
       $post .= $word;
     } else {
       if (defined $post) {
-	if ($func) {
-	  $post .= $word;
-	} else {
-	  warn "panic: not expecting '$word' after array bounds in '$in'\n";
-	}
+        if ($func) {
+          $post .= $word;
+        } else {
+          warn "panic: not expecting '$word' after array bounds in '$in'\n";
+        }
       } else {
-	$type = join ' ', grep defined, $type, $id if defined $id;
-	$id = $word;
+        $type = join ' ', grep defined, $type, $id if defined $id;
+        $id = $word;
       }
     }
   }
@@ -517,7 +517,7 @@
   my ($vdecls, $mdecls) = @_;
   my %vdecl_hash;
   for (@$vdecls, @$mdecls) {
-    next if /[()]/;	# ignore functions, and function pointers
+    next if /[()]/;     # ignore functions, and function pointers
     my $copy = $_;
     next unless $copy =~ s/^\s*extern\s*//;
     my $vars = parse_vars($copy);
@@ -529,8 +529,8 @@
 # The output is the list of list of inline chunks and list of
 # declaration chunks.
 
-sub functions_in {		# The arg is text without type declarations.
-  my $in = shift;		# remove_type_decl(top_level(sanitize($txt)));
+sub functions_in {              # The arg is text without type declarations.
+  my $in = shift;               # remove_type_decl(top_level(sanitize($txt)));
   # What remains now consists of variable and function declarations,
   # and inline functions.
   $in =~ /(?=\S)/g;
@@ -542,7 +542,7 @@
     $e = pos $in;
     $chunk = substr $in, $b, $e - $b;
     # Now subdivide the chunk.
-    # 
+    #
     # What we got is one chunk, probably finished by `;'. Whoever, it
     # may start with several inline functions.
     #
@@ -552,39 +552,39 @@
       $e1 = pos $chunk;
       push @inlines, $b + $b1, $b + $e1;
       $chunk =~ /(?=\S)/g;
-      $b1 = pos $chunk; 
+      $b1 = pos $chunk;
       $b1 = length $chunk, last unless defined $b1;
     }
     if ($e - $b - $b1 > 0) {
       my ($isvar, $isfunc) = (1, 1);
       substr ($chunk, 0, $b1) = '';
-      if ($chunk =~ /,/) {	# Contains multiple declarations.
-	push @mdecls, $b + $b1, $e;
-      } else  {			# Non-multiple.
-	# Since leading \s* is not optimized, this is quadratic!
-	$chunk =~ s{
-		     ( ( const | __const
-			 | __attribute__ \s* \( \s* \)
-		       ) \s* )* ( ; \s* )? \Z # Strip from the end
-		   }()x;
-	$chunk =~ s/\s*\Z//;
-	if ($chunk =~ /\)\Z/) { # Function declaration ends on ")"!
-	  if ($chunk !~ m{ 
-			  \( .* \( # Multiple parenths
-			 }x
-	      and $chunk =~ / \w \s* \( /x) { # Most probably pointer to a function?
-	    $isvar = 0;
-	  }
-	} elsif ($chunk =~ /
-	  ^ \s* (enum|struct|union|class) \s+ \w+ \s* $
-	/x) {
-	  $isvar = $isfunc = 0;
-	}
-	if ($isvar)  {	# Heuristically variable
-	  push @vdecls, $b + $b1, $e;
-	} elsif ($isfunc) {
-	  push @fdecls, $b + $b1, $e;
-	}
+      if ($chunk =~ /,/) {      # Contains multiple declarations.
+        push @mdecls, $b + $b1, $e;
+      } else  {                 # Non-multiple.
+        # Since leading \s* is not optimized, this is quadratic!
+        $chunk =~ s{
+                     ( ( const | __const
+                         | __attribute__ \s* \( \s* \)
+                       ) \s* )* ( ; \s* )? \Z # Strip from the end
+                   }()x;
+        $chunk =~ s/\s*\Z//;
+        if ($chunk =~ /\)\Z/) { # Function declaration ends on ")"!
+          if ($chunk !~ m{
+                          \( .* \( # Multiple parenths
+                         }x
+              and $chunk =~ / \w \s* \( /x) { # Most probably pointer to a function?
+            $isvar = 0;
+          }
+        } elsif ($chunk =~ /
+          ^ \s* (enum|struct|union|class) \s+ \w+ \s* $
+        /x) {
+          $isvar = $isfunc = 0;
+        }
+        if ($isvar)  {  # Heuristically variable
+          push @vdecls, $b + $b1, $e;
+        } elsif ($isfunc) {
+          push @fdecls, $b + $b1, $e;
+        }
       }
       push @decls, $b + $b1, $e if $isvar || $isfunc;
     }
@@ -602,15 +602,15 @@
 # Remove function arguments using heuristics methods.
 # Now out of several words in a row the last one is a newly defined type.
 
-sub whited_decl {		# Input is sanitized.
+sub whited_decl {               # Input is sanitized.
   my $keywords_rex = shift;
-  my $in = shift;		# Text of a declaration
+  my $in = shift;               # Text of a declaration
 
   #typedef ret_type*(*func) -> typedef ret_type* (*func)
   $in =~ s/\*\(\*/* \(*/;
 
   my $rest  = $in;
-  my $out  = $in;		# Whited out $in
+  my $out  = $in;               # Whited out $in
 
   # Remove all the structs
   while ($out =~ /(\b(struct|union|class|enum)(\s+\w+)?\s*\{)/g) {
@@ -619,7 +619,7 @@
     matchingbrace($out);
     my $pos_end = pos $out;
     substr($out, $pos_start, $pos_end - $pos_start) =
-	' ' x ($pos_end - $pos_start);
+        ' ' x ($pos_end - $pos_start);
     pos $out = $pos_end;
   }
 
@@ -635,7 +635,7 @@
 
       # Remove the __attribute__ tag.
       substr($out, $att_pos_start, $att_pos_end - $att_pos_start) =
-	' ' x ($att_pos_end - $att_pos_start);
+        ' ' x ($att_pos_end - $att_pos_start);
       pos $out = $att_pos_end;
   }
 
@@ -694,7 +694,7 @@
     return 1 if $n < 0;
   }
   # pos($_[0]) is after the closing brace now
-  return;				# false
+  return;                               # false
 }
 
 sub remove_Comments_no_Strings { # We expect that no strings are around
@@ -704,30 +704,30 @@
     $in;
 }
 
-sub sanitize {		# We expect that no strings are around
+sub sanitize {          # We expect that no strings are around
     my $in = shift;
     # C and C++, strings and characters
     $in =~ s{ / (
-		 / .*			# C++ style
-		 |
-		 \* [\s\S]*? \*/	# C style
-		)			# (1)
-	     | '((?:[^\\\']|\\.)+)'	# (2) Character constants
-	     | "((?:[^\\\"]|\\.)*)"	# (3) Strings
-	     | ( ^ \s* \# .* 		# (4) Preprocessor
-		 ( \\ $ \n .* )* )	# and continuation lines
-	    } {
-	      # We want to preserve the length, so that one may go back
-	      defined $1 ? ' ' x (1 + length $1) :
-		defined $4 ? ' ' x length $4 :
-		  defined $2 ? "'" . ' ' x length($2) . "'" :
-		    defined $3 ? '"' . ' ' x length($3) . '"' : '???'
-	    }xgem ;
+                 / .*                   # C++ style
+                 |
+                 \* [\s\S]*? \*/        # C style
+                )                       # (1)
+             | '((?:[^\\\']|\\.)+)'     # (2) Character constants
+             | "((?:[^\\\"]|\\.)*)"     # (3) Strings
+             | ( ^ \s* \# .*            # (4) Preprocessor
+                 ( \\ $ \n .* )* )      # and continuation lines
+            } {
+              # We want to preserve the length, so that one may go back
+              defined $1 ? ' ' x (1 + length $1) :
+                defined $4 ? ' ' x length $4 :
+                  defined $2 ? "'" . ' ' x length($2) . "'" :
+                    defined $3 ? '"' . ' ' x length($3) . '"' : '???'
+            }xgem ;
     die "Unfinished comment" if $in =~ m{ /\* }x;
     $in;
 }
 
-sub top_level {			# We expect argument is sanitized
+sub top_level {                 # We expect argument is sanitized
   # Note that this may remove the variable in declaration: int (*func)();
   my $in = shift;
   my $start;
@@ -735,18 +735,18 @@
   while ($in =~ /[\[\{\(]/g ) {
     $start = pos $in;
     matchingbrace($in);
-    substr($out, $start, pos($in) - 1 - $start) 
+    substr($out, $start, pos($in) - 1 - $start)
       = ' ' x (pos($in) - 1 - $start);
   }
   $out;
 }
 
-sub remove_type_decl {		# We suppose that the arg is top-level only.
+sub remove_type_decl {          # We suppose that the arg is top-level only.
   my $in = shift;
   $in =~ s/(\b__extension__)(\s+typedef\b)/(' ' x length $1) . $2/gse;
   $in =~ s/(\btypedef\b.*?;)/' ' x length $1/gse;
   # The following form may appear only in the declaration of the type itself:
-  $in =~ 
+  $in =~
     s/(\b(enum|struct|union|class)\b[\s\w]*\{\s*\}\s*;)/' ' x length $1/gse;
   $in;
 }
@@ -830,10 +830,10 @@
       my $p = 0;
       my $arg;
       while ($top =~ /,/g) {
-	$arg = substr($argstring, $p, pos($top) - 1 - $p);
-	$arg =~ s/^\s+|\s+$//gs;
-	push @args, $arg;
-	$p = pos $top;
+        $arg = substr($argstring, $p, pos($top) - 1 - $p);
+        $arg =~ s/^\s+|\s+$//gs;
+        push @args, $arg;
+        $p = pos $top;
       }
       $arg = substr $argstring, $p;
       $arg =~ s/^\s+|\s+$//gs;
@@ -877,7 +877,7 @@
       $ident = "arg$argnum";
     }
   } else {
-    die "Cannot process declaration `$decl' without an identifier" 
+    die "Cannot process declaration `$decl' without an identifier"
       unless $decl =~ /\G(\w+)/g;
     $ident = $1;
     $pos = pos $decl;
@@ -904,10 +904,10 @@
       my $p = 0;
       my $arg;
       while ($top =~ /,/g) {
-	$arg = substr($argstring, $p, pos($top) - 1 - $p);
-	$arg =~ s/^\s+|\s+$//gs;
-	push @args, $arg;
-	$p = pos $top;
+        $arg = substr($argstring, $p, pos($top) - 1 - $p);
+        $arg =~ s/^\s+|\s+$//gs;
+        push @args, $arg;
+        $p = pos $top;
       }
       $arg = substr $argstring, $p;
       $arg =~ s/^\s+|\s+$//gs;
@@ -930,9 +930,9 @@
 use constant WIN32 => $^O eq 'MSWin32';
 
 sub new {
-    die "usage: C::Preprocessed->new(filename[, defines[, includes[, cpp]]])" 
+    die "usage: C::Preprocessed->new(filename[, defines[, includes[, cpp]]])"
       if @_ < 2 or @_ > 5;
-    my ($class, $filename, $Defines, $Includes, $Cpp) 
+    my ($class, $filename, $Defines, $Includes, $Cpp)
       = (shift, shift, shift, shift, shift);
     $Cpp ||= \%Config::Config;
     my $filedir = dirname $filename || '.';
@@ -980,7 +980,7 @@
 }
 
 sub DESTROY {
-  close($_[0]) 
+  close($_[0])
     or die "Cannot close pipe from `$Config::Config{cppstdin}': err $?, $!\n";
 }
 
Index: lib/ModPerl/BuildMM.pm
===================================================================
--- lib/ModPerl/BuildMM.pm	(.../tags/2_0_3)	(revision 630610)
+++ lib/ModPerl/BuildMM.pm	(.../trunk)	(revision 630610)
@@ -267,7 +267,7 @@
                 my $podpath = catfile $doc_root, $pod;
                 next unless -r $podpath;
 
-                push @target, 
+                push @target,
                     '$(FULLPERL) -I$(INST_LIB) ' .
                     "-I$apache_test_dir -MModPerl::BuildMM " .
                     "-e ModPerl::BuildMM::glue_pod $pm $podpath $blib";
Index: lib/ModPerl/Code.pm
===================================================================
--- lib/ModPerl/Code.pm	(.../tags/2_0_3)	(revision 630610)
+++ lib/ModPerl/Code.pm	(.../trunk)	(revision 630610)
@@ -68,7 +68,7 @@
     },
     PerSrv     => {
         ret  => 'int',
-        args => [{type => 'request_rec', name => 'r'}, 
+        args => [{type => 'request_rec', name => 'r'},
                  {type => 'dummy', name => 'MP_HOOK_RUN_ALL'}],
     },
     Connection => {
@@ -140,7 +140,7 @@
     Srv => ['NONE', @ithread_opts, qw(ENABLE AUTOLOAD MERGE_HANDLERS),
             @hook_flags, 'UNSET','INHERIT_SWITCHES'],
     Dir => [qw(NONE PARSE_HEADERS SETUP_ENV MERGE_HANDLERS GLOBAL_REQUEST UNSET)],
-    Req => [qw(NONE SET_GLOBAL_REQUEST PARSE_HEADERS SETUP_ENV 
+    Req => [qw(NONE SET_GLOBAL_REQUEST PARSE_HEADERS SETUP_ENV
                CLEANUP_REGISTERED PERL_SET_ENV_DIR PERL_SET_ENV_SRV)],
     Interp => [qw(NONE IN_USE PUTBACK CLONED BASE)],
     Handler => [qw(NONE PARSED METHOD OBJECT ANON AUTOLOAD DYNAMIC FAKE)],
@@ -379,7 +379,7 @@
                            "$h_name is disabled for server ",
                            parms->server->server_hostname, NULL);
     }
-    MP_TRACE_d(MP_FUNC, "push \@%s, %s\\n", parms->cmd->name, arg);
+    MP_TRACE_d(MP_FUNC, "push \@%s, %s", parms->cmd->name, arg);
     return $cmd_push(&($av), arg, parms->pool);
 }
 EOF
@@ -451,7 +451,7 @@
             for (keys %lookup) {
                 if (/^(\w)/) {
                     my $gap = " " x ($max_len - length $_);
-                    push @{ $switch{$1} }, 
+                    push @{ $switch{$1} },
                         qq{if (strEQ(str, "$_"))$gap return $lookup{$_};};
                 }
             }
@@ -468,7 +468,7 @@
         }
 
         delete $dumper{None}; #NONE
-        print $h_fh join ' \\'."\n", 
+        print $h_fh join ' \\'."\n",
           "#define ${class}_dump_flags(p, str)",
                      qq{modperl_trace(NULL, "$class flags dump (%s):", str);},
                      map $dumper{$_}, sort keys %dumper;
@@ -552,7 +552,7 @@
         $i += $i;
     }
 
-    print $h_fh join ' \\'."\n", 
+    print $h_fh join ' \\'."\n",
                      '#define MP_TRACE_dump_flags()',
                      qq{modperl_trace(NULL, "mod_perl trace flags dump:");},
                      @dumper;
@@ -785,7 +785,7 @@
     # Fix this by cleaning the @Extensions array.
 
     # Loads @Extensions if not loaded
-    ExtUtils::Embed::static_ext(); 
+    ExtUtils::Embed::static_ext();
 
     @ExtUtils::Embed::Extensions = grep{$_} @ExtUtils::Embed::Extensions;
 
@@ -820,9 +820,9 @@
 
 #backwards compat with older httpd/apr
 #XXX: remove once we require newer httpd/apr
-my %ifdef = map { $_, 1 } 
+my %ifdef = map { $_, 1 }
     qw(APLOG_TOCLIENT APR_LIMIT_NOFILE), # added in ???
-    qw(AP_MPMQ_STARTING AP_MPMQ_RUNNING AP_MPMQ_STOPPING 
+    qw(AP_MPMQ_STARTING AP_MPMQ_RUNNING AP_MPMQ_STOPPING
        AP_MPMQ_MPM_STATE), # added in 2.0.49
     qw(APR_FPROT_USETID APR_FPROT_GSETID
        APR_FPROT_WSTICKY APR_FOPEN_LARGEFILE); # added in 2.0.50?
@@ -887,7 +887,7 @@
           if (strEQ(name, "$name")) {
 EOF
 
-            if ($name eq 'DECLINE_CMD' || 
+            if ($name eq 'DECLINE_CMD' ||
                 $name eq 'DIR_MAGIC_TYPE' ||
                 $name eq 'CRLF') {
                 print $c_fh <<EOF;
@@ -941,9 +941,9 @@
 
     $class = canon_lc(lc $class);
     while (my ($group, $constants) = each %$groups) {
-	push @tags, $group;
+        push @tags, $group;
         my $name = join '_', 'MP_constants', $class, $group;
-	print $c_fh "\nstatic const char *$name [] = { \n",
+        print $c_fh "\nstatic const char *$name [] = { \n",
           (map {
               my @ifdef = constants_ifdef($_);
               s/^($constant_prefixes)_?//o;
@@ -965,12 +965,12 @@
     print $c_fh "\n$proto\n{\n", "   switch (*name) {\n";
 
     for my $key (sort keys %switch) {
-	my $val = $switch{$key};
-	print $c_fh "\tcase '$key':\n";
-	for my $group (@$val) {
+        my $val = $switch{$key};
+        print $c_fh "\tcase '$key':\n";
+        for my $group (@$val) {
             my $name = join '_', 'MP_constants', $class, $group;
-	    print $c_fh qq|\tif(strEQ("$group", name))\n\t   return $name;\n|;
-	}
+            print $c_fh qq|\tif(strEQ("$group", name))\n\t   return $name;\n|;
+        }
         print $c_fh "      break;\n";
     }
 
Index: lib/ModPerl/TestReport.pm
===================================================================
--- lib/ModPerl/TestReport.pm	(.../tags/2_0_3)	(revision 630610)
+++ lib/ModPerl/TestReport.pm	(.../trunk)	(revision 630610)
@@ -65,7 +65,7 @@
     my @lines = "*** Packages of interest status:\n";
 
     for my $package (sort @interesting_packages) {
-        my $vers = exists $packages{$package} 
+        my $vers = exists $packages{$package}
             ? join ", ", sort @{ $packages{$package} }
             : "-";
         push @lines, sprintf "%-${max_len}s: %s", $package, $vers;
Index: lib/ModPerl/TypeMap.pm
===================================================================
--- lib/ModPerl/TypeMap.pm	(.../tags/2_0_3)	(revision 630610)
+++ lib/ModPerl/TypeMap.pm	(.../trunk)	(revision 630610)
@@ -245,7 +245,7 @@
 
     $self->thx_fixup($func);
 
-    my ($status, $failed_type) = 
+    my ($status, $failed_type) =
         $self->can_map($map, $func->{return_type},
             map $_->{type}, @{ $func->{args} });
 
@@ -413,6 +413,7 @@
 apr_lib.h
 apr_general.h
 apr_signal.h
+apr_thread_rwlock.h
 util_script.h
 };
 
Index: lib/Apache2/Reload.pm
===================================================================
--- lib/Apache2/Reload.pm	(.../tags/2_0_3)	(revision 630610)
+++ lib/Apache2/Reload.pm	(.../trunk)	(revision 630610)
@@ -1,185 +0,0 @@
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the "License"); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-package Apache2::Reload;
-
-use strict;
-use warnings FATAL => 'all';
-
-use mod_perl2;
-
-our $VERSION = '0.09';
-
-use Apache2::Const -compile => qw(OK);
-
-use Apache2::Connection;
-use Apache2::ServerUtil;
-use Apache2::RequestUtil;
-
-use ModPerl::Util ();
-
-use vars qw(%INCS %Stat $TouchTime);
-
-%Stat = ($INC{"Apache2/Reload.pm"} => time);
-
-$TouchTime = time;
-
-sub import {
-    my $class = shift;
-    my ($package, $file) = (caller)[0,1];
-
-    $class->register_module($package, $file);
-}
-
-sub package_to_module {
-    my $package = shift;
-    $package =~ s/::/\//g;
-    $package .= ".pm";
-    return $package;
-}
-
-sub module_to_package {
-    my $module = shift;
-    $module =~ s/\//::/g;
-    $module =~ s/\.pm$//g;
-    return $module;
-}
-
-sub register_module {
-    my ($class, $package, $file) = @_;
-    my $module = package_to_module($package);
-
-    if ($file) {
-        $INCS{$module} = $file;
-    }
-    else {
-        $file = $INC{$module};
-        return unless $file;
-        $INCS{$module} = $file;
-    }
-}
-
-sub unregister_module {
-    my ($class, $package) = @_;
-    my $module = package_to_module($package);
-    delete $INCS{$module};
-}
-
-# the first argument is:
-# $c if invoked as 'PerlPreConnectionHandler'
-# $r if invoked as 'PerlInitHandler'
-sub handler {
-    my $o = shift;
-    $o = $o->base_server if ref($o) eq 'Apache2::Connection';
-
-    my $DEBUG = ref($o) && (lc($o->dir_config("ReloadDebug") || '') eq 'on');
-
-    my $TouchFile = ref($o) && $o->dir_config("ReloadTouchFile");
-
-    my $ConstantRedefineWarnings = ref($o) && 
-        (lc($o->dir_config("ReloadConstantRedefineWarnings") || '') eq 'off') 
-            ? 0 : 1;
-
-    my $TouchModules;
-
-    if ($TouchFile) {
-        warn "Checking mtime of $TouchFile\n" if $DEBUG;
-        my $touch_mtime = (stat $TouchFile)[9] || return Apache2::Const::OK;
-        return Apache2::Const::OK unless $touch_mtime > $TouchTime;
-        $TouchTime = $touch_mtime;
-        open my $fh, $TouchFile or die "Can't open '$TouchFile': $!";
-        $TouchModules = <$fh>;
-        chomp $TouchModules if $TouchModules;
-    }
-
-    if (ref($o) && (lc($o->dir_config("ReloadAll") || 'on') eq 'on')) {
-        *Apache2::Reload::INCS = \%INC;
-    }
-    else {
-        *Apache2::Reload::INCS = \%INCS;
-        my $ExtraList = 
-                $TouchModules || 
-                (ref($o) && $o->dir_config("ReloadModules")) || 
-                '';
-        my @extra = split /\s+/, $ExtraList;
-        foreach (@extra) {
-            if (/(.*)::\*$/) {
-                my $prefix = $1;
-                $prefix =~ s/::/\//g;
-                foreach my $match (keys %INC) {
-                    if ($match =~ /^\Q$prefix\E/) {
-                        $Apache2::Reload::INCS{$match} = $INC{$match};
-                    }
-                }
-            }
-            else {
-                Apache2::Reload->register_module($_);
-            }
-        }
-    }
-
-    my $ReloadDirs = ref($o) && $o->dir_config("ReloadDirectories");
-    my @watch_dirs = split(/\s+/, $ReloadDirs||'');
-    
-    my @changed;
-    foreach my $key (sort { $a cmp $b } keys %Apache2::Reload::INCS) {
-        my $file = $Apache2::Reload::INCS{$key};
-
-        next unless defined $file;
-        next if @watch_dirs && !grep { $file =~ /^$_/ } @watch_dirs;
-        warn "Apache2::Reload: Checking mtime of $key\n" if $DEBUG;
-
-        my $mtime = (stat $file)[9];
-
-        unless (defined($mtime) && $mtime) {
-            for (@INC) {
-                $mtime = (stat "$_/$file")[9];
-                last if defined($mtime) && $mtime;
-            }
-        }
-
-        warn("Apache2::Reload: Can't locate $file\n"), next
-            unless defined $mtime and $mtime;
-
-        unless (defined $Stat{$file}) {
-            $Stat{$file} = $^T;
-        }
-
-        if ($mtime > $Stat{$file}) {
-            push @changed, $key;
-        }
-        $Stat{$file} = $mtime;
-    }
-    
-    #First, let's unload all changed modules
-    foreach my $module (@changed) {
-        my $package = module_to_package($module);
-        ModPerl::Util::unload_package($package);
-    }
-    
-    #Then, let's reload them all, so that module dependencies can satisfy
-    #themselves in the correct order.
-    foreach my $module (@changed) {
-        my $package = module_to_package($module);
-        require $module;
-        warn("Apache2::Reload: process $$ reloading $package from $module\n")
-            if $DEBUG;
-    }
-
-    return Apache2::Const::OK;
-}
-
-1;
-__END__
Index: lib/Apache2/SizeLimit.pm
===================================================================
--- lib/Apache2/SizeLimit.pm	(.../tags/2_0_3)	(revision 630610)
+++ lib/Apache2/SizeLimit.pm	(.../trunk)	(revision 630610)
@@ -80,7 +80,7 @@
 #  Currently unsupported for mp2 because of threads...
 #     }
 #      elsif (WIN32) {
-# 
+#
 #         if ( eval { require Win32::API } ) {
 #             $HOW_BIG_IS_IT = \&win32_size_check;
 #         }
@@ -142,7 +142,7 @@
 # rss is in KB but ixrss is in BYTES.
 # This is true on at least FreeBSD, OpenBSD, NetBSD
 # Philip M. Gollucci
-sub _bsd_size_check {
+sub bsd_size_check {
 
     my @results = BSD::Resource::getrusage();
     my $max_rss   = $results[2];
Index: lib/Apache2/PerlSections.pm
===================================================================
--- lib/Apache2/PerlSections.pm	(.../tags/2_0_3)	(revision 630610)
+++ lib/Apache2/PerlSections.pm	(.../trunk)	(revision 630610)
@@ -66,9 +66,9 @@
     {
         no strict 'refs';
         foreach my $package ($self->package) {
-            my @config = map { split /\n/ } 
-                            grep { defined } 
-                                (@{"${package}::$special"}, 
+            my @config = map { split /\n/ }
+                            grep { defined }
+                                (@{"${package}::$special"},
                                  ${"${package}::$special"});
             $self->dump_special(@config);
         }
@@ -79,6 +79,8 @@
     Apache2::Const::OK;
 }
 
+my %directives_seen_hack;
+
 sub symdump {
     my ($self) = @_;
 
@@ -87,7 +89,7 @@
 
         $self->{symbols} = [];
 
-        #XXX: Here would be a good place to warn about NOT using 
+        #XXX: Here would be a good place to warn about NOT using
         #     Apache2::ReadConfig:: directly in <Perl> sections
         foreach my $pack ($self->package, $self->SPECIAL_PACKAGE) {
             #XXX: Shamelessly borrowed from Devel::Symdump;
@@ -95,11 +97,14 @@
                 #We don't want to pick up stashes...
                 next if ($key =~ /::$/);
                 local (*ENTRY) = $val;
-                if (defined $val && defined *ENTRY{SCALAR}) {
+                if (defined $val && defined *ENTRY{SCALAR} && defined $ENTRY) {
                     push @{$self->{symbols}}, [$key, $ENTRY];
                 }
                 if (defined $val && defined *ENTRY{ARRAY}) {
-                    push @{$self->{symbols}}, [$key, \@ENTRY];
+                    unless (exists $directives_seen_hack{"$key$val"}) {
+                        $directives_seen_hack{"$key$val"} = 1;
+                        push @{$self->{symbols}}, [$key, \@ENTRY];
+                    }
                 }
                 if (defined $val && defined *ENTRY{HASH} && $key !~ /::/) {
                     push @{$self->{symbols}}, [$key, \%ENTRY];
Index: lib/Apache2/ParseSource.pm
===================================================================
--- lib/Apache2/ParseSource.pm	(.../tags/2_0_3)	(revision 630610)
+++ lib/Apache2/ParseSource.pm	(.../trunk)	(revision 630610)
@@ -79,7 +79,7 @@
 
 
 # some types c-scan failing to resolve
-push @c_scan_defines, map { "$_=void" } 
+push @c_scan_defines, map { "$_=void" }
     qw(PPADDR_t PerlExitListEntry modperl_tipool_vtbl_t);
 
 sub scan {
Index: lib/Apache2/Build.pm
===================================================================
--- lib/Apache2/Build.pm	(.../tags/2_0_3)	(revision 630610)
+++ lib/Apache2/Build.pm	(.../trunk)	(revision 630610)
@@ -1592,7 +1592,10 @@
     return $self->dynamic_link_header_default .
         "\t$defs" .
         ($symbols ? ' \\' . "\n\t-pdb:$symbols" : '') .
-        ' -out:$@' . "\n\n";
+        ' -out:$@' . "\n\t" .
+        'if exist $(MODPERL_MANIFEST_LOCATION)' . " \\\n\t" .
+        'mt /nologo /manifest $(MODPERL_MANIFEST_LOCATION)' . " \\\n\t" .
+        '/outputresource:$@;2' . "\n\n";
 }
 
 sub dynamic_link_aix {
@@ -1838,6 +1841,12 @@
     if ($self->is_dynamic && (my $libs = $self->modperl_libpath)) {
         print $fh $self->canon_make_attr('lib_location', $libs);
 
+        # Visual Studio 8 on Win32 uses manifest files
+        if (WIN32) {
+            (my $manifest = $libs) =~ s/\.lib$/.so.manifest/;
+            print $fh $self->canon_make_attr('manifest_location', $manifest);
+        }
+
         print $fh $self->canon_make_attr('ap_libdir',
             $self->ap_destdir(catdir $self->{MP_AP_PREFIX}, 'lib')
         );
@@ -1938,7 +1947,7 @@
 clean:
 	$(MODPERL_RM_F) *.a *.so *.xsc \
 	$(MODPERL_LIBNAME).exp $(MODPERL_LIBNAME).lib \
-	*$(MODPERL_OBJ_EXT) *.lo *.i *.s *.pdb \
+	*$(MODPERL_OBJ_EXT) *.lo *.i *.s *.pdb *.manifest \
 	$(MODPERL_CLEAN_FILES) \
 	$(MODPERL_XS_CLEAN_FILES)
 
Index: lib/Apache2/porting.pm
===================================================================
--- lib/Apache2/porting.pm	(.../tags/2_0_3)	(revision 630610)
+++ lib/Apache2/porting.pm	(.../trunk)	(revision 630610)
@@ -32,7 +32,7 @@
 # - removed and replaced methods
 # - hinting the package names in which methods reside
 
-my %avail_methods = map { $_ => 1 } 
+my %avail_methods = map { $_ => 1 }
     (ModPerl::MethodLookup::avail_methods(),
      ModPerl::MethodLookup::avail_methods_compat());
 
Index: lib/Apache2/Status.pm
===================================================================
--- lib/Apache2/Status.pm	(.../tags/2_0_3)	(revision 630610)
+++ lib/Apache2/Status.pm	(.../trunk)	(revision 630610)
@@ -60,8 +60,8 @@
     lexinfo     => ["StatusLexInfo",     "B::LexInfo",     0,    ],
     xref        => ["StatusXref",        "B::Xref",        1.01, ],
     terse       => ["StatusTerse",       "B::Terse",       0,    ],
-    tersesize   => ["StatusTerseSize",   "B::TerseSize",   0.07, ],
-    packagesize => ["StatusPackageSize", "B::TerseSize",   0.07, ],
+    tersesize   => ["StatusTerseSize",   "B::TerseSize",   0.09, ],
+    packagesize => ["StatusPackageSize", "B::TerseSize",   0.09, ],
     peek        => ["StatusPeek",        "Apache::Peek",   1.03, ],
 );
 
@@ -201,7 +201,7 @@
     my $uri = $r->uri;
     my @retval = (
         '<table border="1">',
-        "<tr>", 
+        "<tr>",
         (map "<td><b>$_</b></td>", qw(Package Version Modified File)),
         "</tr>\n"
     );
@@ -221,8 +221,8 @@
             'N/A';
 
         push @retval, (
-            "<tr>", 
-            (map "<td>$_</td>", 
+            "<tr>",
+            (map "<td>$_</td>",
                 qq(<a href="$uri?$module">$module</a>),
                 $v, $mtime, $INC{$file}),
             "</tr>\n"
@@ -243,7 +243,7 @@
 
     foreach my $file (sort keys %INC) {
         next if $file =~ m:\.(pm|al|ix)$:;
-        push @retval, 
+        push @retval,
             qq(<tr><td>$file</td><td>$INC{$file}</td></tr>\n);
     }
     push @retval, "</table>";
@@ -394,14 +394,14 @@
     $obj->can('FILEGV') ? $obj->FILEGV->SV->PV : $obj->FILE;
 }
 
-sub status_cv_dump { 
+sub status_cv_dump {
     my ($r) = @_;
     return [] unless has($r, "b");
 
     no strict 'refs';
     my ($name, $type) = (split "/", $r->uri)[-2,-1];
     # could be another child, which doesn't have this symbol table?
-    return unless *$name{CODE}; 
+    return unless *$name{CODE};
 
     my @retval = "<p>Subroutine info for <b>$name</b></p>\n<pre>\n";
     my $obj    = B::svref_2object(*$name{CODE});
@@ -409,7 +409,7 @@
     my $stash  = $obj->GV->STASH->NAME;
     my $script = $r->location;
 
-    push @retval, "File: ", 
+    push @retval, "File: ",
         (-e $file ? qq(<a href="file:$file">$file</a>) : $file), "\n";
 
     my $cv    = $obj->GV->CV;
@@ -563,11 +563,11 @@
         }
         elsif ($name =~ /^\*(\w+)\{(\w+)\}/) {
             my $link = qq(<a href="$script/$package\::$1/$2?data_dump">);
-            $r->printf("$link%-${nlen}s</a> %${slen}d bytes\n", 
+            $r->printf("$link%-${nlen}s</a> %${slen}d bytes\n",
                        $name, $stats->{size});
         }
         else {
-            my $link = 
+            my $link =
                 qq(<a href="$script/slow/$package\::$name?noh_b_terse_size">);
             $r->printf("$link%-${nlen}s</a> %${slen}d bytes | %${clen}d OPs\n",
                        $name, $stats->{size}, $stats->{count});
@@ -592,7 +592,7 @@
 
     my $name = (split "/", $r->uri)[-1];
     $r->print("Deparse of $name\n\n");
-    my $deparse = B::Deparse->new(split /\s+/, 
+    my $deparse = B::Deparse->new(split /\s+/,
                                   $r->dir_config('StatusDeparseOptions')||"");
     my $body = $deparse->coderef2text(\&{$name});
     $r->print("sub $name $body");
@@ -615,7 +615,7 @@
 
     my $name = (split "/", $r->uri)[-1];
     $r->print("Fathom Score of $name\n\n");
-    my $fathom = B::Fathom->new(split /\s+/, 
+    my $fathom = B::Fathom->new(split /\s+/,
                                 $r->dir_config('StatusFathomOptions')||"");
     $r->print($fathom->fathom(\&{$name}));
 }
@@ -772,7 +772,7 @@
 
     my @methods = sort keys %{$self->{'AUTOLOAD'}};
 
-    if ($is_main) { 
+    if ($is_main) {
         @methods = grep { $_ ne "packages" } @methods;
         unshift @methods, "packages";
     }
@@ -783,7 +783,7 @@
         my @line = ();
 
         for (sort $self->_partdump(uc $type)) {
-            s/([\000-\037\177])/ '^' . pack('c', ord($1) ^ 64)/eg; 
+            s/([\000-\037\177])/ '^' . pack('c', ord($1) ^ 64)/eg;
 
             if ($type eq "scalars") {
                 no strict 'refs';
Index: lib/Apache2/compat.pm
===================================================================
--- lib/Apache2/compat.pm	(.../tags/2_0_3)	(revision 630610)
+++ lib/Apache2/compat.pm	(.../trunk)	(revision 630610)
@@ -310,7 +310,7 @@
 
 package Apache::Server;
 # XXX: is that good enough? see modperl/src/modules/perl/mod_perl.c:367
-our $CWD = Apache2::ServerUtil::server_root;
+our $CWD = Apache2::ServerUtil::server_root();
 
 our $AddPerlVersion = 1;
 
@@ -321,6 +321,10 @@
 
 package Apache;
 
+sub request {
+    return Apache2::compat::request(@_);
+}
+
 sub unescape_url_info {
     my ($class, $string) = @_;
     Apache2::URI::unescape_url($string);
@@ -344,7 +348,7 @@
          return File::Spec->catfile(@_);
     }
     else {
-        File::Spec->catfile(Apache2::ServerUtil::server_root, @_);
+        File::Spec->catfile(Apache2::ServerUtil::server_root(), @_);
     }
 }
 
@@ -486,18 +490,18 @@
     my ($key, $value) = @_;
 
     if (1 == @_) {
-        return wantarray() 
+        return wantarray()
             ?       ($table->get($key))
             : scalar($table->get($key));
     }
     elsif (2 == @_) {
         if (defined $value) {
-            return wantarray() 
+            return wantarray()
                 ?        ($table->set($key, $value))
                 :  scalar($table->set($key, $value));
         }
         else {
-            return wantarray() 
+            return wantarray()
                 ?       ($table->unset($key))
                 : scalar($table->unset($key));
         }
@@ -513,21 +517,21 @@
 
 sub header_out {
     my $r = shift;
-    return wantarray() 
+    return wantarray()
         ?       ($r->table_get_set(scalar($r->headers_out), @_))
         : scalar($r->table_get_set(scalar($r->headers_out), @_));
 }
 
 sub header_in {
     my $r = shift;
-    return wantarray() 
+    return wantarray()
         ?       ($r->table_get_set(scalar($r->headers_in), @_))
         : scalar($r->table_get_set(scalar($r->headers_in), @_));
 }
 
 sub err_header_out {
     my $r = shift;
-    return wantarray() 
+    return wantarray()
         ?       ($r->table_get_set(scalar($r->err_headers_out), @_))
         : scalar($r->table_get_set(scalar($r->err_headers_out), @_));
 }
@@ -596,7 +600,7 @@
 
 sub server_root_relative {
     my $r = shift;
-    File::Spec->catfile(Apache2::ServerUtil::server_root, @_);
+    File::Spec->catfile(Apache2::ServerUtil::server_root(), @_);
 }
 
 sub clear_rgy_endav {
Index: lib/mod_perl2.pm
===================================================================
--- lib/mod_perl2.pm	(.../tags/2_0_3)	(revision 630610)
+++ lib/mod_perl2.pm	(.../trunk)	(revision 630610)
@@ -19,7 +19,7 @@
 use strict;
 
 BEGIN {
-    our $VERSION = "2.000003";
+    our $VERSION = "2.000004";
     our $VERSION_TRIPLET;
 
     if ($VERSION =~ /(\d+)\.(\d\d\d)(\d+)/) {
Index: ModPerl-Registry/t/conf/modperl_extra_startup.pl
===================================================================
--- ModPerl-Registry/t/conf/modperl_extra_startup.pl	(.../tags/2_0_3)	(revision 630610)
+++ ModPerl-Registry/t/conf/modperl_extra_startup.pl	(.../trunk)	(revision 630610)
@@ -31,7 +31,7 @@
 # test the scripts pre-loading by using trans sub
 {
     sub trans {
-        my $uri = shift; 
+        my $uri = shift;
         $uri =~ s|^/registry_bb/|cgi-bin/|;
         return Apache2::ServerUtil::server_root_relative($pool, $uri);
     }
Index: ModPerl-Registry/t/conf/extra.conf.in
===================================================================
--- ModPerl-Registry/t/conf/extra.conf.in	(.../tags/2_0_3)	(revision 630610)
+++ ModPerl-Registry/t/conf/extra.conf.in	(.../trunk)	(revision 630610)
@@ -21,12 +21,6 @@
 # run on startup
 PerlRequire @ServerRoot@/conf/modperl_extra_startup.pl
 
-#### DEVMODE: Remove in production ###
-PerlModule Apache2::Reload
-PerlInitHandler Apache2::Reload
-PerlSetVar ReloadAll Off
-PerlSetVar ReloadModules "ModPerl::*"
-
 PerlSetVar ModPerl::RegistryCooker::DEBUG 2
 
 PerlModule ModPerl::RegistryCooker
@@ -45,6 +39,7 @@
     Alias /perlrun_prefork/  @ServerRoot@/cgi-bin/
     Alias /nph/              @ServerRoot@/cgi-bin/
     Alias /registry_modperl_handler/  @ServerRoot@/cgi-bin/
+    Alias /rewrite_env/      @ServerRoot@/cgi-bin/
 
     ScriptAlias /cgi-bin/ @ServerRoot@/cgi-bin/
 </IfModule>
@@ -220,3 +215,19 @@
 # </sandbox-friendly>
 
 
+<IfModule mod_rewrite.c>
+
+    RewriteEngine On
+    RewriteLogLevel 9
+    RewriteLog @ServerRoot@/logs/rewrite_log
+    RewriteRule /rewritetest /rewrite_env/env_val.pl?REWRITE_TEST [E=REWRITE_TEST:GOTCHA,PT,NS,L]
+
+    <Location /rewrite_env>
+        SetHandler perl-script
+        PerlResponseHandler ModPerl::Registry
+        Options +ExecCGI
+        PerlOptions +ParseHeaders
+    </Location>
+</IfModule>
+
+
Index: ModPerl-Registry/t/rewrite_env.t
===================================================================
--- ModPerl-Registry/t/rewrite_env.t	(.../tags/2_0_3)	(revision 0)
+++ ModPerl-Registry/t/rewrite_env.t	(.../trunk)	(revision 630610)
@@ -0,0 +1,17 @@
+use strict;
+use warnings FATAL => 'all';
+
+use Apache::Test;
+use Apache::TestUtil;
+use Apache::TestRequest qw(GET);
+
+plan tests => 1, need [qw(mod_alias.c mod_rewrite.c)];
+
+{
+    my $url = "/rewritetest";
+    my $res = GET $url;
+
+    ok t_cmp($res->content(),
+             "GOTCHA",
+             'found environment variable from mod_rewrite');
+}
Index: ModPerl-Registry/t/cgi-bin/env_val.pl
===================================================================
--- ModPerl-Registry/t/cgi-bin/env_val.pl	(.../tags/2_0_3)	(revision 0)
+++ ModPerl-Registry/t/cgi-bin/env_val.pl	(.../trunk)	(revision 630610)
@@ -0,0 +1,7 @@
+# test env vars
+
+print "Content-type: text/plain\n\n";
+my $var = $ENV{QUERY_STRING};
+print exists $ENV{$var} && $ENV{$var};
+
+__END__

Property changes on: ModPerl-Registry/t/cgi-bin/env_val.pl
___________________________________________________________________
Name: svn:executable
   + *

Index: ModPerl-Registry/t/cgi-bin/perlrun_extload.pl
===================================================================
--- ModPerl-Registry/t/cgi-bin/perlrun_extload.pl	(.../tags/2_0_3)	(revision 630610)
+++ ModPerl-Registry/t/cgi-bin/perlrun_extload.pl	(.../trunk)	(revision 630610)
@@ -19,7 +19,7 @@
     # original function's prototype doesn't match the aliases prototype.
     # see decl_proto()
     BEGIN { t_server_log_warn_is_expected()
-                if perlrun_decl->can("decl_proto"); 
+                if perlrun_decl->can("decl_proto");
     }
     use perlrun_decl;
 
Index: ModPerl-Registry/t/regex.t
===================================================================
--- ModPerl-Registry/t/regex.t	(.../tags/2_0_3)	(revision 0)
+++ ModPerl-Registry/t/regex.t	(.../trunk)	(revision 630610)
@@ -0,0 +1,33 @@
+use strict;
+use warnings FATAL => 'all';
+
+use Apache::Test;
+use Apache::TestUtil qw(t_cmp t_catfile_apache);
+use Apache::TestRequest;
+use Apache::TestConfig ();
+
+my %modules = (
+    registry    => 'ModPerl::Registry',
+    registry_bb => 'ModPerl::RegistryBB',
+    perlrun     => 'ModPerl::PerlRun',
+);
+
+my @aliases = sort keys %modules;
+
+plan tests => @aliases * 1, need 'mod_alias.c';
+
+my $vars = Apache::Test::config()->{vars};
+my $script_file = t_catfile_apache $vars->{serverroot}, 'cgi-bin', 'basic.pl';
+
+# extended regex quoting
+# CVE-2007-1349 (which doesn't affect any of our shipped handlers)
+
+for my $alias (@aliases) {
+    my $url = "/$alias/basic.pl/(";
+
+    ok t_cmp(
+        GET_BODY($url),
+        "ok $script_file",
+        "$modules{$alias} regex in path_info",
+    );
+}
Index: ModPerl-Registry/lib/ModPerl/RegistryCooker.pm
===================================================================
--- ModPerl-Registry/lib/ModPerl/RegistryCooker.pm	(.../tags/2_0_3)	(revision 630610)
+++ ModPerl-Registry/lib/ModPerl/RegistryCooker.pm	(.../trunk)	(revision 630610)
@@ -326,7 +326,7 @@
 sub namespace_from_filename {
     my $self = shift;
 
-    my ($volume, $dirs, $file) = 
+    my ($volume, $dirs, $file) =
         File::Spec::Functions::splitpath($self->{FILENAME});
     my @dirs = File::Spec::Functions::splitdir($dirs);
     return join '_', grep { defined && length } $volume, @dirs, $file;
@@ -337,11 +337,11 @@
     my $self = shift;
 
     my $path_info = $self->{REQ}->path_info;
-    my $script_name = $path_info && $self->{URI} =~ /$path_info$/
+    my $script_name = $path_info && $self->{URI} =~ /\Q$path_info\E$/
         ? substr($self->{URI}, 0, length($self->{URI}) - length($path_info))
         : $self->{URI};
 
-    if ($ModPerl::RegistryCooker::NameWithVirtualHost && 
+    if ($ModPerl::RegistryCooker::NameWithVirtualHost &&
         $self->{REQ}->server->is_virtual) {
         my $name = $self->{REQ}->get_server_name;
         $script_name = join "", $name, $script_name if $name;
@@ -486,7 +486,7 @@
 sub should_compile_if_modified {
     my $self = shift;
     $self->{MTIME} ||= -M $self->{REQ}->my_finfo;
-    !($self->is_cached && 
+    !($self->is_cached &&
       $self->cache_table->{ $self->{PACKAGE} }{mtime} <= $self->{MTIME});
 }
 
@@ -546,9 +546,8 @@
             return Apache2::Const::FORBIDDEN if APR::Status::is_EACCES($@);
             return Apache2::Const::NOT_FOUND if APR::Status::is_ENOENT($@);
         }
-        else {
-            return Apache2::Const::SERVER_ERROR;
-        }
+
+        return Apache2::Const::SERVER_ERROR;
     }
 
     return Apache2::Const::OK;
@@ -611,7 +610,7 @@
 # dflt: NOP
 # desc: chdirs into $dir
 # args: $self - registry blessed object
-#       $dir - a dir 
+#       $dir - a dir
 # rtrn: nothing (?or success/failure?)
 #########################################################################
 
@@ -671,9 +670,9 @@
     ModPerl::Global::special_list_clear(   END => $self->{PACKAGE});
 
     {
-        # let the code define its own warn and strict level 
+        # let the code define its own warn and strict level
         no strict;
-        no warnings FATAL => 'all'; # because we use FATAL 
+        no warnings FATAL => 'all'; # because we use FATAL
         eval $$eval;
     }
 
Index: Changes
===================================================================
--- Changes	(.../tags/2_0_3)	(revision 630610)
+++ Changes	(.../trunk)	(revision 630610)
@@ -10,6 +10,106 @@
 
 =over 3
 
+=item 2.0.4-dev
+
+Fix $r->location corruption under certain conditions
+[Gozer]
+
+Fix a crash when spawning Perl threads under Perl 5.10
+[Gozer]
+
+Fix erratic behaviour when filters were used with Perl 5.10
+[Gozer]
+
+Fix problems with redefinitions of perl_free as free and perl_malloc
+as malloc on Win32, as described at
+ http://marc.info/?l=apache-modperl&m=119896407510526&w=2
+[Tom Donovan]
+
+Fix a crash when running a sub-request from within a filter where
+mod_perl was not the content handler. [Gozer]
+
+Refactor tests to use keepalives instead of same_interp [Gozer, Phred]
+
+Apache2::Reload has been moved to an externally maintained
+CPAN distribution [Fred Moyer <fred@redhotpenguin.com>]
+
+PerlCleanupHandler are now registered with a subpool of $r->pool,
+instead of $r->pool itself, ensuring they run _before_ any other
+$r->pool cleanups [Torsten Foertsch]
+
+Fix a bug that would prevent pnotes from being cleaned up proprely
+at the end of the request [Torsten Foertsch]
+
+On Win32, embed the manifest file, if present, in mod_perl.so,
+so as to work with VC 8 [Steve Hay, Randy Kobes]
+
+Expose apr_thread_rwlock_t with the APR::ThreadRWLock module
+[Torsten Foertsch]
+
+Don't waste an extra interpreter anymore under threaded MPMs when using a 
+modperl handler [Torsten Foertsch] 
+
+Fix a bug that could cause a crash when using $r->push_handlers() multiple
+times for a phase that has no configured handlers [Torsten Foertsch]
+
+Catch up with some httpd API changes
+  2.2.4: 
+   The full server version information is now included in the error log at
+startup as well as server status reports, irrespective of the setting
+of the ServerTokens directive. ap_get_server_version() is now
+deprecated, and is replaced by ap_get_server_banner() and
+ap_get_server_description(). [Jeff Trawick]
+
+  2.3.0:
+ap_get_server_version() has been removed. Third-party modules must
+now use ap_get_server_banner() or ap_get_server_description().
+[Gozer]
+
+fixed Apache2::compat Apache2::ServerUtil::server_root() resolution
+issues [Joshua Hoblitt]
+
+*) SECURITY: CVE-2007-1349 (cve.mitre.org)
+fix unescaped variable interprolation in regular expression
+[Randal L. Schwartz <merlyn@stonehenge.com>, Fred Moyer <fred@redhotpenguin.com>]
+
+Make $r->the_request() writeable
+[Fred Moyer <fred@redhotpenguin.com>]
+
+fix ModPerl::RegistryCooker::read_script to handle all possible
+errors, previously there was a case where Apache2::Const::OK was
+returned on an error.  [Eivind Eklund <eeklund@gmail.com>]
+
+a minor compilation warning resolved in modperl_handler_new_from_sv
+[Stas]
+
+a minor compilation warning resolved in modperl_gtop_size_string
+[Stas]
+
+Prevent direct use of _deprecated_ Apache2::ReadConfig in
+<Perl> sections with httpd Alias directives from 
+incorrectly generating
+'The Alias directive in xxxxx at line y will probably never match'
+messages.
+[Philip M. Gollucci <pgollucci@p6m78g.com>]
+
+Prevent Apache2::PerSections::symdump() from returning invalid
+httpd.conf snippets like 'Alias undef'
+[Philip M. Gollucci <pgollucci@p6m78g.com>]
+
+Require B-Size 0.9 for Apache2::Status which fixes
+Can't call method "script_name" on an undefined value
+[Philip M. Gollucci <pgollucci@p6m78g.com>]
+
+-march=pentium4 or anything with an = in it in CCFLAGS or @ARGV
+that gets passed to xs/APR/APR/Makefile.PL broke the @ARGV
+parsing.  I.E. FreeBSD port builds when users had CPUTYPE
+set in /etc/make.conf.
+[Philip M. Gollucci <pgollucci@p6m7g8.com>]
+
+Fixes to get bleed-ithread (5.9.5+) to comile again. 
+[Philip M. Gollucci <pgollucci@p6m7g8.com>]
+
 =item 2.0.3 November 28, 2006
 
 Prevent things in %INC that are not stat() able

Property changes on: .
___________________________________________________________________
Name: svnmerge-integrated
   + /perl/modperl/branches/threading:1-584361
Name: svn:externals
   - Apache-Test https://svn.apache.org/repos/asf/perl/Apache-Test/tags/1_29
docs        https://svn.apache.org/repos/asf/perl/modperl/docs/tags/2_0_3/src/docs/2.0

   + Apache-Test https://svn.apache.org/repos/asf/perl/Apache-Test/trunk
docs        https://svn.apache.org/repos/asf/perl/modperl/docs/trunk/src/docs/2.0


